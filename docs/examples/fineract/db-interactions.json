[
  {
    "path": "fineract-db/multi-tenant-demo-backups/ceda/README.md",
    "mechanism": "DDL",
    "name": "CEDA Microfinance Demo Database",
    "description": "The text describes a database initialization package containing DDL scripts for schema creation and DML for reference data insertion. It specifically targets the customization of code tables and the addition of new tables for client and loan data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_code",
      "m_code_value",
      "client datatables",
      "loan datatables"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "Schema creation (DDL) and reference data insertion (DML).",
    "transactionHandling": "unknown",
    "protocol": "SQL",
    "connectionInfo": "unknown",
    "codeExample": "n/a"
  },
  {
    "path": "fineract-db/old-schema-files/0001a-mifosplatform-core-ddl-latest.sql",
    "mechanism": "DDL",
    "description": "The file is a raw SQL script used to define the database schema for a core banking application. It does not use an ORM or application code directly but is likely executed by a database migration tool or during initial system setup. It defines the structure for a relational database (MySQL/MariaDB) including tables, columns, data types, and foreign key constraints.",
    "databaseName": "Mifos X / Apache Fineract (Inferred)",
    "tablesAccessed": [
      "m_currency",
      "m_organisation_currency",
      "c_configuration",
      "m_code",
      "m_code_value",
      "m_document",
      "r_enum_value",
      "x_registered_table",
      "m_calendar",
      "m_calendar_instance",
      "m_office",
      "m_office_transaction",
      "m_permission",
      "m_role",
      "m_role_permission",
      "m_appuser",
      "m_appuser_role",
      "m_portfolio_command_source",
      "m_charge",
      "m_fund",
      "m_staff",
      "m_group_level",
      "m_group",
      "m_client",
      "m_client_identifier",
      "m_group_client",
      "m_product_loan",
      "m_product_loan_charge",
      "m_loan",
      "m_loan_arrears_aging",
      "m_guarantor",
      "m_loan_charge",
      "m_loan_collateral",
      "m_loan_officer_assignment_history",
      "m_loan_repayment_schedule",
      "m_loan_transaction",
      "m_savings_product",
      "m_savings_account",
      "m_savings_account_transaction",
      "m_note",
      "acc_gl_account",
      "acc_gl_closure",
      "acc_gl_journal_entry",
      "acc_product_mapping",
      "rpt_sequence",
      "stretchy_parameter",
      "stretchy_report",
      "stretchy_report_parameter"
    ],
    "operationType": [
      "DDL"
    ],
    "queryPatterns": "CREATE TABLE statements, DROP TABLE statements, Foreign Key definitions",
    "transactionHandling": "Implicit DDL transactions (SET foreign_key_checks)",
    "protocol": "MySQL / MariaDB (InnoDB)",
    "codeExample": "CREATE TABLE `m_currency` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `code` varchar(3) NOT NULL,\n  `decimal_places` SMALLINT NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/latam-demo/README.md",
    "mechanism": "DDL",
    "name": "latam Demo Database",
    "description": "The documentation describes the initialization script for a demo database, including the Data Definition Language (DDL) for the schema and Data Manipulation Language (DML) for seeding reference data.",
    "databaseName": "latam Demo",
    "tablesAccessed": [
      "currency",
      "office",
      "permission",
      "role",
      "app_user",
      "configuration",
      "code"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "Database schema creation and initial reference data seeding.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "DDL of latest schema\n- Minimum reference data required for deployment of platform"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/latam-demo/bk_latam.sql",
    "mechanism": "DDL",
    "name": "fineract_default",
    "description": "The file is a MySQL database dump that primarily uses Data Definition Language (DDL) to create the database schema for the Fineract/Mifos application. It defines tables, primary keys, and foreign key constraints. It also uses Data Manipulation Language (DML) to insert initial seed data into various tables.",
    "databaseName": "fineract_default",
    "tablesAccessed": [
      "acc_gl_account",
      "acc_gl_closure",
      "acc_gl_journal_entry",
      "acc_product_mapping",
      "c_configuration",
      "extra_client_details",
      "extra_family_details",
      "extra_loan_details",
      "m_appuser",
      "m_appuser_role",
      "m_charge",
      "m_client",
      "m_client_identifier",
      "m_code",
      "m_code_value",
      "m_currency",
      "m_deposit_account",
      "m_deposit_account_transaction",
      "m_document",
      "m_fund",
      "m_group",
      "m_group_client",
      "m_guarantor",
      "m_loan",
      "m_loan_charge",
      "m_loan_officer_assignment_history",
      "m_loan_repayment_schedule",
      "m_loan_transaction",
      "m_note",
      "m_office",
      "m_office_transaction",
      "m_organisation_currency",
      "m_permission",
      "m_portfolio_command_source",
      "m_product_deposit",
      "m_product_loan",
      "m_product_loan_charge",
      "m_product_savings",
      "m_role",
      "m_role_permission",
      "m_saving_account",
      "m_saving_account_transaction",
      "m_saving_schedule",
      "m_staff",
      "r_enum_value",
      "rpt_sequence",
      "stretchy_parameter",
      "stretchy_report",
      "stretchy_report_parameter",
      "x_registered_table"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements, INSERT operations, Foreign Key constraints",
    "transactionHandling": "LOCK TABLES / UNLOCK TABLES for bulk inserts",
    "protocol": "MySQL 5.1.60",
    "codeExample": "DROP TABLE IF EXISTS `acc_gl_account`;\nCREATE TABLE `acc_gl_account` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/gk-maarg/0001b-gk-datatables.sql",
    "mechanism": "DDL",
    "name": "Risk Analysis Schema",
    "description": "The code interacts with the database by defining structural elements using SQL DDL. It drops an existing table if present and creates a new one with specific column definitions and constraints.",
    "databaseName": "mifos/fineract (inferred from m_client reference)",
    "tablesAccessed": [
      "risk_analysis",
      "m_client"
    ],
    "operationType": [
      "DDL"
    ],
    "queryPatterns": "CREATE TABLE statements with Foreign Key constraints",
    "transactionHandling": "Implicit DDL transaction handling",
    "protocol": "MySQL / MariaDB (InnoDB)",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "CREATE TABLE `risk_analysis` (\n  `client_id` BIGINT NOT NULL,\n  `proposed_loan_amount` decimal(19,6) DEFAULT NULL,\n  ...\n  CONSTRAINT `FK_risk_analysis_1` FOREIGN KEY (`client_id`) REFERENCES `m_client` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-provider/src/test/resources/features/infrastructure/infrastructure.core.feature",
    "mechanism": "DDL",
    "name": "Liquibase / Flyway",
    "description": "The file contains acceptance tests for the database schema migration process, verifying that Liquibase and Flyway correctly manage schema upgrades for tenant and default databases based on instance configuration.",
    "databaseName": "tenant store, default tenant",
    "tablesAccessed": [
      "schema_version (Flyway)",
      "databasechangelog (Liquibase)",
      "All Application Tables"
    ],
    "operationType": [
      "DDL",
      "ADMIN"
    ],
    "queryPatterns": "Database schema migration execution and version verification",
    "transactionHandling": "Managed implicitly by the migration tools (Liquibase/Flyway) during execution",
    "protocol": "Database Agnostic",
    "connectionInfo": "n/a",
    "codeExample": "Given Liquibase is enabled with a default tenant\n    Given Liquibase runs the very first time for the tenant store\n    Given A previously Flyway migrated tenant store database on the latest version\n    When The database migration process is executed\n    Then The tenant store and the default tenant gets synced and then upgraded"
  },
  {
    "path": "fineract-db/docker/01-databases.sql",
    "mechanism": "DDL",
    "name": "Fineract Database Setup",
    "description": "The file uses raw SQL DDL and DCL commands to provision the database server. It creates specific logical databases required by the application architecture and configures user access rights.",
    "databaseName": "fineract_tenants, fineract_default",
    "tablesAccessed": [],
    "operationType": [
      "DDL",
      "ADMIN"
    ],
    "queryPatterns": "CREATE DATABASE statements and GRANT privilege commands",
    "transactionHandling": "Implicit auto-commit for DDL statements",
    "protocol": "MySQL",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "CREATE DATABASE IF NOT EXISTS `fineract_tenants`;\nCREATE DATABASE IF NOT EXISTS `fineract_default`;\nGRANT ALL ON *.* TO 'root'@'%';"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/bare-bones-demo/README.md",
    "mechanism": "DDL",
    "name": "Demo Database Initialization",
    "description": "The documentation describes the SQL DDL and DML scripts used to initialize the database schema and populate mandatory reference data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "currency",
      "office",
      "permission",
      "role",
      "appuser",
      "code",
      "configuration"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "Database schema creation and initial reference data insertion.",
    "transactionHandling": "unknown",
    "protocol": "SQL",
    "connectionInfo": "n/a",
    "codeExample": "Its mandatory to have one selected currency so we default to US Dollar"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/latam-demo/datatables-on-latam-demo.sql",
    "mechanism": "DDL",
    "name": "Mifos/Fineract Database Extension",
    "description": "The code integrates with the database primarily through SQL scripts that execute DDL commands to define new schema objects and DML commands to seed reference data. It directly interacts with the database engine to create tables and establish foreign key relationships with existing core tables (`m_client`, `m_loan`). The script also performs write operations to insert configuration data into specific tenant schemas.",
    "databaseName": "mifostenant-latam",
    "tablesAccessed": [
      "latam_extra_client_details",
      "latam_family_details",
      "latam_extra_loan_details",
      "m_client",
      "m_loan",
      "m_code",
      "m_code_value"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements with Foreign Key constraints, INSERT statements for reference data",
    "transactionHandling": "Implicit auto-commit per statement (standard SQL script behavior)",
    "protocol": "MySQL / MariaDB (InnoDB Engine)",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "CREATE TABLE `latam_extra_client_details` (\n  `client_id` BIGINT NOT NULL,\n  `Business Description` varchar(100) DEFAULT NULL,\n  PRIMARY KEY (`client_id`),\n  CONSTRAINT `FK_latam_extra_client_details` FOREIGN KEY (`client_id`) REFERENCES `m_client` (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-provider/src/main/resources/sql/migrations/sample_data/tn03_interop_sample_data.sql",
    "mechanism": "DML",
    "name": "Data Initialization Script",
    "description": "The file is a raw SQL script containing Data Manipulation Language (DML) statements used to seed the database with initial test data. It utilizes MySQL-specific user variables to maintain referential integrity between inserted records without needing hardcoded IDs.",
    "databaseName": "tn03",
    "tablesAccessed": [
      "m_client",
      "m_savings_product",
      "m_savings_account",
      "interop_identifier",
      "m_charge",
      "m_savings_account_charge"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "The script uses a pattern of setting variables via SELECT statements to fetch Foreign Keys, followed by INSERT statements using those variables.",
    "transactionHandling": "Implicit transaction handling (auto-commit) is assumed as no explicit BEGIN/COMMIT statements are present.",
    "protocol": "MySQL",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "INSERT INTO interop_identifier (id, account_id, type, a_value, sub_value_or_type, created_by, created_on, modified_by, modified_on)\nVALUES (NULL, @saving_acc_id, 'IBAN', @IBAN, NULL, 'operator', CURDATE(), 'operator',\n        CURDATE());"
  },
  {
    "path": "fineract-db/old-schema-files/0003-mifosx-permissions-and-authorisation-utf8.sql",
    "mechanism": "DML",
    "name": "Mifos/Fineract Database Seeding",
    "description": "The file interacts with the database purely through SQL Data Manipulation Language (DML) scripts. It performs extensive data seeding operations using `INSERT` statements to populate permission, role, and user tables. It also utilizes `INSERT ... SELECT` patterns to dynamically generate data based on the contents of other tables (`x_registered_table`) and performs `UPDATE` operations to set default configuration flags.",
    "databaseName": "Mifos/Fineract (implied by username 'mifos')",
    "tablesAccessed": [
      "m_permission",
      "m_role",
      "m_role_permission",
      "m_appuser",
      "m_appuser_role",
      "x_registered_table"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "Bulk INSERT statements, INSERT-SELECT subqueries for dynamic data generation, and bulk UPDATE statements.",
    "transactionHandling": "Implicit transaction handling typical of SQL script execution (Auto-commit unless wrapped externally).",
    "protocol": "MySQL / MariaDB (indicated by backtick usage)",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "INSERT INTO `m_permission`\n(`grouping`,`code`,`entity_name`,`action_name`,`can_maker_checker`) VALUES\n('special','ALL_FUNCTIONS',NULL,NULL,0),\n('special','ALL_FUNCTIONS_READ',NULL,NULL,0),\n('special', 'CHECKER_SUPER_USER', NULL, NULL, '0');"
  },
  {
    "path": "fineract-db/old-schema-files/0002-mifosx-base-reference-data-utf8.sql",
    "mechanism": "DML",
    "name": "Reference Data Seeding",
    "description": "The file consists entirely of SQL DML statements used to insert initial seed data into the database. It interacts directly with the database tables to populate rows for configurations, enums, currencies, and organizational structures using standard INSERT syntax and INSERT-SELECT patterns.",
    "databaseName": "Mifos/Fineract Schema",
    "tablesAccessed": [
      "c_configuration",
      "r_enum_value",
      "m_currency",
      "m_organisation_currency",
      "m_office",
      "m_group_level",
      "m_code",
      "m_code_value"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Bulk INSERT statements and INSERT INTO ... SELECT subqueries for referential integrity.",
    "transactionHandling": "Implicit transaction handling typical of SQL scripts.",
    "protocol": "MySQL / SQL Standard",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "INSERT INTO `c_configuration`\n(`name`, `enabled`)\nVALUES\n('maker-checker', 0);"
  },
  {
    "path": "fineract-db/old-schema-files/0004-mifosx-core-reports-utf8.sql",
    "mechanism": "DML",
    "name": "Reporting Module Configuration",
    "description": "The file uses Data Manipulation Language (DML) to populate configuration tables that drive a dynamic reporting engine. It uses TRUNCATE to clear tables and INSERT to add report definitions. Notably, the 'stretchy_report' table stores raw SQL SELECT statements as string data within the 'report_sql' column; these stored queries perform complex joins across the master data tables (m_office, m_client, m_loan) when executed by the application layer.",
    "databaseName": "Mifos/Fineract Schema",
    "tablesAccessed": [
      "stretchy_report",
      "stretchy_parameter",
      "stretchy_report_parameter",
      "m_permission",
      "m_office",
      "m_client",
      "m_loan",
      "m_staff",
      "m_product_loan",
      "m_fund",
      "r_enum_value",
      "m_code_value",
      "m_currency",
      "m_loan_arrears_aging",
      "m_loan_repayment_schedule",
      "m_loan_transaction",
      "m_note",
      "m_appuser_role",
      "m_role",
      "m_role_permission"
    ],
    "operationType": [
      "WRITE",
      "READ"
    ],
    "queryPatterns": "The script performs bulk INSERTs containing embedded dynamic SQL queries. The embedded queries utilize complex joins, aggregations, and variable substitution (e.g., ${officeId}).",
    "transactionHandling": "Implicit transaction handling typical of SQL script execution.",
    "protocol": "MySQL / MariaDB (inferred from syntax like `concat`, `ifnull`, and backticks)",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "truncate table stretchy_report;\nINSERT INTO `stretchy_report` VALUES (1,'Client Listing','Table',NULL,'Client','select ... from m_office ...');\ninsert into m_permission(grouping, `code`, entity_name, action_name, can_maker_checker)\nselect 'report', concat('READ_', r.report_name), r.report_name, 'READ', false\nfrom stretchy_report r;"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.service",
    "mechanism": "DRIVER",
    "name": "Database Driver Utilities",
    "description": "The class interacts directly with database driver utilities (specifically PostgreSQL's core Utils) to perform SQL escaping. It also uses the DatabaseTypeResolver to determine which logic to apply.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "PostgreSQL / MySQL",
    "connectionInfo": "n/a",
    "codeExample": "Utils.escapeLiteral(null, literal, true).toString()"
  },
  {
    "path": "README.md",
    "mechanism": "JDBC",
    "name": "HikariCP",
    "description": "The application integrates with relational databases (MariaDB, MySQL, PostgreSQL) using JDBC drivers and manages connections via the HikariCP connection pool. It supports multi-tenancy by connecting to specific databases (e.g., 'fineract_tenants') configured via environment variables or application properties. Database schemas are initialized and managed using Gradle tasks and Liquibase migrations, with strict enforcement of UTC timezones at the JDBC driver level.",
    "databaseName": "fineract_tenants, fineract_default",
    "tablesAccessed": [
      "not identifiable from code"
    ],
    "operationType": [
      "READ_WRITE",
      "DDL"
    ],
    "queryPatterns": "Database creation and schema migration scripts, partitioned batch processing for 'Close of Business' jobs, and standard CRUD operations implied by the core banking functionality.",
    "transactionHandling": "Spring Batch is explicitly used for partitioning large jobs like 'Close of Business' across worker nodes; general transaction management is likely handled by Spring Boot's transaction management but is not explicitly detailed in the provided text.",
    "protocol": "MariaDB 10.9, MySQL, PostgreSQL",
    "connectionInfo": "JDBC URL parameters (e.g., serverTimezone=UTC) and environment variables (e.g., FINERACT_HIKARI_*)",
    "codeExample": "export FINERACT_HIKARI_PASSWORD=verysecret\n./gradlew createDB -PdbName=fineract_tenants\njava -Dloader.path=. -jar fineract-provider/build/libs/fineract-provider.jar"
  },
  {
    "path": "fineract-provider/src/main/resources/application.properties",
    "mechanism": "JDBC",
    "name": "HikariCP DataSource",
    "description": "The file configures the primary JDBC connection pool using HikariCP. It defines the database driver, connection URL, credentials, and pool sizing properties (min/max connections, timeouts). It also includes specific configuration for a multi-tenant architecture, defining parameters for a default tenant database and separate read-only connection details. Additionally, it enables Liquibase for automated database schema management and migrations.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE",
      "DDL"
    ],
    "queryPatterns": "Configuration for connection pooling, transaction isolation levels, and schema migration scripts.",
    "transactionHandling": "Configures the JDBC transaction isolation level to TRANSACTION_REPEATABLE_READ and manages auto-commit settings for the connection pool.",
    "protocol": "MariaDB / MySQL",
    "connectionInfo": "jdbc:mariadb://localhost:3306/fineract_tenants",
    "codeExample": "spring.datasource.hikari.driverClassName=${FINERACT_HIKARI_DRIVER_SOURCE_CLASS_NAME:org.mariadb.jdbc.Driver}\nspring.datasource.hikari.jdbcUrl=${FINERACT_HIKARI_JDBC_URL:jdbc:mariadb://localhost:3306/fineract_tenants}\nspring.datasource.hikari.username=${FINERACT_HIKARI_USERNAME:root}\nspring.datasource.hikari.password=${FINERACT_HIKARI_PASSWORD:mysql}\nspring.datasource.hikari.minimumIdle=${FINERACT_HIKARI_MINIMUM_IDLE:3}"
  },
  {
    "path": "fineract-provider/src/test/resources/application-test.properties",
    "mechanism": "JDBC",
    "name": "HikariCP Datasource",
    "description": "The file configures the primary application datasource using Spring Boot's HikariCP integration. It specifies the MariaDB JDBC driver, connection credentials, and pooling parameters (minimum idle connections, maximum pool size). It also enables specific driver-level performance optimizations including server-side prepared statements and batched statement rewriting.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [
      "not identifiable from code"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Configures driver-level optimizations for prepared statement caching and batched statement rewriting.",
    "transactionHandling": "Configures auto-commit to true at the pool level and defines retry logic for optimistic locking exceptions.",
    "protocol": "MariaDB",
    "connectionInfo": "jdbc:mariadb://localhost:3306/fineract_tenants",
    "codeExample": "spring.datasource.hikari.driverClassName=org.mariadb.jdbc.Driver\nspring.datasource.hikari.jdbcUrl=jdbc:mariadb://localhost:3306/fineract_tenants\nspring.datasource.hikari.username=root\nspring.datasource.hikari.password=[REDACTED]\nspring.datasource.hikari.minimumIdle=3\nspring.datasource.hikari.maximumPoolSize=10"
  },
  {
    "path": "docker-compose-postgresql-kafka.yml",
    "mechanism": "JDBC",
    "name": "Fineract PostgreSQL / HikariCP",
    "description": "The file configures the application services to connect to a PostgreSQL container using JDBC. It defines the connection string, credentials, and extensive HikariCP connection pool settings (such as pool size, timeouts, and auto-commit behavior) through environment variables passed to the `fineract-manager` and `fineract-worker` containers.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a (Configuration file)",
    "transactionHandling": "Configured as auto-commit=true via environment variable FINERACT_HIKARI_AUTO_COMMIT.",
    "protocol": "PostgreSQL 15.3",
    "connectionInfo": "jdbc:postgresql://fineractpostgresql:5432/fineract_tenants",
    "codeExample": "      - FINERACT_HIKARI_DRIVER_SOURCE_CLASS_NAME=org.postgresql.Driver\n      - FINERACT_HIKARI_JDBC_URL=jdbc:postgresql://fineractpostgresql:5432/fineract_tenants\n      - FINERACT_HIKARI_USERNAME=postgres\n      - FINERACT_HIKARI_PASSWORD=REDACTED\n      - FINERACT_HIKARI_AUTO_COMMIT=true"
  },
  {
    "path": "custom/docker/docker-compose.yml",
    "mechanism": "JDBC",
    "name": "MariaDB",
    "description": "The file configures the application's database connection via environment variables that are passed to the Fineract server container. It specifies the MariaDB JDBC driver, connection URL, credentials, and specific HikariCP pool settings (like pool size, timeouts, and cache properties) to establish connectivity with the `fineractmysql` service.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE",
      "ADMIN"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Configures auto-commit to true via FINERACT_HIKARI_AUTO_COMMIT environment variable.",
    "protocol": "MariaDB 11.0",
    "connectionInfo": "jdbc:mariadb://fineractmysql:3306/fineract_tenants",
    "codeExample": "environment:\n  - FINERACT_HIKARI_DRIVER_SOURCE_CLASS_NAME=org.mariadb.jdbc.Driver\n  - FINERACT_HIKARI_JDBC_URL=jdbc:mariadb://fineractmysql:3306/fineract_tenants\n  - FINERACT_HIKARI_USERNAME=root\n  - FINERACT_HIKARI_PASSWORD=[REDACTED]"
  },
  {
    "path": "docker-compose.yml",
    "mechanism": "JDBC",
    "name": "MariaDB",
    "description": "The file configures the database infrastructure by defining a MariaDB service and passing JDBC connection parameters to the application service via environment variables. It sets up the Hikari connection pool settings, including the driver class, JDBC URL, and credentials, allowing the Fineract server to communicate with the database container.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE",
      "DDL",
      "ADMIN"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Auto-commit is enabled via the environment variable FINERACT_HIKARI_AUTO_COMMIT=true.",
    "protocol": "MariaDB 11.0",
    "connectionInfo": "jdbc:mariadb://fineractmysql:3306/fineract_tenants",
    "codeExample": "environment:\n  - FINERACT_HIKARI_DRIVER_SOURCE_CLASS_NAME=org.mariadb.jdbc.Driver\n  - FINERACT_HIKARI_JDBC_URL=jdbc:mariadb://fineractmysql:3306/fineract_tenants\n  - FINERACT_HIKARI_USERNAME=root\n  - FINERACT_HIKARI_PASSWORD=[REDACTED]"
  },
  {
    "path": "docker-compose-postgresql.yml",
    "mechanism": "JDBC",
    "name": "PostgreSQL / HikariCP",
    "description": "The file configures the database infrastructure and defines the JDBC connection parameters for the application. It spins up a PostgreSQL container and injects JDBC connection strings, credentials, and HikariCP pool settings into the application container via environment variables.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [
      "not identifiable from code"
    ],
    "operationType": [
      "ADMIN",
      "READ_WRITE"
    ],
    "queryPatterns": "n/a (Configuration file)",
    "transactionHandling": "HikariCP auto-commit set to true via environment variable",
    "protocol": "PostgreSQL 15.3",
    "connectionInfo": "jdbc:postgresql://fineractpostgresql:5432/fineract_tenants",
    "codeExample": "environment:\n  - FINERACT_HIKARI_DRIVER_SOURCE_CLASS_NAME=org.postgresql.Driver\n  - FINERACT_HIKARI_JDBC_URL=jdbc:postgresql://fineractpostgresql:5432/fineract_tenants\n  - FINERACT_HIKARI_USERNAME=postgres\n  - FINERACT_HIKARI_PASSWORD=[REDACTED]"
  },
  {
    "path": "kubernetes/fineract-server-deployment.yml",
    "mechanism": "JDBC",
    "name": "fineractmysql",
    "description": "The file configures the database integration by injecting JDBC environment variables into the container. It specifies the MariaDB JDBC driver and connection URL, linking the application to the `fineract_tenants` database hosted on the `fineractmysql` service.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a (configuration only)",
    "transactionHandling": "n/a (configuration only)",
    "protocol": "MariaDB",
    "connectionInfo": "jdbc:mariadb://fineractmysql:3306/fineract_tenants",
    "codeExample": "        - name: FINERACT_HIKARI_DRIVER_CLASS_NAME\n          value: org.mariadb.jdbc.Driver\n        - name: FINERACT_HIKARI_JDBC_URL\n          value: jdbc:mariadb://fineractmysql:3306/fineract_tenants"
  },
  {
    "path": "docker-compose-postgresql-kafka-msk.yml",
    "mechanism": "JDBC",
    "name": "fineractpostgresql",
    "description": "The file configures the Fineract application containers to connect to the PostgreSQL database container using JDBC. It passes connection details, credentials, and HikariCP connection pool configuration settings through environment variables.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Configuration for HikariCP connection pooling, prepared statement caching, and slow query logging.",
    "transactionHandling": "Transaction behavior is configured via environment variables, specifically setting auto-commit to true.",
    "protocol": "PostgreSQL 15.3",
    "connectionInfo": "jdbc:postgresql://fineractpostgresql:5432/fineract_tenants",
    "codeExample": "      - FINERACT_HIKARI_DRIVER_SOURCE_CLASS_NAME=org.postgresql.Driver\n      - FINERACT_HIKARI_JDBC_URL=jdbc:postgresql://fineractpostgresql:5432/fineract_tenants\n      - FINERACT_HIKARI_USERNAME=postgres\n      - FINERACT_HIKARI_PASSWORD=[REDACTED]\n      - FINERACT_HIKARI_AUTO_COMMIT=true"
  },
  {
    "path": "docker-compose-postgresql-activemq.yml",
    "mechanism": "JDBC",
    "name": "fineractpostgresql",
    "description": "The code configures the application to connect to a PostgreSQL database container named 'fineractpostgresql'. It uses environment variables to inject JDBC connection details, including the driver class, URL, credentials, and HikariCP connection pool settings, into the Fineract application runtime.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [
      "not identifiable from configuration file"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "not identifiable from configuration file",
    "transactionHandling": "The configuration explicitly sets auto-commit to true via the 'FINERACT_HIKARI_AUTO_COMMIT' environment variable.",
    "protocol": "PostgreSQL 15.3",
    "connectionInfo": "jdbc:postgresql://fineractpostgresql:5432/fineract_tenants",
    "codeExample": "environment:\n  - FINERACT_HIKARI_DRIVER_SOURCE_CLASS_NAME=org.postgresql.Driver\n  - FINERACT_HIKARI_JDBC_URL=jdbc:postgresql://fineractpostgresql:5432/fineract_tenants\n  - FINERACT_HIKARI_USERNAME=postgres\n  - FINERACT_HIKARI_PASSWORD=[REDACTED]"
  },
  {
    "path": "com.acme.fineract.loan.job",
    "mechanism": "JDBC",
    "name": "JobRepository",
    "description": "The class interacts with the database indirectly through the Spring Batch 'JobRepository'. This component is responsible for persisting the state of the batch job (JobInstance, JobExecution, StepExecution, etc.) to the underlying database tables (typically BATCH_JOB_INSTANCE, BATCH_JOB_EXECUTION, etc.).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_JOB_INSTANCE",
      "BATCH_JOB_EXECUTION",
      "BATCH_JOB_EXECUTION_PARAMS",
      "BATCH_STEP_EXECUTION",
      "BATCH_STEP_EXECUTION_CONTEXT",
      "BATCH_JOB_EXECUTION_CONTEXT"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Batch internal CRUD operations for job metadata",
    "transactionHandling": "Spring PlatformTransactionManager",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring Context (DataSource)",
    "codeExample": "new JobBuilder(AcmeJobName.ACME_NOOP_JOB.name(), jobRepository)"
  },
  {
    "path": "org.apache.fineract",
    "mechanism": "JDBC",
    "name": "Fineract Database Configuration",
    "description": "The application configures a DataSource for an external database and initializes Liquibase for schema migrations. The Javadoc explicitly mentions the use of a 'normal' external database configured via `DataSourceProperties`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE",
      "DDL"
    ],
    "queryPatterns": "Database migrations and connection pooling initialization",
    "transactionHandling": "Spring Boot default transaction management",
    "protocol": "JDBC",
    "connectionInfo": "Configured via external properties (DataSourceProperties)",
    "codeExample": "@Import({ FineractWebApplicationConfiguration.class, FineractLiquibaseOnlyApplicationConfiguration.class })"
  },
  {
    "path": "org.apache.fineract.accounting.closure.service",
    "mechanism": "JDBC",
    "name": "GLClosureReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL SELECT queries. It manually constructs SQL strings that join the main closure table with user and office tables to populate data transfer objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_gl_closure",
      "m_appuser",
      "m_office"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "SQL SELECT queries with multiple joins (acc_gl_closure, m_appuser, m_office) and dynamic WHERE clauses.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource (injected into JdbcTemplate)",
    "codeExample": "this.jdbcTemplate.query(sql, rm, finalObjectArray);"
  },
  {
    "path": "org.apache.fineract.accounting.financialactivityaccount.service",
    "mechanism": "JDBC",
    "name": "FinancialActivityAccountReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL SELECT queries. It joins the 'acc_gl_financial_activity_account' table with 'acc_gl_account' to retrieve detailed information about financial activity mappings.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_gl_financial_activity_account",
      "acc_gl_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with INNER JOINs",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via Spring",
    "codeExample": "this.jdbcTemplate.query(sql, financialActivityAccountMapper, new Object[] {});"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.jobs.updatetrialbalancedetails",
    "mechanism": "JDBC",
    "name": "RoutingDataSourceServiceFactory",
    "description": "The class uses Spring's JdbcTemplate for complex aggregation queries and bulk inserts, and a Spring Data repository wrapper for entity updates.",
    "databaseName": "m_trial_balance",
    "tablesAccessed": [
      "acc_gl_journal_entry",
      "m_trial_balance"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Complex aggregation queries with subqueries, bulk INSERT INTO ... SELECT statements, and standard JPA entity saves.",
    "transactionHandling": "Likely handled by the Spring Batch framework wrapping the Tasklet execution.",
    "protocol": "SQL",
    "connectionInfo": "Derived from RoutingDataSourceServiceFactory",
    "codeExample": "final StringBuilder sqlBuilder = new StringBuilder(600);\nsqlBuilder.append(\"Insert Into m_trial_balance(office_id, account_id, Amount, entry_date, created_date,closing_balance) \")\n        .append(\"Select je.office_id, je.account_id, SUM(CASE WHEN je.type_enum=1 THEN (-1) * je.amount ELSE je.amount END) \")\n        .append(\"as Amount, Date(je.entry_date) as Entry_Date, je.transaction_date as Created_Date,sum(je.amount) as closing_balance \")\n        .append(\"from acc_gl_journal_entry je WHERE je.transaction_date = ? \")\n        .append(\"group by je.account_id, je.office_id, je.transaction_date, Date(je.entry_date)\");\nfinal int result = jdbcTemplate.update(sqlBuilder.toString(), tbGap);"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.service.GLAccountReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It manually maps ResultSets to objects using inner class RowMappers. It constructs dynamic SQL strings to handle optional filtering criteria.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_gl_account",
      "m_code_value",
      "acc_gl_journal_entry",
      "acc_accounting_rule",
      "acc_rule_tags"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation with string concatenation, LEFT JOINs, subqueries for aggregations (max/group by), and parameter binding.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sql, rm, finalObjectArray);"
  },
  {
    "path": "org.apache.fineract.accounting.journalentry.service.JournalEntryReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It dynamically builds SQL strings based on filter criteria and maps the results to Java objects using a custom RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_gl_journal_entry",
      "acc_gl_account",
      "m_office",
      "m_appuser",
      "m_currency",
      "m_loan_transaction",
      "m_savings_account_transaction",
      "m_payment_detail",
      "m_payment_type",
      "m_note"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation with complex joins across multiple tables.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final String sql = \"select \" + rm.schema() + \" where journalEntry.id = ?\";\nreturn this.jdbcTemplate.queryForObject(sql, rm, glJournalEntryId);"
  },
  {
    "path": "org.apache.fineract.accounting.journalentry.service.JournalEntryRunningBalanceUpdateServiceImpl",
    "mechanism": "JDBC",
    "name": "JournalEntryDatabaseService",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries and batch updates. It performs complex joins to calculate running balances and updates the journal entry table directly.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_gl_journal_entry",
      "acc_gl_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code uses complex SQL queries involving aggregations (MIN, MAX), GROUP BY clauses, and self-joins to determine the state of balances prior to a specific date. It also uses batch UPDATE statements to modify records efficiently.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.batchUpdate(sql, params);"
  },
  {
    "path": "org.apache.fineract.accounting.producttoaccountmapping.service.ProductToGLAccountMappingReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "ProductToGLAccountMappingReadPlatformService",
    "description": "The class uses Spring's JdbcTemplate to execute SQL SELECT queries. It manually constructs SQL strings involving joins between `acc_product_mapping`, `m_charge`, `acc_gl_account`, and `m_payment_type`. It uses a custom RowMapper to transform the ResultSet into a Map.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_product_mapping",
      "m_charge",
      "acc_gl_account",
      "m_payment_type"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with dynamic criteria based on product type and mapping attributes.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final String sql = \"select \" + rm.schema() + \" and product_id = ? and payment_type is null and mapping.charge_id is null\";\nfinal List<Map<String, Object>> listOfProductToGLAccountMaps = this.jdbcTemplate.query(sql, rm, new Object[] { PortfolioProductType.LOAN.getValue(), loanProductId });"
  },
  {
    "path": "org.apache.fineract.accounting.provisioning.service.ProvisioningEntriesReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Provisioning Database Service",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It constructs complex SQL strings involving joins across multiple tables (loans, clients, groups, provisioning mappings) and maps the results to Java objects using custom RowMapper implementations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_repayment_schedule",
      "m_loan",
      "m_loanproduct_provisioning_mapping",
      "m_provisioning_criteria_definition",
      "m_client",
      "m_group",
      "m_provisioning_history",
      "m_appuser",
      "m_loanproduct_provisioning_entry",
      "m_office",
      "m_product_loan",
      "m_provision_category",
      "acc_gl_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex SQL queries with multiple LEFT JOINs, subqueries for date calculation, aggregations (SUM, MIN, MAX), and dynamic WHERE clauses.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sql, mapper, formattedDate, formattedDate, formattedDate);"
  },
  {
    "path": "org.apache.fineract.accounting.rule.service.AccountingRuleReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Fineract Database",
    "description": "The class uses Spring's JdbcTemplate to interact directly with the relational database. It constructs SQL queries manually using StringBuilder and maps the results using custom ResultSetExtractor and RowMapper implementations. It performs READ operations involving joins across multiple tables to assemble complex domain objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_office",
      "acc_accounting_rule",
      "acc_gl_account",
      "m_code_value",
      "acc_rule_tags"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with manual mapping logic to handle one-to-many relationships and optional foreign keys.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final String sql = \"select \" + resultSetExtractor.schema() + \" and rule.id = ?\";\nfinal Map<Long, AccountingRuleData> extractedData = this.jdbcTemplate.query(sql, resultSetExtractor, new Object[] { accountingRuleId });"
  },
  {
    "path": "org.apache.fineract.adhocquery.service.AdHocReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "AdHocReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries against the database. It manually constructs SQL strings using a schema defined in an inner RowMapper class and handles result set mapping manually.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_adhoc",
      "m_appuser"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with LEFT JOINs to fetch creator/modifier user details.",
    "transactionHandling": "None explicit (likely read-only auto-commit)",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource",
    "codeExample": "this.jdbcTemplate.query(sql, this.adHocRowMapper);"
  },
  {
    "path": "org.apache.fineract.cob.loan",
    "mechanism": "JDBC",
    "name": "NamedParameterJdbcTemplate / LoanRepository",
    "description": "The class uses Spring's NamedParameterJdbcTemplate for complex partitioning queries that require window functions and dynamic SQL generation. It also uses a Spring Data JPA LoanRepository for standard retrieval operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with subqueries (window functions for pagination) and simple CRUD operations via repository.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "sql.append(\"select min(id) as min, max(id) as max, page, count(id) as count from \");\nsql.append(\"  (select floor(((row_number() over(order by id))-1) / :pageSize) as page, t.* from \");\n// ...\nreturn namedParameterJdbcTemplate.query(sql.toString(), parameters, RetrieveAllNonClosedLoanIdServiceImpl::mapRow);"
  },
  {
    "path": "org.apache.fineract.cob.loan.LoanLockingServiceImpl",
    "mechanism": "JDBC",
    "name": "LoanLockingService Database Access",
    "description": "The class uses a mix of Spring JDBC (`JdbcTemplate`) for high-performance batch operations (inserts and updates) and Spring Data JPA (`LoanAccountLockRepository`) for standard retrieval and deletion. It interacts directly with the `m_loan_account_locks` table.",
    "databaseName": "m_loan_account_locks",
    "tablesAccessed": [
      "m_loan_account_locks",
      "m_loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Batch inserts and updates using raw SQL for performance; standard JPA selects and deletes.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via Spring",
    "codeExample": "jdbcTemplate.batchUpdate(\"INSERT INTO m_loan_account_locks ... VALUES (?,?,?,?,?)\", loanIds, loanIds.size(), (PreparedStatement ps, Long loanId) -> { ... });"
  },
  {
    "path": "org.apache.fineract.cob.loan.RetrieveAllNonClosedLoanIdServiceImplTest",
    "mechanism": "JDBC",
    "name": "NamedParameterJdbcTemplate",
    "description": "Although this is a test class, it explicitly defines and verifies complex SQL queries intended for execution via Spring's NamedParameterJdbcTemplate. The queries use window functions to partition data from the m_loan table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex SQL queries using subqueries, aggregation (min, max, count), and window functions (row_number() over) for pagination/partitioning.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "select min(id) as min, max(id) as max, page, count(id) as count from (select floor(((row_number() over(order by id))-1) / :pageSize) as page, t.* from (select id from m_loan where loan_status_id in (:statusIds)..."
  },
  {
    "path": "org.apache.fineract.commands.service",
    "mechanism": "JDBC",
    "name": "AuditReadPlatformService",
    "description": "The interface methods explicitly use `SQLBuilder`, a utility class in this application framework used to construct dynamic SQL queries for JDBC execution. This pattern indicates that the implementing class will perform direct database reads using JDBC (likely via Spring's JdbcTemplate) rather than an ORM like Hibernate, which is typical for 'ReadPlatformService' components in this architecture to ensure performance.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_portfolio_command_source"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation using SQLBuilder to filter audit logs based on variable criteria.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "Collection<AuditData> retrieveAuditEntries(SQLBuilder extraCriteria, boolean includeJson);"
  },
  {
    "path": "org.apache.fineract.commands.service.AuditReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Audit Database Access",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It dynamically builds SQL strings using StringBuilder to handle optional filtering criteria and pagination. It performs READ operations involving complex joins across multiple tables to aggregate audit information.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_portfolio_command_source",
      "m_appuser",
      "m_office",
      "m_group",
      "m_group_level",
      "m_client",
      "m_loan",
      "m_savings_account",
      "r_enum_value",
      "m_permission",
      "m_role_permission",
      "m_role",
      "m_appuser_role"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins, dynamic criteria generation, pagination, and aggregation.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sql, rm, extraCriteria.getArguments())"
  },
  {
    "path": "org.apache.fineract.infrastructure.accountnumberformat.service",
    "mechanism": "JDBC",
    "name": "AccountNumberFormatReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries against the database. It defines a custom RowMapper to map columns from the 'c_account_number_format' table to the AccountNumberFormatData domain object.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "c_account_number_format"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with row mapping.",
    "transactionHandling": "None explicit (likely relies on default or upper-layer transaction management).",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "final String sql = \"select \" + this.accountNumberFormatMapper.schema() + \" where anf.id = ?\";\nfinal AccountNumberFormatData accountNumberFormatData = this.jdbcTemplate.queryForObject(sql, this.accountNumberFormatMapper, new Object[] { id });"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.service",
    "mechanism": "JDBC",
    "name": "EmailCampaignReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries. It constructs SQL schemas within inner mapper classes (EmailCampaignMapper and BusinessRuleMapper) which define the columns and joins. The queries retrieve data from tables like 'scheduled_email_campaign' and 'stretchy_report'.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "scheduled_email_campaign",
      "m_appuser",
      "stretchy_report",
      "stretchy_report_parameter",
      "stretchy_parameter"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with subqueries (left joins across multiple tables)",
    "transactionHandling": "None (Read-only operations)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "this.jdbcTemplate.query(sql, this.businessRuleMapper, searchType);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.service",
    "mechanism": "JDBC",
    "name": "EmailConfigurationReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "scheduled_email_configuration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with RowMapper",
    "transactionHandling": "NONE",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sql, this.emailConfigurationRowMapper);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.service",
    "mechanism": "JDBC",
    "name": "EmailReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It manually maps ResultSets to objects using a custom RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "scheduled_email_messages_outbound"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with filtering by status, ID, and date ranges. Uses database-specific SQL generation for LIMIT clauses.",
    "transactionHandling": "None (Read-only operations)",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(sql, this.emailRowMapper, EmailMessageStatusType.PENDING.getValue());"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.sms.service.SmsCampaignReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "SmsCampaign Database Access",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It defines SQL schemas within inner mapper classes to select data from the 'sms_campaign' table and join it with 'm_appuser' and 'stretchy_report' tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "sms_campaign",
      "m_appuser",
      "stretchy_report",
      "stretchy_report_parameter",
      "stretchy_parameter"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard SELECT queries with LEFT JOINs to retrieve related entity data (users, reports). Dynamic SQL generation is used for pagination limits and offsets.",
    "transactionHandling": "NONE",
    "protocol": "JDBC",
    "connectionInfo": "Configured via Spring DataSource (injected into JdbcTemplate)",
    "codeExample": "final String sql = \"select \" + this.smsCampaignMapper.schema + \" where sc.id = ? and sc.is_visible = ?\";\nreturn this.jdbcTemplate.queryForObject(sql, this.smsCampaignMapper, campaignId, isVisible);"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.service",
    "mechanism": "JDBC",
    "name": "CodeValueReadPlatformService",
    "description": "The service uses Spring's JdbcTemplate to perform direct SQL SELECT operations against the database. It manually maps ResultSets to objects using a custom RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_code_value",
      "m_code"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with JOINs and WHERE clauses.",
    "transactionHandling": "None explicit (Read-only)",
    "protocol": "JDBC",
    "connectionInfo": "Configured via Spring DataSource (injected into JdbcTemplate)",
    "codeExample": "final String sql = \"select \" + rm.schema() + \"where c.code_name like ? and cv.is_active = true order by position\";\nreturn this.jdbcTemplate.query(sql, rm, new Object[] { code });"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.service",
    "mechanism": "JDBC",
    "name": "CodeReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL SELECT queries against the database. It manually maps the ResultSet to CodeData objects using an inner RowMapper class.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_code"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with WHERE clauses and ORDER BY",
    "transactionHandling": "None explicit (likely read-only auto-commit)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "final String sql = \"select \" + rm.schema() + \" where c.id = ?\";\nreturn this.jdbcTemplate.queryForObject(sql, rm, new Object[] { codeId });"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database to retrieve external service configurations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "c_external_service"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query with a WHERE clause filtering by service name.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource (injected into JdbcTemplate)",
    "codeExample": "final String sql = \"SELECT es.name as name, es.id as id FROM c_external_service es where es.name='\" + serviceNameToUse + \"'\";\nfinal ExternalServicesData externalServicesData = this.jdbcTemplate.query(sql, resultSetExtractor);"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.service",
    "mechanism": "JDBC",
    "name": "ExternalServicesPropertiesReadPlatformServiceImpl",
    "description": "The class uses Spring's `JdbcTemplate` to perform raw SQL read operations. It joins `c_external_service_properties` and `c_external_service` tables to retrieve key-value pairs for specific service configurations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "c_external_service_properties",
      "c_external_service"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with INNER JOINs to filter by service name.",
    "transactionHandling": "None explicit (likely auto-commit or handled by caller)",
    "protocol": "SQL",
    "connectionInfo": "Managed by Spring DataSource via JdbcTemplate",
    "codeExample": "final String sql = \"SELECT esp.name, esp.value FROM c_external_service_properties esp inner join c_external_service es on esp.external_service_id = es.id where es.name = '\" + ExternalServicesConstants.S3_SERVICE_NAME + \"'\";\nfinal S3CredentialsData s3CredentialsData = this.jdbcTemplate.query(sql, resultSetExtractor, new Object[] {});"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.service.ConfigurationReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "ConfigurationReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to perform raw SQL queries against the database. It reads configuration data from the 'c_configuration' table and optionally joins with 'x_registered_table'.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "c_configuration",
      "x_registered_table"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with optional JOINs and WHERE clauses.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource (injected into JdbcTemplate)",
    "codeExample": "final List<GlobalConfigurationPropertyData> globalConfiguration = this.jdbcTemplate.query(sql, this.rm, survey ? new Object[] { DataTableApiConstant.CATEGORY_PPI } : new Object[] {});"
  },
  {
    "path": "org.apache.fineract.infrastructure.core",
    "mechanism": "JDBC",
    "name": "HikariCP Configuration",
    "description": "The code tests the configuration of HikariCP data sources for tenant database connections. It validates that the HikariConfig object is correctly populated with database credentials, URLs, and pool settings derived from tenant properties. While this is a test class and does not establish a real connection, it heavily utilizes JDBC and HikariCP APIs.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "MariaDB (JDBC)",
    "connectionInfo": "jdbc:mariadb://localhost:3306/fineract_tenants",
    "codeExample": "assertEquals(MASTER_DB_JDBC_URL, hikariConfig.getJdbcUrl());"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.LiquibaseStepDefinitions",
    "mechanism": "JDBC",
    "name": "TenantDataSourceFactory",
    "description": "This class tests database migration logic by mocking JDBC DataSources and Liquibase components. It does not perform actual database I/O but simulates various database states (e.g., first run, upgrade needed) to verify the upgrade service's behavior using Mockito.",
    "databaseName": "tenant_store_db",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JDBC (Mocked)",
    "connectionInfo": "n/a",
    "codeExample": "given(databaseStateVerifier.isFirstLiquibaseMigration(tenantStoreDataSource)).willReturn(true);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.boot.FineractLiquibaseOnlyApplicationConfiguration",
    "mechanism": "JDBC",
    "name": "Liquibase Database Migration Configuration",
    "description": "The class configures the application for database migrations using Liquibase. It imports JDBC and HikariCP configurations to establish the necessary database connections required for Liquibase to execute schema changes.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "DDL"
    ],
    "queryPatterns": "Database schema migrations and updates managed by Liquibase.",
    "transactionHandling": "Managed by Liquibase and underlying JDBC configuration.",
    "protocol": "unknown",
    "connectionInfo": "Configured via HikariCpConfig and JdbcConfig (not visible in this file)",
    "codeExample": "@Import({ HikariCpConfig.class, JdbcConfig.class })\n@EnableConfigurationProperties({ ... LiquibaseProperties.class })"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.config",
    "mechanism": "JDBC",
    "name": "JdbcConfig",
    "description": "This class configures the core Spring JDBC templates (JdbcTemplate and NamedParameterJdbcTemplate) which serve as the primary mechanism for executing SQL queries in the application. It integrates these templates with a RoutingDataSource, enabling dynamic database routing.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Generic JDBC template configuration supporting all SQL patterns",
    "transactionHandling": "Delegated to Spring transaction management (likely @Transactional used elsewhere)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by RoutingDataSource",
    "codeExample": "@Bean\npublic JdbcTemplate jdbcTemplate(RoutingDataSource dataSource) {\n    return new JdbcTemplate(dataSource);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.config",
    "mechanism": "JDBC",
    "name": "hikariTenantDataSource",
    "description": "Configures the HikariCP connection pool (HikariDataSource) which provides JDBC connections. It binds standard Spring datasource properties to the pool configuration.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "n/a",
    "protocol": "JDBC",
    "connectionInfo": "Configured via 'spring.datasource.hikari' properties",
    "codeExample": "return new HikariDataSource(hikariConfig);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.config.CompatibilityConfig",
    "mechanism": "JDBC",
    "name": "hikariTenantDataSource",
    "description": "The class configures a JDBC DataSource using the HikariCP connection pool library. It sets up the connection parameters (URL, credentials, driver) and specific driver properties optimized for performance (caching prepared statements, batch rewriting).",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "n/a",
    "protocol": "JDBC (likely MySQL based on driver properties)",
    "connectionInfo": "Configured via environment variable 'fineract_tenants_url'",
    "codeExample": "@Bean\npublic HikariConfig hikariConfig() {\n    HikariConfig hc = new HikariConfig();\n    hc.setJdbcUrl(environment.getProperty(\"fineract_tenants_url\"));\n    // ...\n    return hc;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.domain",
    "mechanism": "JDBC",
    "name": "FineractPlatformTenantConnection",
    "description": "This class is primarily a configuration holder for JDBC connections, but it also contains a utility method that directly interacts with the JDBC API. The 'toProtocol' method obtains a raw JDBC Connection from a DataSource to inspect the database metadata URL.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Metadata inspection only",
    "transactionHandling": "none",
    "protocol": "Dynamic (determined at runtime)",
    "connectionInfo": "Dynamic (constructed via toJdbcUrl)",
    "codeExample": "public static String toProtocol(DataSource dataSource) {\n    try (Connection connection = dataSource.getConnection()) {\n        String url = connection.getMetaData().getURL();\n        return url.substring(0, url.indexOf(\"://\"));\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.domain",
    "mechanism": "JDBC",
    "name": "JdbcSupport",
    "description": "This class is a low-level utility for processing JDBC ResultSets. It does not execute queries itself but is used to extract and map data from ResultSets returned by JDBC queries executed elsewhere in the application. It interacts directly with the java.sql.ResultSet API.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "final Timestamp dateValue = rs.getTimestamp(columnName);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service",
    "mechanism": "JDBC",
    "name": "JDBC DriverManager",
    "description": "The class interacts directly with the JDBC `DriverManager` to manage the lifecycle of database drivers. It does not perform data access (CRUD) but rather administrative cleanup by deregistering drivers to prevent memory leaks.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "ADMIN"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "Enumeration<Driver> drivers = DriverManager.getDrivers();\nwhile (drivers.hasMoreElements()) {\n    Driver driver = drivers.nextElement();\n    java.sql.DriverManager.deregisterDriver(driver);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries provided by the caller. It performs read operations to fetch data lists and count totals.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL execution provided by caller, including count queries.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource",
    "codeExample": "final List<E> items = jt.query(sqlFetchRows, rowMapper, args);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database",
    "mechanism": "JDBC",
    "name": "JdbcJavaType",
    "description": "The class is a core component of the database abstraction layer. It maps application-specific types to standard `java.sql.JDBCType` and generates dialect-specific SQL type strings (DDL) for MySQL and PostgreSQL. It also handles the conversion of Java values to JDBC-compatible values.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "n/a",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "public Object toJdbcValueImpl(@NotNull DatabaseType dialect, Object value) {\n    return value == null ? null : (Boolean.TRUE.equals(value) ? 1 : 0);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database",
    "mechanism": "JDBC",
    "name": "RoutingDataSource",
    "description": "This class implements the javax.sql.DataSource interface to provide JDBC connections. It functions as a router, dynamically selecting the underlying DataSource based on tenant context, enabling multi-tenancy.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Dynamic (routed via factory)",
    "codeExample": "return determineTargetDataSource().getConnection();"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database",
    "mechanism": "JDBC",
    "name": "PostgreSQLQueryService",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries directly against PostgreSQL system catalog tables/views to retrieve schema metadata.",
    "databaseName": "PostgreSQL",
    "tablesAccessed": [
      "information_schema.tables",
      "information_schema.columns",
      "pg_indexes"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL queries targeting system information schemas with dynamic string formatting for table names.",
    "transactionHandling": "None observed; read-only metadata operations.",
    "protocol": "PostgreSQL (JDBC)",
    "connectionInfo": "Provided via javax.sql.DataSource argument in methods",
    "codeExample": "JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\nInteger result = jdbcTemplate.queryForObject(format(\"SELECT COUNT(table_name) \" + \"FROM information_schema.tables ...\", tableName), Integer.class);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database",
    "mechanism": "JDBC",
    "name": "DatabaseIndexMapper",
    "description": "The class interacts with database results via the Spring JDBC SqlRowSet interface. While it does not execute queries directly, it processes the result set cursor to extract data.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Iterates over a result set",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "rowset.beforeFirst();\nwhile (rowset.next()) {\n    indexes.add(new IndexDetail(rowset.getString(1)));\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database",
    "mechanism": "JDBC",
    "name": "DatabaseQueryService",
    "description": "The class interacts directly with the JDBC DataSource to retrieve connection metadata (specifically the URL) for error reporting purposes. It primarily acts as a router for other database metadata operations, delegating them to implementations that likely use JDBC or Spring JDBC.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Metadata inspection via JDBC driver",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Derived from javax.sql.DataSource",
    "codeExample": "dataSource.getConnection().getMetaData().getURL()"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database",
    "mechanism": "JDBC",
    "name": "DatabaseQueryService",
    "description": "The interface defines methods for direct database schema inspection using a JDBC DataSource. It is designed to read metadata about tables, columns, and indexes, abstracting the specific SQL or JDBC calls required.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Schema metadata queries (likely utilizing JDBC DatabaseMetaData or system tables)",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "Provided via javax.sql.DataSource parameter",
    "codeExample": "boolean isTablePresent(DataSource dataSource, String tableName);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database",
    "mechanism": "JDBC",
    "name": "DatabaseTypeResolver",
    "description": "The class interacts with the JDBC configuration (HikariCP) to identify the database driver class name, which is then used to resolve the database vendor type (MySQL or PostgreSQL).",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "MySQL or PostgreSQL (inferred from driver)",
    "connectionInfo": "Derived from HikariConfig",
    "codeExample": "DatabaseType databaseType = DRIVER_MAPPING.get(driverClassName);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database",
    "mechanism": "JDBC",
    "name": "MySQL Metadata Access",
    "description": "The class interacts directly with the MySQL database using Spring's JdbcTemplate to query system tables (INFORMATION_SCHEMA) and execute administrative commands (SHOW TABLES). It does not use an ORM for these operations but relies on raw SQL strings.",
    "databaseName": "MySQL (inferred from class name and logic)",
    "tablesAccessed": [
      "INFORMATION_SCHEMA.COLUMNS",
      "INFORMATION_SCHEMA.STATISTICS"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL queries targeting system views (INFORMATION_SCHEMA) and SHOW commands.",
    "transactionHandling": "None explicit (read-only metadata queries)",
    "protocol": "MySQL",
    "connectionInfo": "Provided via javax.sql.DataSource argument",
    "codeExample": "final JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\nfinal String sql = \"SELECT ... FROM INFORMATION_SCHEMA.COLUMNS ...\";\nfinal SqlRowSet columnDefinitions = jdbcTemplate.queryForRowSet(sql, new Object[] { tableName });"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database",
    "mechanism": "JDBC",
    "name": "TomcatJdbcDataSourcePerTenantService",
    "description": "This class manages the lifecycle and retrieval of JDBC `DataSource` objects for a multi-tenant application. It does not execute business queries directly but manages the connections (pools) that other components use to interact with the database. It verifies connectivity by obtaining a `Connection` object during initialization.",
    "databaseName": "Dynamic (Tenant Specific)",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Dynamic JDBC URL from TenantConnection",
    "codeExample": "try (Connection connection = tenantSpecificDataSource.getConnection()) {\n    String url = connection.getMetaData().getURL();\n    log.debug(\"Established database connection with URL {}\", url);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database.DataSourcePerTenantServiceFactory",
    "mechanism": "JDBC",
    "name": "HikariCP DataSource Factory",
    "description": "This class is responsible for configuring and creating JDBC DataSources using the HikariCP connection pool library. It constructs JDBC URLs dynamically and manages database credentials.",
    "databaseName": "Dynamic (Tenant Specific)",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "n/a",
    "protocol": "Dynamic (JDBC)",
    "connectionInfo": "Dynamic JDBC URL constructed at runtime",
    "codeExample": "HikariConfig config = new HikariConfig();\nconfig.setJdbcUrl(jdbcUrl);\nconfig.setUsername(schemaUsername);\nconfig.setPassword(databasePasswordEncryptor.decrypt(schemaPassword));\nreturn hikariDataSourceFactory.create(config);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database.HikariDataSourceFactory",
    "mechanism": "JDBC",
    "name": "HikariDataSourceFactory",
    "description": "This class is responsible for the creation of the JDBC Connection Pool (HikariCP). While it does not execute queries itself, it is the infrastructure component that initializes the `DataSource` used by the rest of the application to connect to the database via JDBC.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Encapsulated within the HikariConfig object passed to the create method",
    "codeExample": "return new HikariDataSource(config);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database.RoutingDataSourceService",
    "mechanism": "JDBC",
    "name": "RoutingDataSourceService",
    "description": "This interface is explicitly designed to facilitate JDBC database integration by providing a mechanism to retrieve a javax.sql.DataSource. While it does not execute SQL itself, it is the gateway to obtaining the connection pool required for all subsequent database operations.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "DataSource retrieveDataSource();"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.migration",
    "mechanism": "JDBC",
    "name": "TenantDataSourceFactory",
    "description": "This class is responsible for configuring the JDBC connection layer (specifically HikariCP) for dynamic tenant databases. It constructs JDBC URLs and configures DataSources programmatically.",
    "databaseName": "Dynamic (derived from FineractPlatformTenantConnection)",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a (Configuration only)",
    "transactionHandling": "none",
    "protocol": "JDBC (Dynamic Driver)",
    "connectionInfo": "Dynamic JDBC URL constructed at runtime",
    "codeExample": "HikariDataSource dataSource = new HikariDataSource();\ndataSource.setUsername(tenantConnection.getSchemaUsername());\ndataSource.setPassword(databasePasswordEncryptor.decrypt(tenantConnection.getSchemaPassword()));\ndataSource.setJdbcUrl(tenantJdbcUrl);\nreturn dataSource;"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.migration",
    "mechanism": "JDBC",
    "name": "TenantDatabaseStateVerifier",
    "description": "The class uses Spring's `NamedParameterJdbcTemplate` to execute SQL queries against the `schema_version` table to verify migration history. It also checks for the existence of `DATABASECHANGELOG`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "schema_version",
      "DATABASECHANGELOG"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT COUNT queries with WHERE clauses to match version, script name, and checksum.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Provided dynamically via the DataSource parameter",
    "codeExample": "NamedParameterJdbcTemplate jdbcTemplate = new NamedParameterJdbcTemplate(dataSource);\nInteger result = jdbcTemplate.queryForObject(\n        \"SELECT COUNT(script) FROM schema_version \" + \"WHERE version = :latestFlywayVersion \"\n                + \"AND script = :latestFlywayScriptName \" + \"AND checksum = :latestFlywayScriptChecksum \" + \"AND success = 1\",\n        paramMap, Integer.class);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.migration",
    "mechanism": "JDBC",
    "name": "tenant_server_connections",
    "description": "The class interacts directly with the database using JDBC `Statement` and `ResultSet` objects obtained via the Liquibase connection wrapper. It performs a read operation to fetch plain text passwords and a write operation to update them with encrypted values.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "tenant_server_connections"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Iterates through a ResultSet and executes individual UPDATE statements for each row (cursor-based processing).",
    "transactionHandling": "Manual transaction handling via the underlying Liquibase connection (autocommit is noted as false in comments).",
    "protocol": "JDBC",
    "connectionInfo": "Derived from liquibase.database.Database object",
    "codeExample": "try (ResultSet rs = selectStatement.executeQuery(\"SELECT id, readonly_schema_password FROM tenant_server_connections...\")) { ... updateStatement.execute(updateSql); }"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.migration",
    "mechanism": "JDBC",
    "name": "TenantPasswordEncryptionTask",
    "description": "The class interacts directly with the database using the JDBC API exposed through the Liquibase 'Database' object. It executes raw SQL queries to read and update the 'tenant_server_connections' table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "tenant_server_connections"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Inline SQL SELECT and UPDATE statements constructed via String formatting.",
    "transactionHandling": "Manual handling via the provided JdbcConnection (autocommit is noted as false in comments).",
    "protocol": "JDBC",
    "connectionInfo": "Derived from liquibase.database.Database object",
    "codeExample": "JdbcConnection dbConn = (JdbcConnection) database.getConnection();\ntry (Statement selectStatement = dbConn.createStatement()) {\n    try (ResultSet rs = selectStatement.executeQuery(\"SELECT id, schema_password FROM tenant_server_connections\")) {\n        // ...\n        updateStatement.execute(updateSql);\n    }\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.migration.ExtendedSpringLiquibase",
    "mechanism": "JDBC",
    "name": "Liquibase Migration Service",
    "description": "The class interacts with the database to manage schema migration metadata. It retrieves a raw JDBC connection from the Spring DataSource and passes it to the Liquibase library to update the changelog table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DATABASECHANGELOG"
    ],
    "operationType": [
      "ADMIN",
      "WRITE"
    ],
    "queryPatterns": "Liquibase internal queries to update changelog lock and changelog tables.",
    "transactionHandling": "Managed internally by Liquibase",
    "protocol": "JDBC",
    "connectionInfo": "Derived from Spring DataSource",
    "codeExample": "try (Liquibase liquibase = createLiquibase(getDataSource().getConnection())) {\n    liquibase.changeLogSync(getContexts());\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.migration.ExtendedSpringLiquibaseBuilder",
    "mechanism": "JDBC",
    "name": "ExtendedSpringLiquibase",
    "description": "This class configures the Liquibase migration tool. It holds a javax.sql.DataSource and passes it to the ExtendedSpringLiquibase instance, which is responsible for managing database schema changes (DDL).",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "DDL"
    ],
    "queryPatterns": "Database Schema Migration (DDL)",
    "transactionHandling": "Managed by Liquibase internally",
    "protocol": "JDBC",
    "connectionInfo": "Derived from javax.sql.DataSource",
    "codeExample": "public ExtendedSpringLiquibaseBuilder withDataSource(DataSource dataSource) {\n    this.dataSource = dataSource;\n    return this;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.migration.ExtendedSpringLiquibaseFactory",
    "mechanism": "JDBC",
    "name": "Liquibase Migration Factory",
    "description": "The class configures Liquibase for database schema migration using a JDBC DataSource. It prepares the migration tool to execute DDL changes against the connected database.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "DDL"
    ],
    "queryPatterns": "Database schema migrations and change set execution.",
    "transactionHandling": "Liquibase manages its own transactions during migration execution.",
    "protocol": "JDBC",
    "connectionInfo": "Provided via javax.sql.DataSource argument",
    "codeExample": "return new ExtendedSpringLiquibaseBuilder(liquibaseProperties).withDataSource(dataSource)..."
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.migration.TenantDatabaseUpgradeService",
    "mechanism": "JDBC",
    "name": "TenantDatabaseUpgradeService",
    "description": "The service manages database schema migrations using Liquibase, interacting with databases via `javax.sql.DataSource`. It handles connections for the 'tenant store' and dynamically creates connections for individual tenants to apply DDL changes.",
    "databaseName": "Tenant Store DB and multiple Tenant DBs",
    "tablesAccessed": [
      "unknown (manages full schema)"
    ],
    "operationType": [
      "DDL",
      "READ_WRITE"
    ],
    "queryPatterns": "Database Schema Migrations (Liquibase)",
    "transactionHandling": "Managed by Liquibase",
    "protocol": "JDBC (via Liquibase)",
    "connectionInfo": "Dynamic JDBC URLs derived from TenantDataSourceFactory",
    "codeExample": "ExtendedSpringLiquibase liquibase = liquibaseFactory.create(tenantDataSource, TENANT_STORE_DB_CONTEXT, INITIAL_SWITCH_CONTEXT);\napplyInitialLiquibase(tenantDataSource, liquibase, \"tenant store\",\n        (ds) -> !databaseStateVerifier.isTenantStoreOnLatestUpgradableVersion(ds));"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.tenant.JdbcTenantDetailsService",
    "mechanism": "JDBC",
    "name": "hikariTenantDataSource",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against a DataSource. It relies on a TenantMapper helper class to define the SQL schema and map the ResultSet to domain objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown (hidden in TenantMapper.schema())"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries using a RowMapper",
    "transactionHandling": "None explicit (likely auto-commit or managed by caller)",
    "protocol": "JDBC",
    "connectionInfo": "DataSource bean: hikariTenantDataSource",
    "codeExample": "this.jdbcTemplate.queryForObject(sql, rm, new Object[] { tenantIdentifier });"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.tenant.TenantMapper",
    "mechanism": "JDBC",
    "name": "TenantMapper",
    "description": "The class defines raw SQL strings and uses Spring's `RowMapper` interface to map JDBC `ResultSet` data to domain objects. It explicitly defines a SQL query involving joins and maps specific column names to object properties.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "tenants",
      "tenant_server_connections"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex SQL query using a LEFT JOIN between 'tenants' and 'tenant_server_connections' tables to retrieve hierarchical data.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "public FineractPlatformTenant mapRow(final ResultSet rs, int rowNum) throws SQLException {\n    final Long id = rs.getLong(\"id\");\n    final String tenantIdentifier = rs.getString(\"identifier\");\n    // ...\n    return new FineractPlatformTenant(id, tenantIdentifier, name, timezoneId, connection);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.data",
    "mechanism": "JDBC",
    "name": "CreditReportReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It defines a RowMapper to manually map the ResultSet columns to the domain object fields.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_creditreport"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query with a WHERE clause and manual RowMapper.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(sql, rm, new Object[] { creditBureauId });"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.service",
    "mechanism": "JDBC",
    "name": "CreditBureauReadConfigurationServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL SELECT queries against the database to retrieve credit bureau configuration data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_creditbureau_configuration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with WHERE clauses using a RowMapper.",
    "transactionHandling": "None explicit, relies on default or caller context.",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "this.jdbcTemplate.query(sql, rm, new Object[] { id });"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.service",
    "mechanism": "JDBC",
    "name": "CreditBureauLoanProductMappingReadPlatformServiceImpl",
    "description": "The class uses Spring's `JdbcTemplate` to execute raw SQL queries against the database. It manually maps `ResultSet` rows to domain objects using inner `RowMapper` classes. The SQL queries involve joins across multiple tables to aggregate credit bureau and loan product information.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_creditbureau_loanproduct_mapping",
      "m_organisation_creditbureau",
      "m_product_loan",
      "m_creditbureau"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "SQL queries with joins across 4 tables, filtering by ID, and ordering results.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.jdbcTemplate.query(sql, rm);"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It defines a RowMapper to map the result set columns to the CreditBureauData domain object.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_creditbureau"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query with string concatenation for summary fields.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "final String sql = \"select \" + rm.schema() + \" order by id\";\nreturn this.jdbcTemplate.query(sql, rm);"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.service.OrganisationCreditBureauReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL SELECT queries. It manually maps the results using a RowMapper implementation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_organisation_creditbureau",
      "m_creditbureau"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with an INNER JOIN between mapping table and definition table.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Injected via Spring DataSource",
    "codeExample": "this.jdbcTemplate.query(sql, rm);"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.service",
    "mechanism": "JDBC",
    "name": "Fineract Database",
    "description": "The class uses Spring's JdbcTemplate and NamedParameterJdbcTemplate to perform direct SQL operations. It handles both DDL (creating/altering tables) and DML (querying/updating data) for dynamic user-defined tables ('Datatables'). It also interacts with system tables like 'x_registered_table', 'm_permission', and core entity tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "x_registered_table",
      "m_appuser_role",
      "m_role",
      "m_role_permission",
      "m_permission",
      "m_code_value",
      "c_configuration",
      "m_loan",
      "m_savings_account",
      "m_savings_account_transaction",
      "m_client",
      "m_group",
      "m_office",
      "m_entity_datatable_check",
      "information_schema.tables",
      "information_schema.TABLE_CONSTRAINTS",
      "x_table_column_code_mappings"
    ],
    "operationType": [
      "READ_WRITE",
      "DDL"
    ],
    "queryPatterns": "Dynamic SQL generation for DDL and DML, parameterized queries, batch updates, and complex joins for permission and scoping checks.",
    "transactionHandling": "Spring @Transactional annotations on methods that modify data or schema.",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "jdbcTemplate.queryForRowSet(sql, params); // NOSONAR\n...\nthis.namedParameterJdbcTemplate.update(registerDatatableSql, paramMap);"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.service",
    "mechanism": "JDBC",
    "name": "Datatable Service",
    "description": "The interface defines methods for interacting with dynamic 'Datatables'. The presence of methods like 'buildDataQueryEmbedded' which take StringBuilder arguments for 'select', 'from', and 'where' clauses, along with 'params' lists, strongly indicates an implementation that constructs dynamic SQL queries, likely executed via JDBC or Spring's JdbcTemplate. It handles DDL (create/drop tables) and DML (insert/update/delete entries) for these user-defined tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown (dynamic datatables)"
    ],
    "operationType": [
      "READ_WRITE",
      "DDL"
    ],
    "queryPatterns": "Dynamic SQL generation for user-defined tables, including DDL for table creation and DML for data management.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "boolean buildDataQueryEmbedded(@NotNull EntityTables entityTable, @NotNull String datatable, ... @NotNull StringBuilder select, @NotNull StringBuilder from, @NotNull StringBuilder where ...)"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.service.EntityDatatableChecksReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Fineract Database",
    "description": "The class primarily uses Spring's `JdbcTemplate` to execute SQL queries for retrieving lists of checks and datatable definitions. It also utilizes a Spring Data JPA repository (`EntityDatatableChecksRepository`) for specific domain object retrieval.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_entity_datatable_check",
      "x_registered_table",
      "m_product_loan",
      "m_savings_product"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation with filtering conditions and joins.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final String sql = \"select \" + this.registerDataTableMapper.schema();\nreturn this.jdbcTemplate.query(sql, this.registerDataTableMapper);"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.service.GenericDataServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute dynamic SQL queries and retrieve results as SqlRowSet. It also queries system tables for metadata and specific application tables (m_code, m_code_value) for code lookups.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_code",
      "m_code_value"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL execution, metadata queries, and specific joins for code value lookups.",
    "transactionHandling": "None observed in this file (likely handled by caller or auto-commit).",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via Spring",
    "codeExample": "final SqlRowSet rs = this.jdbcTemplate.queryForRowSet(sql);"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.service.ReadReportingServiceImpl",
    "mechanism": "JDBC",
    "name": "Stretchy Reports Database",
    "description": "The class interacts with the database using Spring's JdbcTemplate. It reads report definitions (SQL queries) from the 'stretchy_report' table and executes them dynamically. It also queries metadata tables for parameters.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "stretchy_report",
      "stretchy_report_parameter",
      "stretchy_parameter",
      "stretchy_{type}"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL execution where SQL strings are fetched from the database and executed. Parameter substitution is performed before execution.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource",
    "codeExample": "final SqlRowSet rs = this.jdbcTemplate.queryForRowSet(inputSqlWrapped, encodedName);"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.starter",
    "mechanism": "JDBC",
    "name": "ReadWriteNonCoreDataService",
    "description": "This configuration class wires up a service that utilizes Spring JDBC templates for database interaction. It injects JdbcTemplate and NamedParameterJdbcTemplate into the service implementation.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The service being configured likely performs dynamic SQL generation and execution based on the injected dependencies like DatabaseSpecificSQLGenerator.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "Configured via Spring Boot DataSource (injected into JdbcTemplate)",
    "codeExample": "return new ReadWriteNonCoreDataServiceImpl(jdbcTemplate, databaseTypeResolver, ...)"
  },
  {
    "path": "org.apache.fineract.infrastructure.documentmanagement.service",
    "mechanism": "JDBC",
    "name": "ImageReadPlatformServiceImpl",
    "description": "The class uses Spring's `JdbcTemplate` to execute raw SQL queries for retrieving image metadata. It performs joins between the image table and entity-specific tables (client or staff) to link images to their owners.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_image",
      "m_client",
      "m_staff"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with INNER JOINs based on entity ID.",
    "transactionHandling": "None explicitly defined in this class (likely relies on read-only default or upper-layer transaction context).",
    "protocol": "JDBC",
    "connectionInfo": "configured via JdbcTemplate bean",
    "codeExample": "final String sql = \"select \" + imageMapper.schema(entityType);\nfinal ImageData imageData = this.jdbcTemplate.queryForObject(sql, imageMapper, entityId);"
  },
  {
    "path": "org.apache.fineract.infrastructure.documentmanagement.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL SELECT queries against the database to retrieve document metadata.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_document"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with WHERE clauses filtering by parent entity type and ID.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sql, mapper, new Object[] { entityType, entityId });"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.service.FineractEntityAccessReadServiceImpl",
    "mechanism": "JDBC",
    "name": "Fineract Database",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It manually maps ResultSets to domain objects using inner classes implementing RowMapper. It constructs dynamic SQL for filtering and joins multiple tables to retrieve human-readable names for entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_entity_to_entity_mapping",
      "m_entity_relation",
      "m_office",
      "m_role",
      "m_product_loan",
      "m_savings_product",
      "m_charge"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses parameterized SQL queries with '?' placeholders. It includes simple SELECTs, dynamic WHERE clauses based on hierarchy, and complex JOINs with CASE statements in the 'EntityToEntityMapper' to resolve entity names based on relation types.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(sql, mapper, new Object[] { relId, fromEntityId });"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.jobs",
    "mechanism": "JDBC",
    "name": "JobRepository",
    "description": "The class interacts with the database indirectly through the Spring Batch `JobRepository`. This component is responsible for persisting job metadata, including job instances, execution contexts, and step executions, typically into standard Spring Batch tables (e.g., BATCH_JOB_INSTANCE, BATCH_JOB_EXECUTION).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_JOB_INSTANCE",
      "BATCH_JOB_EXECUTION",
      "BATCH_JOB_EXECUTION_PARAMS",
      "BATCH_STEP_EXECUTION",
      "BATCH_STEP_EXECUTION_CONTEXT",
      "BATCH_JOB_EXECUTION_CONTEXT"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Batch internal CRUD operations for job metadata management",
    "transactionHandling": "Spring PlatformTransactionManager",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "new StepBuilder(StepName.SEND_ASYNCHRONOUS_EVENTS_STEP.name(), jobRepository).tasklet(tasklet, transactionManager)"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class mocks Spring's JdbcTemplate to simulate database interactions. While it does not connect to a real database, it defines the expected SQL query behavior and response structures used by the service under test.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simulated SQL queries via Mockito",
    "transactionHandling": "none",
    "protocol": "JDBC (Mocked)",
    "connectionInfo": "n/a",
    "codeExample": "when(jdbcTemplate.queryForList(anyString(), eq(String.class))).thenReturn(configurations);"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplateFactory",
    "description": "The service uses a `JdbcTemplateFactory` to create a Spring `JdbcTemplate` configured for a specific tenant's database connection. It executes raw SQL queries to retrieve configuration data.",
    "databaseName": "Tenant-specific database",
    "tablesAccessed": [
      "m_external_event_configuration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query to fetch a list of strings.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Managed via JdbcTemplateFactory per tenant",
    "codeExample": "jdbcTemplate.queryForList(\"select me.type as type from m_external_event_configuration me\", String.class)"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.service.JdbcTemplateFactory",
    "mechanism": "JDBC",
    "name": "JdbcTemplateFactory",
    "description": "This class acts as a configuration factory that prepares JDBC connections. It does not execute queries itself but creates the Spring JdbcTemplate and NamedParameterJdbcTemplate objects that are used by other components to interact with the database via JDBC.",
    "databaseName": "Dynamic (Tenant Specific)",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Managed via TenantDataSourceFactory",
    "codeExample": "DataSource tenantDataSource = tenantDataSourceFactory.create(tenant);\nreturn new JdbcTemplate(tenantDataSource);"
  },
  {
    "path": "org.apache.fineract.infrastructure.gcm.service",
    "mechanism": "JDBC",
    "name": "DeviceRegistrationReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It defines a custom RowMapper (DeviceRegistrationDataMapper) to map the result set columns to the DeviceRegistrationData domain object. The queries involve joining the 'client_device_registration' table with the 'm_client' table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "client_device_registration",
      "m_client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with a LEFT JOIN.",
    "transactionHandling": "unknown",
    "protocol": "SQL",
    "connectionInfo": "unknown",
    "codeExample": "String sql = \"select \" + drm.schema() + \" where cdr.id = ? \";\nreturn this.jdbcTemplate.queryForObject(sql, drm, id);"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.data",
    "mechanism": "JDBC",
    "name": "EventResultSetExtractor",
    "description": "Implements Spring's ResultSetExtractor to map SQL results to Java objects manually.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code processes a flat result set likely resulting from a JOIN query, aggregating the data in memory.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "final String groupingName = rs.getString(\"grouping\");\nfinal String entityName = rs.getString(\"entity_name\");"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.service",
    "mechanism": "JDBC",
    "name": "Fineract Database",
    "description": "The class uses Spring's `JdbcTemplate` for the majority of its read operations, executing raw SQL queries with joins across multiple tables. It also utilizes a Spring Data JPA repository (`HookRepository`) for one specific cached query.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_hook",
      "m_hook_templates",
      "m_template",
      "m_hook_registered_events",
      "m_hook_configuration",
      "m_hook_schema",
      "m_permission"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses raw SQL strings with string concatenation for schema definitions within inner Mapper classes. It performs `SELECT` operations involving `LEFT JOIN` and `INNER JOIN` to aggregate data from parent and child tables (e.g., hooks and their events/configurations).",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final HookMapper rm = new HookMapper(jdbcTemplate);\nfinal String sql = \"select \" + rm.schema() + \" order by h.name\";\nreturn jdbcTemplate.query(sql, rm);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.ScheduledJobRunnerConfig",
    "mechanism": "JDBC",
    "name": "Spring Batch Repository",
    "description": "The class configures the Spring Batch JobRepository and JobExplorer, which interact directly with the database to store and retrieve batch execution metadata (JobInstances, JobExecutions, StepExecutions). It uses a `RoutingDataSource` to connect to the database and a custom `ExtendedJpaTransactionManager` for transaction handling. The `JobRepositoryFactoryBean` internally uses JDBC to perform CRUD operations on the batch meta-tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_JOB_INSTANCE",
      "BATCH_JOB_EXECUTION",
      "BATCH_JOB_EXECUTION_PARAMS",
      "BATCH_STEP_EXECUTION",
      "BATCH_STEP_EXECUTION_CONTEXT",
      "BATCH_JOB_EXECUTION_CONTEXT"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard Spring Batch JDBC queries for managing job state.",
    "transactionHandling": "Spring @Transactional via PlatformTransactionManager",
    "protocol": "JDBC",
    "connectionInfo": "Configured via RoutingDataSource",
    "codeExample": "JobRepositoryFactoryBean factory = new JobRepositoryFactoryBean();\nfactory.setDataSource(routingDataSource);\nfactory.setTransactionManager(transactionManager);\nfactory.setIsolationLevelForCreate(\"ISOLATION_READ_COMMITTED\");"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.config.FineractDataFieldMaxValueIncrementerFactory",
    "mechanism": "JDBC",
    "name": "FineractDataFieldMaxValueIncrementerFactory",
    "description": "The class interacts with the database via Spring JDBC support classes to manage sequence generation. It uses a `DataSource` to instantiate specific incrementer implementations (`MySQLMaxValueIncrementer`, `PostgresSequenceMaxValueIncrementer`) which execute SQL to retrieve or update sequence values.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown (dynamic based on incrementerName)"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Sequence generation (SELECT/UPDATE for MySQL, Sequence calls for Postgres)",
    "transactionHandling": "unknown",
    "protocol": "MySQL, MariaDB, PostgreSQL",
    "connectionInfo": "DataSource injected via constructor",
    "codeExample": "MySQLMaxValueIncrementer mySQLMaxValueIncrementer = new MySQLMaxValueIncrementer(dataSource, incrementerName, incrementerColumnName);\nmySQLMaxValueIncrementer.setUseNewConnection(true);\nreturn mySQLMaxValueIncrementer;"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain",
    "mechanism": "JDBC",
    "name": "CustomJobParameterRepositoryImpl",
    "description": "The class interacts directly with the database using Spring's JDBC abstraction (NamedParameterJdbcTemplate). It performs CRUD operations on the 'batch_custom_job_parameters' table. It specifically handles JSON data types by serializing objects before insertion and retrieving them as strings. It relies on a 'DatabaseSpecificSQLGenerator' helper to abstract away vendor-specific SQL differences for JSON casting and identity retrieval.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "batch_custom_job_parameters"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations involving INSERT with JSON casting and SELECT by primary key.",
    "transactionHandling": "unknown",
    "protocol": "JDBC (Generic)",
    "connectionInfo": "n/a",
    "codeExample": "final String insertSQL = \"INSERT INTO batch_custom_job_parameters (parameter_json) VALUES (%s)\"\n        .formatted(databaseSpecificSQLGenerator.castJson(\":jsonString\"));\nfinal String jsonString = gson.toJson(customJobParameters);\nSqlParameterSource parameters = new MapSqlParameterSource(\"jsonString\", jsonString);\nnamedParameterJdbcTemplate.update(insertSQL, parameters);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain.JobExecutionRepository",
    "mechanism": "JDBC",
    "name": "JobExecutionRepository",
    "description": "The class uses `NamedParameterJdbcTemplate` to execute raw SQL queries against Spring Batch metadata tables and a custom parameter table. It explicitly handles SQL dialect differences for JSON operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_JOB_INSTANCE",
      "BATCH_JOB_EXECUTION",
      "BATCH_STEP_EXECUTION",
      "BATCH_JOB_EXECUTION_PARAMS",
      "batch_custom_job_parameters"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Complex joins involving subqueries, aggregations (COUNT, GROUP BY), and database-specific JSON parsing (json_array_elements, json_table).",
    "transactionHandling": "unknown",
    "protocol": "PostgreSQL, MySQL",
    "connectionInfo": "n/a",
    "codeExample": "namedParameterJdbcTemplate.update(\"\"\"\n    UPDATE BATCH_JOB_EXECUTION\n    SET STATUS = :status, START_TIME = null\n    WHERE JOB_EXECUTION_ID = :jobExecutionId\n\"\"\", Map.of(\"status\", FAILED.name(), \"jobExecutionId\", stuckJobId));"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service",
    "mechanism": "JDBC",
    "name": "JobExecutionRepository",
    "description": "The class interacts with the database to identify stuck batch jobs. It uses a 'JdbcTemplateFactory' to create a 'NamedParameterJdbcTemplate' specific to each tenant, which is then passed to the 'JobExecutionRepository' to execute the query.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Selects job names based on status (stuck/running) via a repository helper.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "Derived dynamically per tenant via JdbcTemplateFactory",
    "codeExample": "NamedParameterJdbcTemplate namedParameterJdbcTemplate = jdbcTemplateFactory.createNamedParameterJdbcTemplate(tenant);\nList<String> stuckJobNames = jobExecutionRepository.getStuckJobNames(namedParameterJdbcTemplate);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service.SchedulerJobRunnerReadServiceImpl",
    "mechanism": "JDBC",
    "name": "SchedulerJobRunnerReadServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It constructs SQL strings dynamically using a StringBuilder and a DatabaseSpecificSQLGenerator to handle dialect-specific syntax (like limits and escaping). It maps results to Java objects using custom RowMapper implementations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "job",
      "job_run_history"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses parameterized SQL queries for selecting data. It employs simple SELECTs with WHERE clauses for single entity retrieval and JOINs (LEFT JOIN, JOIN) to link job details with run history. It also dynamically appends ORDER BY and LIMIT clauses for pagination.",
    "transactionHandling": "Spring @Transactional annotations (readOnly = true) are used at the class level.",
    "protocol": "JDBC",
    "connectionInfo": "Injected via DataSource/JdbcTemplate (not visible in code)",
    "codeExample": "final String sql = detailMapper.schema() + \" where job.id=?\";\nreturn this.jdbcTemplate.queryForObject(sql, detailMapper, new Object[] { jobId });"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service.executealldirtyjobs",
    "mechanism": "JDBC",
    "name": "JobRepository",
    "description": "The class injects and uses a Spring Batch 'JobRepository'. This component is responsible for interacting with the database to persist batch metadata (JobInstances, JobExecutions, StepExecutions, etc.). While the SQL is abstracted away by the framework, the configuration here explicitly wires up the persistence mechanism for the batch job.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_JOB_INSTANCE",
      "BATCH_JOB_EXECUTION",
      "BATCH_STEP_EXECUTION"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Batch internal metadata management (CRUD on batch tables)",
    "transactionHandling": "Spring @Transactional via PlatformTransactionManager",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring Context (DataSource)",
    "codeExample": "new StepBuilder(JobName.EXECUTE_DIRTY_JOBS.name(), jobRepository).tasklet(executeAllDirtyJobsTasklet, transactionManager)"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service.updatenpa",
    "mechanism": "JDBC",
    "name": "RoutingDataSourceServiceFactory",
    "description": "The code interacts with the database using Spring's JdbcTemplate to execute raw SQL UPDATE statements. It manually constructs SQL strings to handle complex joins between 'm_loan', 'm_loan_arrears_aging', and 'm_product_loan' tables. It specifically handles database portability by checking the database type (MySQL vs others) and adjusting the SQL syntax for UPDATE joins accordingly.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_loan_arrears_aging",
      "m_product_loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Complex UPDATE statements with inner joins and subqueries; dynamic SQL generation based on DB vendor.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "Derived from dataSourceServiceFactory.determineDataSourceService().retrieveDataSource()",
    "codeExample": "jdbcTemplate.update(resetNPASqlBuilder.toString(), user.getId(), DateUtils.getOffsetDateTimeOfTenantWithMostPrecision());"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.service",
    "mechanism": "JDBC",
    "name": "ReportMailingJobConfigurationReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries against the database to read configuration data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_report_mailing_job_configuration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with basic filtering.",
    "transactionHandling": "None explicit (likely read-only or auto-commit)",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "this.jdbcTemplate.queryForObject(sql, mapper, new Object[] { name });"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.service",
    "mechanism": "JDBC",
    "name": "ReportMailingJobRunHistoryReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries against the database. It constructs SQL strings dynamically to support filtering and pagination.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_report_mailing_job_run_history"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL construction with pagination and sorting logic.",
    "transactionHandling": "None explicit (likely read-only context)",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource",
    "codeExample": "sqlStringBuilder.append(\"select \" + sqlGenerator.calcFoundRows() + \" \");\nsqlStringBuilder.append(this.reportMailingJobRunHistoryMapper.reportMailingJobRunHistorySchema());\nif (reportMailingJobId != null) {\n    sqlStringBuilder.append(\" where rmjrh.job_id = ? \");\n    queryParameters.add(reportMailingJobId);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.service.ReportMailingJobReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "ReportMailingJobReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It manually constructs SQL strings, including joins between the mailing job, app user, and stretchy report tables. It uses a custom RowMapper to map the ResultSet to domain objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_report_mailing_job",
      "m_appuser",
      "stretchy_report"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses dynamic SQL generation for pagination and sorting, and static SQL for single-record retrieval. It performs INNER and LEFT JOINs to fetch related user and report information.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final String sql = \"select \" + mapper.reportMailingJobSchema() + \" where rmj.id = ? and rmj.is_deleted = false\";\nreturn this.jdbcTemplate.queryForObject(sql, mapper, new Object[] { reportMailingJobId });"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.exception.EscapeSqlLiteralException",
    "mechanism": "JDBC",
    "name": "SQLExceptionWrapper",
    "description": "This class does not perform direct database operations but is tightly coupled to the JDBC API by wrapping `java.sql.SQLException`. It is used to handle errors originating from database interactions, specifically regarding SQL literal escaping.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JDBC API",
    "connectionInfo": "n/a",
    "codeExample": "public EscapeSqlLiteralException(String message, SQLException e) {\n    super(message, e);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.service",
    "mechanism": "JDBC",
    "name": "BasicAuthTenantDetailsServiceJdbc",
    "description": "The class uses Spring's `JdbcTemplate` to execute raw SQL queries against the tenant database to retrieve tenant configuration.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown (dynamic schema via TenantMapper)"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query with a WHERE clause to fetch a single record by ID.",
    "transactionHandling": "None explicit (likely auto-commit or managed by caller)",
    "protocol": "JDBC",
    "connectionInfo": "hikariTenantDataSource",
    "codeExample": "this.jdbcTemplate.queryForObject(sql, rm, new Object[] { tenantIdentifier });"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.utils.ColumnValidator",
    "mechanism": "JDBC",
    "name": "DatabaseMetaData Inspection",
    "description": "The class interacts with the database primarily to inspect metadata rather than to manipulate data. It obtains a raw JDBC connection from the Spring `JdbcTemplate` to access `DatabaseMetaData`. It uses this metadata to verify the existence of tables and columns referenced in dynamic SQL strings.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Metadata inspection using DatabaseMetaData.getColumns()",
    "transactionHandling": "Manual connection release using DataSourceUtils",
    "protocol": "JDBC",
    "connectionInfo": "Derived from JdbcTemplate DataSource",
    "codeExample": "connection = this.jdbcTemplate.getDataSource().getConnection();\nDatabaseMetaData dbMetaData = connection.getMetaData();\nresultSet = dbMetaData.getColumns(null, null, entry.getKey(), null);"
  },
  {
    "path": "org.apache.fineract.infrastructure.sms.service.SmsReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "SmsReadPlatformService",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It manually constructs SQL strings, often concatenating parameters or using placeholders, and maps the results to Java objects using a custom RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "sms_messages_outbound",
      "sms_campaign"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL construction with string concatenation for filtering and pagination limits. Uses JOINs between message and campaign tables.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "final String sql = \"select \" + this.smsRowMapper.schema() + \" where smo.id = ?\";\nreturn this.jdbcTemplate.queryForObject(sql, this.smsRowMapper, new Object[] { resourceId });"
  },
  {
    "path": "org.apache.fineract.infrastructure.springbatch.messagehandler",
    "mechanism": "JDBC",
    "name": "Spring Batch JobRepository",
    "description": "The class interacts with the underlying database used by Spring Batch to persist job and step execution metadata. It uses 'JobExplorer' for reading execution state and 'JobRepository' for updating it. While the specific database technology is abstracted, Spring Batch typically uses JDBC.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_STEP_EXECUTION",
      "BATCH_JOB_EXECUTION",
      "BATCH_STEP_EXECUTION_CONTEXT"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Batch internal metadata queries (Select by ID, Update status)",
    "transactionHandling": "Managed by Spring Batch JobRepository implementation",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "StepExecution stepExecution = jobExplorer.getStepExecution(jobExecutionId, stepExecutionId);\n// ...\njobRepository.update(stepExecution);"
  },
  {
    "path": "org.apache.fineract.infrastructure.survey.service",
    "mechanism": "JDBC",
    "name": "PovertyLineServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL SELECT queries. It retrieves data using SqlRowSet to allow for cursor manipulation (scrolling) during the mapping process.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ppi_likelihoods",
      "ppi_likelihoods_ppi",
      "ppi_poverty_line",
      "ppi_scores"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins involving 3 to 4 tables to link poverty lines, likelihoods, and scores.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via Spring",
    "codeExample": "this.jdbcTemplate.queryForRowSet(sql, new Object[] { ppiName });"
  },
  {
    "path": "org.apache.fineract.infrastructure.survey.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It interacts with system configuration tables and dynamic application tables (surveys). It manually maps SqlRowSet results to Java objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "x_registered_table",
      "c_configuration",
      "m_appuser_role",
      "m_role",
      "m_role_permission",
      "m_permission",
      "ppi_likelihoods_ppi",
      "ppi_scores",
      "ppi_poverty_line",
      "ppi_likelihoods"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins involving system metadata tables and dynamic tables determined at runtime. Contains potential N+1 query patterns when retrieving scores for all surveys.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "final String sql = \"select application_table_name... from x_registered_table...\";\nfinal SqlRowSet rs = this.jdbcTemplate.queryForRowSet(sql);"
  },
  {
    "path": "org.apache.fineract.infrastructure.survey.service.ReadLikelihoodServiceImpl",
    "mechanism": "JDBC",
    "name": "ReadLikelihoodServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute parameterized SQL queries directly against the database. It constructs SQL strings that join multiple tables to retrieve the required survey likelihood data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ppi_poverty_line",
      "ppi_likelihoods_ppi",
      "ppi_likelihoods"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "SQL queries involving INNER JOINs across three tables with GROUP BY clauses and WHERE filtering.",
    "transactionHandling": "NONE",
    "protocol": "SQL",
    "connectionInfo": "Managed by Spring JdbcTemplate",
    "codeExample": "return this.jdbcTemplate.queryForRowSet(sql, new Object[] { ppiName });"
  },
  {
    "path": "org.apache.fineract.mix.service",
    "mechanism": "JDBC",
    "name": "MixTaxonomyReadPlatformServiceImpl",
    "description": "The service interacts with the database using Spring's JdbcTemplate to execute inline SQL queries. It performs read operations involving joins between taxonomy and namespace tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "mix_taxonomy",
      "mix_xbrl_namespace"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL SELECT statements with LEFT JOINs.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sql, this.mixTaxonomyMapper);"
  },
  {
    "path": "org.apache.fineract.mix.service.MixTaxonomyMappingReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "MixTaxonomyMappingReadPlatformServiceImpl",
    "description": "The class interacts with the database using Spring's JdbcTemplate to execute raw SQL queries. It reads configuration data from a specific table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "mix_taxonomy_mapping"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query fetching specific columns from a single table.",
    "transactionHandling": "None explicit (likely read-only or auto-commit)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring JdbcTemplate",
    "codeExample": "this.jdbcTemplate.queryForObject(sqlString, rm);"
  },
  {
    "path": "org.apache.fineract.mix.service.NamespaceReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "NamespaceReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute parameterized SQL SELECT queries directly against the database. It defines a RowMapper to map the columns 'id', 'prefix', and 'url' to the NamespaceData object.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "mix_xbrl_namespace"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD SELECT queries using parameterized SQL.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource (injected into JdbcTemplate)",
    "codeExample": "this.jdbcTemplate.queryForObject(sql, this.namespaceMapper, new Object[] { id });"
  },
  {
    "path": "org.apache.fineract.mix.service.XBRLResultServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries directly against the database. It constructs a large SQL string with unions and joins to aggregate accounting data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_gl_journal_entry",
      "acc_gl_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex aggregation query using UNION, LEFT/RIGHT OUTER JOIN, and GROUP BY to calculate debits and credits.",
    "transactionHandling": "None observed (likely read-only or auto-commit)",
    "protocol": "SQL",
    "connectionInfo": "DataSource injected via JdbcTemplate",
    "codeExample": "final SqlRowSet rs = this.jdbcTemplate.queryForRowSet(sql);"
  },
  {
    "path": "org.apache.fineract.notification.service.NotificationReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Notification Database Access",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It performs SELECT operations with joins to retrieve notification data and UPDATE operations to change read status.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "notification_mapper",
      "notification_generator"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Inline SQL strings with joins between mapper and generator tables, utilizing dynamic pagination and sorting logic.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sql, notificationMapperRow, appUserId);"
  },
  {
    "path": "org.apache.fineract.organisation.holiday.service",
    "mechanism": "JDBC",
    "name": "HolidayReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It manually maps ResultSets to objects using a custom RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_holiday",
      "m_holiday_office"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL construction with joins and parameter binding.",
    "transactionHandling": "None (Read-only operations, likely relies on default auto-commit or higher-level transaction management)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "this.jdbcTemplate.query(sql, rm, finalObjectArray);"
  },
  {
    "path": "org.apache.fineract.organisation.monetary.service.CurrencyReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "CurrencyReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries against the database. It maps results to objects using a custom RowMapper implementation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_organisation_currency",
      "m_currency"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with ORDER BY clauses.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "this.jdbcTemplate.query(sql, this.currencyRowMapper);"
  },
  {
    "path": "org.apache.fineract.organisation.office.service.OfficeReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Fineract Database",
    "description": "The class primarily uses Spring's `JdbcTemplate` to execute raw SQL SELECT queries. It constructs SQL strings dynamically to handle hierarchy filtering and sorting. It also uses `OfficeRepository` (Spring Data JPA) for one specific lookup by External ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_office",
      "m_office_transaction",
      "m_currency"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses dynamic SQL generation for filtering by hierarchy (using 'like' clauses) and sorting. It employs complex string concatenation in SQL for visual hierarchy representation (dots). It performs joins between office and currency tables.",
    "transactionHandling": "Read-only operations, implicit transaction management (likely non-transactional or read-only transaction at service boundary, though not explicitly annotated with @Transactional in this file).",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sqlBuilder.toString(), rm, new Object[] { hierarchySearchString });"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.service",
    "mechanism": "JDBC",
    "name": "ProvisioningCategoryReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to perform direct SQL queries against the relational database. It manually maps the result set to domain objects using a custom RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_provision_category"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query with ORDER BY clause",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource",
    "codeExample": "final String sql = \"select \" + this.provisionCategoryRowMapper.schema() + \" from m_provision_category pc order by pc.id\";\nreturn this.jdbcTemplate.query(sql, this.provisionCategoryRowMapper);"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.service",
    "mechanism": "JDBC",
    "name": "ProvisioningCriteriaReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries. It manually maps ResultSets to Java objects using inner RowMapper classes.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_provisioning_criteria",
      "m_appuser",
      "m_loanproduct_provisioning_mapping",
      "m_provisioning_criteria_definition",
      "acc_gl_account",
      "m_provision_category"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD SELECT queries with LEFT JOINs to fetch related entity names (e.g., usernames, category names, GL account names).",
    "transactionHandling": "None (Read-only service)",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(sql, mapper);"
  },
  {
    "path": "org.apache.fineract.organisation.staff.service.StaffReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "StaffReadPlatformService",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It manually maps ResultSets to domain objects using inner RowMapper classes. It constructs dynamic SQL based on filter criteria.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_staff",
      "m_office",
      "m_client",
      "m_group",
      "m_loan",
      "m_savings_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses parameterized SQL SELECT queries with JOINS (inner and left outer). It uses dynamic criteria building for filtering and hierarchy-based security checks using 'like' operators.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via Spring JdbcTemplate",
    "codeExample": "this.jdbcTemplate.query(sql, LOOKUP_MAPPER, defaultOfficeId, hierarchy);"
  },
  {
    "path": "org.apache.fineract.organisation.teller.data",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the 'm_cashiers' table. It constructs SQL strings dynamically to check for overlapping time ranges and to retrieve cashier IDs based on staff IDs and current timestamps.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_cashiers"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL queries with string concatenation for dynamic criteria (dates, times, IDs).",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "String sql = \"select count(*) from m_cashiers c where c.staff_id = \" + staffId ...;\nint count = this.jdbcTemplate.queryForObject(sql, Integer.class);"
  },
  {
    "path": "org.apache.fineract.organisation.teller.service",
    "mechanism": "JDBC",
    "name": "Fineract Database",
    "description": "The class uses Spring's `JdbcTemplate` to execute raw SQL queries. It manually maps `ResultSet` data to Java objects using inner `RowMapper` classes. It constructs SQL strings dynamically using `StringBuilder` to handle optional search criteria and complex unions across multiple tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_tellers",
      "m_office",
      "m_cashiers",
      "m_staff",
      "m_cashier_transactions",
      "m_savings_account_transaction",
      "m_loan_transaction",
      "m_client_transaction",
      "m_savings_account",
      "m_client",
      "m_appuser",
      "m_payment_detail",
      "m_payment_type",
      "m_account_transfer_transaction",
      "r_enum_value",
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex SQL queries involving multiple UNIONs to aggregate transaction data from different modules (savings, loans, client). Dynamic WHERE clause generation based on search parameters.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(sql, this.lookupMapper, new Object[] { defaultOfficeId });"
  },
  {
    "path": "org.apache.fineract.organisation.workingdays.service",
    "mechanism": "JDBC",
    "name": "WorkingDaysReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL SELECT queries against the 'm_working_days' table. It maps the result set manually using a RowMapper implementation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_working_days"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query with column mapping",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "final String sql = \" select \" + rm.schema();\nWorkingDaysData data = this.jdbcTemplate.queryForObject(sql, rm);"
  },
  {
    "path": "org.apache.fineract.portfolio.account.jobs.executestandinginstructions",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's `JdbcTemplate` to perform direct SQL updates and inserts. It updates the `last_run_date` of standing instructions and inserts audit logs into a history table. It also relies on `StandingInstructionReadPlatformService` for reading data, which likely uses a different mechanism (JPA/Spring Data) internally, but this file specifically uses JDBC.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_account_transfer_standing_instructions",
      "m_account_transfer_standing_instructions_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Inline SQL INSERT and UPDATE statements with parameter binding.",
    "transactionHandling": "Manual/Implicit via JdbcTemplate (likely part of a larger Spring Batch transaction context).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final String updateQuery = \"UPDATE m_account_transfer_standing_instructions SET last_run_date = ? where id = ?\";\njdbcTemplate.update(updateQuery, transactionDate, data.getId());"
  },
  {
    "path": "org.apache.fineract.portfolio.account.jobs.executestandinginstructions",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class injects a Spring JdbcTemplate and a DatabaseSpecificSQLGenerator, which are then passed to the Tasklet bean. While this configuration class does not execute queries directly, it wires the components that perform direct database access via JDBC.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The actual queries are encapsulated within the Tasklet and Services injected here, likely involving reading standing instructions and writing transfer records.",
    "transactionHandling": "Spring Batch Step configured with PlatformTransactionManager",
    "protocol": "JDBC",
    "connectionInfo": "DataSource configured in Spring Context (injected via JdbcTemplate)",
    "codeExample": "return new ExecuteStandingInstructionsTasklet(standingInstructionReadPlatformService, jdbcTemplate, sqlGenerator,\n                accountTransfersWritePlatformService);"
  },
  {
    "path": "org.apache.fineract.portfolio.account.service",
    "mechanism": "JDBC",
    "name": "StandingInstructionHistoryReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It dynamically builds SQL strings with multiple joins to retrieve standing instruction history data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_account_transfer_standing_instructions_history",
      "m_account_transfer_standing_instructions",
      "m_account_transfer_details",
      "m_office",
      "m_client",
      "m_savings_account",
      "m_savings_product",
      "m_loan",
      "m_product_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins across 9 tables with dynamic WHERE clauses based on filter criteria.",
    "transactionHandling": "None explicit (likely read-only transaction managed at a higher layer)",
    "protocol": "SQL",
    "connectionInfo": "n/a",
    "codeExample": "final StringBuilder sqlBuilder = new StringBuilder(200);\nsqlBuilder.append(\"select \" + sqlGenerator.calcFoundRows() + \" \");\nsqlBuilder.append(this.standingInstructionHistoryMapper.schema());\nif (standingInstructionDTO.transferType() != null) {\n    sqlBuilder.append(\" and atd.transfer_type=? \");\n    paramObj.add(standingInstructionDTO.transferType());\n}\nreturn this.paginationHelper.fetchPage(this.jdbcTemplate, sqlBuilder.toString(), finalObjectArray, this.standingInstructionHistoryMapper);"
  },
  {
    "path": "org.apache.fineract.portfolio.account.service",
    "mechanism": "JDBC",
    "name": "Fineract Database",
    "description": "The class uses Spring's JdbcTemplate to interact directly with the database. It constructs SQL queries dynamically for search and filtering operations and uses RowMappers to convert ResultSet rows into Java objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_account_transfer_standing_instructions",
      "m_account_transfer_details",
      "m_office",
      "m_client",
      "m_savings_account",
      "m_savings_product",
      "m_loan",
      "m_product_loan",
      "m_loan_repayment_schedule"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation for search filters; complex joins across multiple tables (office, client, accounts, products); aggregation queries for loan dues.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sqlBuilder.toString(), this.standingInstructionMapper, status);"
  },
  {
    "path": "org.apache.fineract.portfolio.account.service.AccountAssociationsReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It manually maps ResultSets to domain objects using a custom RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_portfolio_account_associations",
      "m_loan",
      "m_savings_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL queries with joins and filtering by IDs and Enum values.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource (not visible in file)",
    "codeExample": "this.jdbcTemplate.queryForObject(\"select ... where aa.loan_account_id = ?\", mapper, loanId, ...)"
  },
  {
    "path": "org.apache.fineract.portfolio.account.service.AccountTransfersReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "AccountTransfersReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It manually constructs SQL strings, often concatenating clauses for dynamic filtering and pagination. It uses a custom RowMapper to transform ResultSet rows into domain objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_account_transfer_transaction",
      "m_account_transfer_details",
      "m_currency",
      "m_office",
      "m_client",
      "m_savings_account",
      "m_loan",
      "m_savings_account_transaction",
      "m_loan_transaction",
      "m_account_transfer_standing_instructions"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins across multiple tables (transfers, clients, offices, accounts), dynamic SQL generation for search/filtering, and aggregation queries.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.queryForObject(sql, this.accountTransfersMapper, new Object[] { transferId });"
  },
  {
    "path": "org.apache.fineract.portfolio.account.service.PortfolioAccountReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Portfolio Database Access",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It constructs SQL strings dynamically and maps results using custom RowMapper implementations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_savings_product",
      "m_currency",
      "m_client",
      "m_group",
      "m_staff",
      "m_loan",
      "m_product_loan",
      "m_loan_repayment_schedule"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL construction with joins and subqueries (for refund calculations).",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "accountData = this.jdbcTemplate.queryForObject(sql, this.loanAccountMapper, sqlParams);"
  },
  {
    "path": "org.apache.fineract.portfolio.accountdetails.service",
    "mechanism": "JDBC",
    "name": "AccountDetailsReadPlatformService",
    "description": "The service uses Spring's `JdbcTemplate` to execute raw SQL SELECT queries. It constructs these queries by appending WHERE clauses to base schemas defined in inner `RowMapper` classes. The schemas involve complex joins across multiple tables to aggregate account information.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_savings_account",
      "m_share_account",
      "m_guarantor",
      "m_client",
      "m_product_loan",
      "m_loan_arrears_aging",
      "glim_accounts",
      "m_savings_product",
      "m_currency",
      "m_appuser",
      "m_share_product",
      "m_code_value",
      "m_savings_account_transaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex SQL SELECT statements with multiple LEFT JOINs to fetch related entity data (products, users, currency, arrears). Includes subqueries in some mappers.",
    "transactionHandling": "None explicit in this class (Read-only operations).",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via JdbcTemplate",
    "codeExample": "this.jdbcTemplate.query(sql, rm, inputs);"
  },
  {
    "path": "org.apache.fineract.portfolio.address.service.AddressReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It employs custom RowMapper implementations (AddFieldsMapper and AddMapper) to map the ResultSet to the AddressData domain object. The SQL is constructed via string concatenation in the mapper classes.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_address",
      "m_client",
      "m_code_value",
      "m_client_address"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses parameterized SELECT queries with multiple JOINs (LEFT JOIN, JOIN) to link address data with client data and code values (dictionaries).",
    "transactionHandling": "none",
    "protocol": "SQL",
    "connectionInfo": "configured via Spring DataSource (not visible in file)",
    "codeExample": "final String sql = \"select \" + rm.schema() + \" where client.id=?\";\nreturn this.jdbcTemplate.query(sql, rm, new Object[] { clientid });"
  },
  {
    "path": "org.apache.fineract.portfolio.address.service.FieldConfigurationReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "FieldConfigurationReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to perform direct SQL SELECT operations on the configuration table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_field_configuration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with a WHERE clause filtering by entity name.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource (injected JdbcTemplate)",
    "codeExample": "this.jdbcTemplate.query(sql, rm, new Object[] { entity });"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.service.CalendarReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It manually maps ResultSets to objects using inner class RowMappers. It interacts with calendar definition and instance tables, as well as user and entity tables for joins.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_calendar",
      "m_calendar_instance",
      "m_appuser",
      "m_calendar_history",
      "m_client",
      "m_group",
      "m_group_client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses parameterized SQL SELECT queries with joins. It constructs some SQL fragments dynamically (e.g., IN clauses for lists, hierarchy conditions). It uses subqueries for hierarchical data retrieval.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via Spring (details not in file)",
    "codeExample": "this.jdbcTemplate.queryForObject(sql, rm, new Object[] { calendarId, entityId, entityTypeId });"
  },
  {
    "path": "org.apache.fineract.portfolio.charge.service.ChargeReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "ChargeReadPlatformServiceImpl",
    "description": "This class directly interacts with the database using Spring's `JdbcTemplate` and `NamedParameterJdbcTemplate`. It constructs raw SQL strings to perform read-only queries for charge data. A private inner `RowMapper` class, `ChargeMapper`, is used to map the `ResultSet` from the database into `ChargeData` DTOs. Queries involve joins across multiple tables to gather comprehensive charge information.",
    "databaseName": "not identifiable from code",
    "tablesAccessed": [
      "m_charge",
      "m_organisation_currency",
      "acc_gl_account",
      "m_tax_group",
      "m_payment_type",
      "m_product_loan_charge",
      "m_savings_product_charge",
      "m_share_product_charge",
      "m_loan",
      "m_product_loan",
      "m_savings_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The class uses direct SQL SELECT queries with JOINs and dynamic WHERE clauses. It does not use stored procedures, complex aggregations, or subqueries. The pattern is primarily fetching entities and their related data.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return this.jdbcTemplate.query(sql, rm, new Object[] { currencyCode }); // NOSONAR"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate and ClientTransactionRepository",
    "description": "The class primarily uses Spring's `JdbcTemplate` to execute raw SQL SELECT queries involving complex joins across multiple tables. It maps the results to data objects using a custom `RowMapper`. It also uses a Spring Data JPA repository (`ClientTransactionRepository`) for one specific lookup method.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client",
      "m_client_transaction",
      "m_currency",
      "m_payment_detail",
      "m_payment_type",
      "m_office",
      "m_client_charge_paid_by"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex SQL joins across 7 tables, dynamic filtering, and pagination logic.",
    "transactionHandling": "none (read-only operations, no explicit transaction management in this file)",
    "protocol": "Relational Database (SQL)",
    "connectionInfo": "Injected via DataSource/JdbcTemplate",
    "codeExample": "final String sql = \"select \" + this.clientTransactionMapper.schema() + \" where c.id = ? and tr.id= ?\";\nreturn this.jdbcTemplate.queryForObject(sql, this.clientTransactionMapper, clientId, transactionId);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It manually constructs SQL strings and uses a RowMapper to transform the ResultSet into domain objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_field_configuration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query with a WHERE clause filtering by an entity column.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource",
    "codeExample": "this.jdbcTemplate.query(sql, rm, entity);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service",
    "mechanism": "JDBC",
    "name": "ClientIdentifierReadPlatformServiceImpl",
    "description": "The class interacts directly with the database using Spring's `JdbcTemplate`. It constructs raw SQL queries involving joins across multiple tables (`m_client_identifier`, `m_client`, `m_office`, `m_code_value`) to assemble the client identifier data. It uses a custom `RowMapper` to map the result set columns to the `ClientIdentifierData` object.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client_identifier",
      "m_client",
      "m_office",
      "m_code_value"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "SQL SELECT queries with implicit joins across 4 tables, filtered by client ID and office hierarchy.",
    "transactionHandling": "NONE",
    "protocol": "JDBC",
    "connectionInfo": "Injected via JdbcTemplate",
    "codeExample": "this.jdbcTemplate.query(sql, rm, clientId, hierarchySearchString);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service",
    "mechanism": "JDBC",
    "name": "ClientFamilyMembersReadPlatformServiceImpl",
    "description": "The class interacts with the database using Spring's JdbcTemplate. It executes parameterized SQL SELECT queries to fetch data from the 'm_family_members' table and joins it with 'm_code_value' to retrieve descriptive values for foreign keys.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_family_members",
      "m_code_value"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with LEFT JOINs to resolve code values.",
    "transactionHandling": "None (Read-only operations)",
    "protocol": "JDBC",
    "connectionInfo": "Injected via JdbcTemplate",
    "codeExample": "this.jdbcTemplate.query(sql, rm, clientId);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service",
    "mechanism": "JDBC",
    "name": "ClientChargeReadPlatformServiceImpl",
    "description": "The class interacts directly with the database using Spring's `JdbcTemplate`. It constructs raw SQL SELECT statements that join the `m_charge`, `m_organisation_currency`, and `m_client_charge` tables to assemble the required data view.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_charge",
      "m_organisation_currency",
      "m_client_charge"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with JOINs, dynamic WHERE clauses based on filter criteria, and pagination logic.",
    "transactionHandling": "None explicitly defined in this read-only service.",
    "protocol": "JDBC",
    "connectionInfo": "Injected via JdbcTemplate",
    "codeExample": "this.jdbcTemplate.queryForObject(sql, rm, clientId, clientChargeId);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service.ClientReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Fineract Database",
    "description": "The class primarily uses Spring's `JdbcTemplate` to perform read-only operations against the database. It constructs complex SQL queries dynamically to handle search criteria, joins multiple tables (client, office, staff, code_value, etc.) to aggregate data, and uses `RowMapper` classes to transform `ResultSet` data into DTOs. It also utilizes `ClientRepositoryWrapper` (likely JPA/Spring Data) for retrieving domain entities in specific cases like `retrieveOne`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client",
      "m_office",
      "m_staff",
      "m_code_value",
      "m_savings_product",
      "m_client_non_person",
      "m_group_client",
      "m_group",
      "m_appuser",
      "m_selfservice_user_client_mapping",
      "m_client_identifier"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses dynamic SQL generation for search filters (building WHERE clauses based on input), complex joins to fetch related data (office, staff, code values) in a single query, and pagination logic.",
    "transactionHandling": "Not explicitly annotated with @Transactional in this file, relying on the service layer or default read-only behavior of the underlying connection for select statements.",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring JdbcTemplate",
    "codeExample": "final String sql = \"select \" + this.membersOfGroupMapper.schema() + \" where o.hierarchy like ? and pgc.group_id = ?\";\nreturn this.jdbcTemplate.query(sql, this.membersOfGroupMapper, hierarchySearchString, groupId);"
  },
  {
    "path": "org.apache.fineract.portfolio.collateral.service",
    "mechanism": "JDBC",
    "name": "CollateralReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL SELECT queries. It manually maps the ResultSet to domain objects using a custom RowMapper. The queries involve joins across multiple tables to aggregate collateral, code value, loan, and currency information.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_collateral",
      "m_code_value",
      "m_loan",
      "m_organisation_currency"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with JOINs to retrieve related entity data.",
    "transactionHandling": "None explicit (likely relies on auto-commit for read-only operations)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring JdbcTemplate (DataSource)",
    "codeExample": "this.jdbcTemplate.query(sql, rm, new Object[] { loanId });"
  },
  {
    "path": "org.apache.fineract.portfolio.collectionsheet.service",
    "mechanism": "JDBC",
    "name": "Fineract Core Database",
    "description": "The class uses Spring's NamedParameterJdbcTemplate to execute raw SQL queries. It manually maps ResultSets to domain objects using inner class RowMappers. The SQL is constructed dynamically to handle different hierarchy levels (Group vs Center) and filtering options.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_group",
      "m_office",
      "m_group_level",
      "m_staff",
      "m_group_client",
      "m_client",
      "m_loan",
      "m_product_loan",
      "m_currency",
      "m_loan_repayment_schedule",
      "m_calendar_instance",
      "m_meeting",
      "m_client_attendance",
      "m_loan_charge",
      "m_savings_account",
      "m_savings_product",
      "m_deposit_account_recurring_detail",
      "m_mandatory_savings_schedule"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins across multiple tables to aggregate financial data (loans, savings) with structural data (groups, clients). Uses dynamic SQL generation.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.namedParameterJdbcTemplate.query(mapper.collectionSheetSchema(false), namedParameters, mapper);"
  },
  {
    "path": "org.apache.fineract.portfolio.floatingrates.service.FloatingRatesReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "FloatingRatesReadPlatformServiceImpl",
    "description": "The class interacts directly with the database using Spring's JdbcTemplate. It constructs SQL queries manually using StringBuilder within inner RowMapper classes to select data from multiple tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_floating_rates",
      "m_appuser",
      "m_floating_rates_periods",
      "m_product_loan",
      "m_product_loan_floating_rates"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex SQL queries with multiple LEFT JOINs and subqueries, particularly in FloatingInterestRatePeriodRowMapper.",
    "transactionHandling": "None explicitly defined (likely relies on default read-only behavior or non-transactional reads).",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "final String sql = \"select \" + rateMapper.schema() + \" where rate.id = ?\";\nreturn this.jdbcTemplate.queryForObject(sql, rateMapper, new Object[] { floatingRateId });"
  },
  {
    "path": "org.apache.fineract.portfolio.fund.service",
    "mechanism": "JDBC",
    "name": "FundReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries against the database. It maps the results manually using a RowMapper implementation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_fund"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with basic filtering and ordering.",
    "transactionHandling": "None explicit (likely auto-commit for reads)",
    "protocol": "JDBC",
    "connectionInfo": "Injected via JdbcTemplate",
    "codeExample": "this.jdbcTemplate.query(sql, rm);"
  },
  {
    "path": "org.apache.fineract.portfolio.group.service",
    "mechanism": "JDBC",
    "name": "AllGroupTypesDataMapper",
    "description": "The class interacts with the database by defining a raw SQL schema and mapping the resulting JDBC ResultSet to Java objects. It uses Spring's RowMapper interface to facilitate this within the Spring JDBC framework.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_group",
      "m_office",
      "m_staff",
      "m_appuser"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins involving multiple tables (m_group, m_office, m_staff, m_appuser) to enrich the core entity data.",
    "transactionHandling": "None",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "sqlBuilder.append(\"g.id as id, g.account_no as accountNumber... from m_group g \");\n// ...\nfinal Long id = rs.getLong(\"id\");"
  },
  {
    "path": "org.apache.fineract.portfolio.group.service",
    "mechanism": "JDBC",
    "name": "GroupLevelReadPlatformServiceImpl",
    "description": "The service interacts with the database using Spring's JdbcTemplate to execute a raw SQL SELECT query. It manually maps the ResultSet to domain objects using a custom RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_group_level"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL SELECT statement using LEFT JOINs to retrieve self-referencing hierarchical data (parent and child levels).",
    "transactionHandling": "No explicit transaction management (likely read-only or auto-commit).",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring JdbcTemplate",
    "codeExample": "final String sql = \"select \" + rm.groupLevelSchema();\nreturn this.jdbcTemplate.query(sql, rm);"
  },
  {
    "path": "org.apache.fineract.portfolio.group.service",
    "mechanism": "JDBC",
    "name": "GroupReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It constructs SQL strings dynamically using StringBuilder and a custom SQLBuilder utility to manage WHERE clauses and arguments safely.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_group",
      "m_office"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation with joins, filtering criteria, and pagination.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(sqlBuilder.toString(), ALL_GROUP_TYPES_DATA_MAPPER, extraCriteria.getArguments());"
  },
  {
    "path": "org.apache.fineract.portfolio.group.service.CenterReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "CenterReadPlatformService Database Access",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It defines SQL schemas in inner RowMapper classes and constructs dynamic WHERE clauses using a SQLBuilder helper. It interacts with tables related to groups, offices, staff, calendars, and loans.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_group",
      "m_office",
      "m_staff",
      "m_appuser",
      "m_calendar",
      "m_calendar_instance",
      "m_group_client",
      "m_client",
      "m_loan",
      "m_loan_repayment_schedule"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with subqueries, aggregations for loan totals, and dynamic criteria generation.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(sql, this.centerMapper, new Object[] { centerId });"
  },
  {
    "path": "org.apache.fineract.portfolio.group.service.GroupRolesReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "GroupRolesReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL SELECT queries. It manually maps ResultSets to domain objects using a custom RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_group_roles",
      "m_code_value",
      "m_client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with JOINs",
    "transactionHandling": "None (Read-only operations)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "this.jdbcTemplate.query(sql, mapper, new Object[] { groupId });"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.service",
    "mechanism": "JDBC",
    "name": "InterestRateChartSlabReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It constructs SQL strings dynamically to handle database-specific syntax via DatabaseSpecificSQLGenerator. It reads from multiple joined tables to assemble complex objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_interest_rate_slab",
      "m_interest_incentives",
      "m_code_value",
      "m_currency"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins involving left joins to fetch parent entities (slabs) and child entities (incentives) in a single result set.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sql, this.chartSlabExtractor, new Object[] { chartId });"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.service.InterestRateChartReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "InterestRateChart Database Access",
    "description": "The class uses Spring JdbcTemplate to execute raw SQL queries. It constructs complex SQL strings involving multiple joins (charts, slabs, incentives, codes, currencies) and uses custom ResultSetExtractors to map the flat result set into a hierarchical object structure.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_interest_rate_chart",
      "m_interest_rate_slab",
      "m_interest_incentives",
      "m_code_value",
      "m_currency",
      "m_deposit_product_interest_rate_chart",
      "m_savings_product"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with sub-entities (slabs, incentives) and dynamic ordering.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "final String sql = \"select \" + CHART_ROW_MAPPER.schema() + \" where irc.id = ?\";\nreturn this.jdbcTemplate.queryForObject(sql, CHART_ROW_MAPPER, chartId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.guarantor.service.GuarantorReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Guarantor Database Access",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It constructs SQL strings dynamically using inner helper classes (Mappers) that define the schema and column selection. It uses PreparedStatement to bind parameters safely.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_guarantor",
      "m_code_value",
      "m_guarantor_funding_details",
      "m_portfolio_account_associations",
      "m_savings_account",
      "m_guarantor_transaction",
      "m_deposit_account_on_hold_transaction",
      "m_client",
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins involving multiple tables (guarantor, funding, transactions, accounts) with grouping and ordering. Uses scroll-sensitive ResultSets to handle one-to-many mapping logic manually in Java.",
    "transactionHandling": "Spring @Transactional(readOnly = true)",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via JdbcTemplate",
    "codeExample": "this.jdbcTemplate.query(con -> {\n    PreparedStatement preparedStatement = con.prepareStatement(finalSql, ResultSet.TYPE_SCROLL_SENSITIVE,\n            ResultSet.CONCUR_UPDATABLE);\n    preparedStatement.setInt(1, AccountAssociationType.GUARANTOR_ACCOUNT_ASSOCIATION.getValue());\n    preparedStatement.setLong(2, loanId);\n    return preparedStatement;\n}, rm);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.jobs.applyholidaystoloans",
    "mechanism": "JDBC",
    "name": "JobRepository",
    "description": "The class configures a Spring Batch Job which relies on a `JobRepository`. This repository persists the state of batch job executions, steps, and contexts to the database (typically tables like BATCH_JOB_INSTANCE, BATCH_JOB_EXECUTION) using JDBC or a similar datasource connection managed by the `PlatformTransactionManager`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_JOB_INSTANCE",
      "BATCH_JOB_EXECUTION",
      "BATCH_STEP_EXECUTION",
      "BATCH_JOB_EXECUTION_CONTEXT"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Batch internal CRUD operations for job metadata management",
    "transactionHandling": "Spring PlatformTransactionManager",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "new StepBuilder(JobName.APPLY_HOLIDAYS_TO_LOANS.name(), jobRepository)\n        .tasklet(applyHolidaysToLoansTasklet, transactionManager).build();"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.jobs.updateloanarrearsageing.LoanArrearsAgeingUpdateHandler",
    "mechanism": "JDBC",
    "name": "LoanArrearsAgeingUpdateHandler",
    "description": "The class uses Spring's JdbcTemplate and NamedParameterJdbcTemplate to perform direct SQL operations. It constructs complex SQL strings dynamically to handle aggregations and filtering logic for loan arrears calculations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_arrears_aging",
      "m_loan",
      "m_loan_repayment_schedule",
      "m_product_loan_recalculation_details",
      "m_loan_repayment_schedule_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Complex SQL generation involving joins, aggregations (SUM, MIN), and subqueries. Uses batch updates for performance.",
    "transactionHandling": "Manual/Implicit (relies on Spring context or caller transaction)",
    "protocol": "SQL",
    "connectionInfo": "DataSource injected via JdbcTemplate",
    "codeExample": "jdbcTemplate.update(\"delete from m_loan_arrears_aging where loan_id=?\", loanId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.loanschedule.service",
    "mechanism": "JDBC",
    "name": "LoanScheduleHistoryReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It reads from the loan repayment schedule history tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_repayment_schedule_history",
      "m_loan_repayment_schedule"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with aggregations (MAX) and filtering by ID.",
    "transactionHandling": "Spring @Transactional(readOnly = true)",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Integer max = this.jdbcTemplate.queryForObject(sql, new Object[] { loanId }, Integer.class);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.rescheduleloan.service.LoanRescheduleRequestReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It manually maps ResultSets to Java objects using inner RowMapper classes. It constructs SQL strings dynamically for filtering.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_reschedule_request",
      "m_code_value",
      "m_appuser",
      "m_loan",
      "m_client",
      "m_loan_reschedule_request_term_variations_mapping",
      "m_loan_term_variations"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with subqueries and dynamic criteria",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(sql, LOAN_RESCHEDULE_REQUEST_ROW_MAPPER, loanId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service",
    "mechanism": "JDBC",
    "name": "LoanChargePaidByReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute direct SQL queries. It performs a read operation involving joins across three tables to link paid charges to their definitions and the transaction.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_charge_paid_by",
      "m_loan_charge",
      "m_charge"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query with INNER JOINs to retrieve related entity data.",
    "transactionHandling": "None explicit (likely relies on auto-commit for reads or caller transaction).",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "final String sql = \"select \" + rm.loanChargePaidBySchema() + \" where lcpd.loan_transaction_id = ?\";\nreturn this.jdbcTemplate.query(sql, rm, transactionId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service",
    "mechanism": "JDBC",
    "name": "GLIMAccountInfoReadPlatformService",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL SELECT queries. It defines custom RowMappers (GLIMFieldsMapper, GLIMMapper, GLIMRepaymentMapper) to map the ResultSets to Java POJOs.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "glim_accounts",
      "m_loan",
      "m_client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses parameterized SQL queries constructed by concatenating schema strings from inner classes with WHERE clauses. It performs joins between glim_accounts, m_loan, and m_client tables.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final String sql = \"select \" + rm.schema() + \" and glim.id=?\";\nreturn this.jdbcTemplate.query(sql, rm, glimId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class primarily uses Spring's `JdbcTemplate` and `NamedParameterJdbcTemplate` to execute raw SQL queries for data retrieval. This is done to optimize performance for read operations, avoiding the overhead of JPA entity management for complex reporting views. It also uses `LoanRepositoryWrapper` (JPA) for some domain logic and entity retrieval where necessary.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_office",
      "m_client",
      "m_group",
      "m_product_loan",
      "m_loan_recalculation_details",
      "m_currency",
      "m_loan_arrears_aging",
      "m_fund",
      "m_staff",
      "m_appuser",
      "m_code_value",
      "m_product_loan_variable_installment_config",
      "m_loan_topup",
      "m_loan_repayment_schedule",
      "m_loan_transaction",
      "m_payment_detail",
      "m_payment_type",
      "m_account_transfer_transaction",
      "glim_parent_child_mapping",
      "m_loan_disbursement_detail",
      "m_loan_tranche_disbursement_charge",
      "m_loan_charge",
      "m_loan_term_variations",
      "m_loan_interest_recalculation_additional_details",
      "m_product_loan_floating_rates",
      "m_floating_rates",
      "m_floating_rates_periods",
      "m_loan_reschedule_request"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex SQL SELECT statements with multiple JOINs, subqueries, aggregations, and dynamic WHERE clauses based on search parameters.",
    "transactionHandling": "Spring @Transactional(readOnly = true) annotation at the class level.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final String sql = \"select \" + rm.loanSchema() + \" where l.account_no=?\";\nreturn this.jdbcTemplate.queryForObject(sql, rm, loanAccountNumber);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries against the database. It defines inner class RowMappers to map SQL result sets to Java objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client",
      "m_group",
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "SQL queries involving joins between entity tables (m_client, m_group) and the loan table (m_loan) with filtering by ID and status.",
    "transactionHandling": "None explicit (likely read-only or handled by caller)",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(clientSql, staffClientMapper, loanOfficerId, ClientStatus.ACTIVE.getValue());"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service.LoanAccrualWritePlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Fineract Database",
    "description": "The class uses a mix of Spring Data JPA (via `LoanRepository`, `LoanTransactionRepository`) for object retrieval and persistence, and raw Spring `JdbcTemplate` for specific updates to the `m_loan_charge_paid_by`, `m_loan_repayment_schedule`, and `m_loan` tables. This hybrid approach allows for domain-driven design where appropriate and optimized SQL execution for batch or specific field updates.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_loan_transaction",
      "m_loan_charge_paid_by",
      "m_loan_repayment_schedule"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code performs JPA save/flush operations for transactions and uses inline SQL UPDATE and INSERT statements via JdbcTemplate for updating loan schedules and charge associations.",
    "transactionHandling": "Spring @Transactional annotations are used on public methods to ensure atomicity of the database operations.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "String repaymentUpdateSql = \"UPDATE m_loan_repayment_schedule SET accrual_interest_derived=?, accrual_fee_charges_derived=?, \"\n        + \"accrual_penalty_charges_derived=? WHERE  id=?\";\nthis.jdbcTemplate.update(repaymentUpdateSql, totalAccInterest, totalAccFee, totalAccPenalty,\n        scheduleAccrualData.getRepaymentScheduleId());"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service.LoanArrearsAgingServiceImpl",
    "mechanism": "JDBC",
    "name": "LoanArrearsAgingDatabase",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries and updates. It interacts with the 'm_loan_arrears_aging' table to store calculated overdue metrics and reads from 'm_loan' and 'm_loan_repayment_schedule_history' to derive these metrics.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_arrears_aging",
      "m_loan",
      "m_loan_repayment_schedule_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code uses SELECT COUNT queries to check existence, SELECT queries with joins to fetch schedule history, and manually constructed INSERT/UPDATE/DELETE strings for data persistence.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via JdbcTemplate",
    "codeExample": "this.jdbcTemplate.update(\"DELETE FROM m_loan_arrears_aging WHERE loan_id=?\", loan.getId());"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service.LoanChargeReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate & LoanChargeRepository",
    "description": "The class primarily uses Spring's JdbcTemplate to execute raw SQL SELECT queries. It constructs SQL strings manually, often using inner class RowMappers to define the schema and map ResultSet rows to DTOs. It also uses a Spring Data JPA repository (LoanChargeRepository) for a single ID lookup method.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_charge",
      "m_organisation_currency",
      "m_loan_charge",
      "m_loan_tranche_disbursement_charge",
      "m_loan_disbursement_detail",
      "m_loan",
      "m_loan_installment_charge",
      "m_loan_repayment_schedule",
      "m_loan_charge_paid_by",
      "m_loan_transaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses raw SQL with complex joins (INNER JOIN, LEFT JOIN) across multiple tables. It includes subqueries for calculating accrued amounts and unrecognized income portions. Queries are dynamically constructed in some methods based on input parameters.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "final LoanChargeMapper rm = new LoanChargeMapper();\nfinal String sql = \"select \" + rm.schema() + \" where lc.id=? and lc.loan_id=?\";\nreturn this.jdbcTemplate.queryForObject(sql, rm, id, loanId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.productmix.service",
    "mechanism": "JDBC",
    "name": "ProductMixReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries against the database. It joins the `m_product_mix` and `m_product_loan` tables to retrieve product mix configurations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_product_mix",
      "m_product_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SQL SELECT with JOINs",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource",
    "codeExample": "final String sql = \"Select \" + extractor.schema() + \" where pm.product_id=?\";\nfinal Map<Long, ProductMixData> productMixData = this.jdbcTemplate.query(sql, extractor, productId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.service.LoanProductReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Fineract Core Database",
    "description": "The class relies heavily on Spring's JdbcTemplate to perform read operations. It constructs raw SQL strings, often using string concatenation for dynamic clauses (like security scoping). It maps the results using custom RowMapper implementations (LoanProductMapper, LoanProductLookupMapper, etc.). One method uses Spring Data JPA (LoanProductRepository).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_product_loan",
      "m_fund",
      "m_product_loan_recalculation_details",
      "m_product_loan_guarantee_details",
      "m_product_loan_configurable_attributes",
      "m_product_loan_floating_rates",
      "m_floating_rates",
      "m_product_loan_variable_installment_config",
      "m_delinquency_bucket",
      "m_currency",
      "m_loan_product_payment_allocation_rule",
      "m_product_loan_variations_borrower_cycle",
      "m_product_mix"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins across multiple configuration tables, dynamic WHERE clause generation for data scoping, UNION queries for product mix logic.",
    "transactionHandling": "None explicitly defined in this class (likely read-only or handled by caller)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource",
    "codeExample": "final String sql = \"select \" + rm.loanProductSchema() + \" where lp.id = ?\";\nreturn this.jdbcTemplate.queryForObject(sql, rm, loanProductId);"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.attendance.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries directly against the database. It manually maps the result set to Java objects using a RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_meeting",
      "m_client_attendance",
      "m_client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL with INNER JOINs across three tables",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource",
    "codeExample": "this.jdbcTemplate.query(sql, rm, new Object[] { meetingId });"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.service",
    "mechanism": "JDBC",
    "name": "MeetingReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL SELECT queries. It manually maps ResultSets to objects using a RowMapper implementation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_meeting",
      "m_calendar_instance",
      "m_calendar"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD SELECT queries with inner joins and filtering by foreign keys.",
    "transactionHandling": "None (Read-only operations, likely relying on auto-commit or higher-level transaction management)",
    "protocol": "JDBC",
    "connectionInfo": "Injected via JdbcTemplate",
    "codeExample": "this.jdbcTemplate.queryForObject(sql, rm, new Object[] { meetingId, entityId, entityTypeId });"
  },
  {
    "path": "org.apache.fineract.portfolio.note.service",
    "mechanism": "JDBC",
    "name": "NoteReadPlatformServiceImpl",
    "description": "The class uses Spring's `JdbcTemplate` to execute raw SQL queries. It manually maps `ResultSet` data to Java objects using a custom `RowMapper`. It constructs dynamic SQL strings to handle different filtering criteria based on the entity type (Client, Loan, etc.).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_note",
      "m_appuser"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD SELECT queries with LEFT JOINs to user tables.",
    "transactionHandling": "none",
    "protocol": "SQL",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return this.jdbcTemplate.queryForObject(sql, rm, paramList.toArray());"
  },
  {
    "path": "org.apache.fineract.portfolio.rate.service",
    "mechanism": "JDBC",
    "name": "RateReadServiceImpl",
    "description": "The class interacts with the database using Spring's JdbcTemplate. It constructs SQL SELECT statements by concatenating schema strings defined in the inner RateMapper class. It maps the ResultSet to RateData POJOs.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_rate",
      "m_loan_rate",
      "m_product_loan_rate"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries, some involving INNER JOINs to link rates with loans or products.",
    "transactionHandling": "None explicit (likely read-only auto-commit)",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via Spring",
    "codeExample": "this.jdbcTemplate.query(sql, rm, new Object[] { loanId });"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.jobs.generateadhocclientschhedule",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute dynamic SQL queries. It performs data insertion based on ad-hoc definitions and updates metadata in the 'm_adhoc' table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_adhoc",
      "dynamic_tables_defined_in_adhoc_config"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Dynamic SQL construction (INLINE SQL) for inserts, and standard parameterized updates for metadata.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "configured in Spring Context",
    "codeExample": "jdbcTemplate.update(\"UPDATE m_adhoc SET last_run=? WHERE id=?\", new Date(), adhoc.getId());"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.jobs.generateadhocclientschhedule.GenerateAdhocClientScheduleConfig",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The configuration class injects a Spring JdbcTemplate and passes it to the GenerateAdhocClientScheduleTasklet. While this configuration file does not execute queries itself, it explicitly wires the JDBC access component into the job's execution logic.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The actual queries are encapsulated within the Tasklet class, but the injection of JdbcTemplate suggests raw SQL or JDBC-based operations.",
    "transactionHandling": "Transactions are managed by the Spring Batch Step using the injected PlatformTransactionManager.",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "return new GenerateAdhocClientScheduleTasklet(adHocReadPlatformService, jdbcTemplate);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.jobs.generaterdschedule",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's `JdbcTemplate` to execute raw SQL INSERT statements constructed via string concatenation. It writes directly to the `m_mandatory_savings_schedule` table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_mandatory_savings_schedule"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Batch INSERT operations using manually constructed inline SQL strings.",
    "transactionHandling": "Manual batch execution within the tasklet context",
    "protocol": "JDBC",
    "connectionInfo": "Derived from RoutingDataSourceServiceFactory",
    "codeExample": "jdbcTemplate.update(insertSql + sb);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.jobs.postinterestforsavings.PostInterestForSavingConfig",
    "mechanism": "JDBC",
    "name": "JobRepository and Savings Data Access",
    "description": "The class interacts with the database primarily through the Spring Batch 'JobRepository' for managing job state and metadata. Additionally, it injects 'JdbcTemplate' and 'SavingsAccountRepositoryWrapper', indicating that the underlying tasklet or the configuration context interacts with savings account tables, although these fields are not explicitly used in the configuration methods shown.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_JOB_INSTANCE",
      "BATCH_JOB_EXECUTION",
      "m_savings_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Batch metadata management and Savings Account CRUD operations",
    "transactionHandling": "Spring PlatformTransactionManager used in Step configuration",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Autowired\nprivate JobRepository jobRepository;\n@Autowired\nprivate JdbcTemplate jdbcTemplate;"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It constructs SQL strings dynamically using StringBuilder and maps the results to Java objects using custom RowMapper implementations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_product",
      "m_deposit_product_term_and_preclosure",
      "m_currency",
      "m_tax_group",
      "m_deposit_product_recurring_detail"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins involving multiple tables (product, terms, currency, tax groups) to assemble a complete view of a deposit product.",
    "transactionHandling": "NONE",
    "protocol": "SQL",
    "connectionInfo": "configured in Spring DataSource",
    "codeExample": "this.jdbcTemplate.query(sqlBuilder.toString(), depositProductMapper, depositAccountType.getValue());"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service",
    "mechanism": "JDBC",
    "name": "DepositAccountOnHoldTransactionReadPlatformServiceImpl",
    "description": "The class uses Spring's `JdbcTemplate` to execute raw SQL queries. It manually constructs SQL strings involving multiple joins to retrieve transaction details and maps the results to Java objects using a custom `RowMapper`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_deposit_account_on_hold_transaction",
      "m_client",
      "m_guarantor_transaction",
      "m_guarantor_funding_details",
      "m_portfolio_account_associations",
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins across multiple tables (savings, transactions, clients, guarantors, loans) with dynamic filtering and pagination.",
    "transactionHandling": "None explicit (Read-only operations likely relying on auto-commit or higher-level transaction management).",
    "protocol": "SQL",
    "connectionInfo": "n/a",
    "codeExample": "sqlBuilder.append(\"select \" + sqlGenerator.calcFoundRows() + \" \");\nsqlBuilder.append(this.mapper.schema());\nsqlBuilder.append(\" where tr.savings_account_id = ? \");\nparamObj.add(savingsId);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It manually constructs SQL strings, including dynamic WHERE clauses for security scoping, and maps the results to Java objects using custom RowMapper implementations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_product",
      "m_currency",
      "m_tax_group"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL with dynamic WHERE clauses and joins",
    "transactionHandling": "None explicit in this file (likely read-only or handled by container)",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(sql, this.savingsProductRowMapper, new Object[] { DepositAccountType.SAVINGS_DEPOSIT.getValue() });"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It manually maps ResultSets to domain objects using inner classes that implement RowMapper and ResultSetExtractor. It handles complex joins to retrieve hierarchical data (Chart -> Slabs -> Incentives).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account_interest_rate_chart",
      "m_savings_account_interest_rate_slab",
      "m_savings_interest_incentives",
      "m_code_value",
      "m_currency",
      "m_savings_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins involving multiple tables (charts, slabs, incentives, codes, currency) to reconstruct hierarchical object graphs. Uses conditional ordering in SQL.",
    "transactionHandling": "None explicit (Read-only service)",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(sql.toString(), this.chartExtractor, chartId);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.DepositAccountReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It constructs SQL strings dynamically using StringBuilder and maps the results to Java objects using custom RowMapper implementations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_deposit_account_term_and_preclosure",
      "m_savings_product",
      "m_currency",
      "m_client",
      "m_group",
      "m_staff",
      "m_appuser",
      "m_tax_group",
      "m_deposit_account_recurring_detail",
      "m_savings_account_transaction",
      "m_account_transfer_transaction",
      "m_payment_detail",
      "m_payment_type",
      "m_deposit_product_term_and_preclosure",
      "m_deposit_product_recurring_detail",
      "m_mandatory_savings_schedule",
      "m_calendar_instance",
      "m_calendar",
      "m_savings_account_charge",
      "m_charge",
      "m_portfolio_account_associations"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins across multiple tables, dynamic SQL generation based on parameters, pagination support, aggregation queries.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "final StringBuilder sqlBuilder = new StringBuilder(400);\nsqlBuilder.append(\"select \");\nsqlBuilder.append(depositAccountMapper.schema());\nsqlBuilder.append(\" where sa.deposit_type_enum = ? \");\nreturn jdbcTemplate.query(sqlBuilder.toString(), depositAccountMapper, new Object[] { depositAccountType.getValue() });"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.GSIMReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "GSIM Database Access",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It defines custom RowMappers (GSIMFieldsMapper, GSIMMapper, SavingsAccountSummaryDataMapper) to map ResultSets to domain objects. It constructs SQL strings dynamically in some cases and uses ColumnValidator to prevent SQL injection.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "gsim_accounts",
      "m_savings_account",
      "m_savings_product",
      "m_currency",
      "m_appuser",
      "m_client",
      "m_savings_account_transaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with subqueries, specifically in the SavingsAccountSummaryDataMapper which joins multiple tables (products, currency, users, clients) and includes a subquery for transaction dates.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.jdbcTemplate.query(sql, rm, new Object[] { gsimId });"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.SavingsAccountChargeReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "SavingsAccountChargeReadPlatformServiceImpl",
    "description": "The class interacts with the database using Spring's JdbcTemplate. It constructs raw SQL queries to read data from the 'm_savings_account_charge' table and joins it with 'm_charge', 'm_organisation_currency', and 'm_savings_account' tables. It uses custom RowMapper implementations to map the ResultSet to domain objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_charge",
      "m_organisation_currency",
      "m_savings_account_charge",
      "m_savings_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with multiple tables, dynamic filtering based on status, and date-based criteria.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "final String sql = \"select \" + rm.schema() + \" where sc.id=? and sc.savings_account_id=?\";\nreturn this.jdbcTemplate.queryForObject(sql, rm, new Object[] { id, savingsAccountId });"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.SavingsAccountReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "SavingsAccount Database Access",
    "description": "The class primarily uses Spring's `JdbcTemplate` to perform read-only operations against the database. It constructs SQL queries dynamically using `StringBuilder` to handle optional search parameters and joins multiple tables (account, product, client, group, transactions, etc.) to assemble rich DTOs. It uses custom `RowMapper` and `ResultSetExtractor` implementations to map the relational data to object structures. There is minor usage of `SavingsAccountRepositoryWrapper` (Spring Data) for external ID lookup.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_savings_product",
      "m_currency",
      "m_client",
      "m_group",
      "m_staff",
      "m_appuser",
      "m_savings_account_transaction",
      "m_payment_detail",
      "m_payment_type",
      "m_tax_group",
      "m_tax_component",
      "acc_product_mapping",
      "m_account_transfer_transaction",
      "m_note",
      "m_savings_account_charge",
      "m_savings_account_charge_paid_by",
      "m_savings_account_transaction_tax_details"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with subqueries, dynamic SQL generation based on search criteria, keyset pagination for batch jobs.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "final StringBuilder sqlBuilder = new StringBuilder(\"select \" + this.savingAccountMapper.schema());\nsqlBuilder.append(\" where sa.client_id = ? and sa.status_enum = 300 \");\nfinal Object[] queryParameters = new Object[] { clientId };\nreturn this.jdbcTemplate.query(sqlBuilder.toString(), this.savingAccountMapper, queryParameters);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.SavingsSchedularInterestPoster",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's `JdbcTemplate` to perform batch SQL operations for performance efficiency. It constructs raw SQL `INSERT` and `UPDATE` statements for savings transactions, account summaries, and general ledger journal entries, executing them in batches rather than individually.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_savings_account_transaction",
      "acc_gl_journal_entry"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Batch operations with inline SQL for inserts and updates",
    "transactionHandling": "Spring @Transactional with Isolation.READ_UNCOMMITTED",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.jdbcTemplate.batchUpdate(queryForJGLUpdate, paramsForGLInsertion);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.search.SavingsAccountTransactionsSearchServiceImpl",
    "mechanism": "JDBC",
    "name": "SavingsAccountTransactionsSearchServiceImpl",
    "description": "The class interacts with the database using Spring's `JdbcTemplate`. It dynamically constructs SQL strings (SELECT, FROM, WHERE, ORDER BY) based on input filters and executes them. It uses `DatabaseSpecificSQLGenerator` to handle SQL dialect differences.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account_transaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation with complex filtering and optional joins to datatables.",
    "transactionHandling": "Spring @Transactional(readOnly = true)",
    "protocol": "JDBC",
    "connectionInfo": "DataSource injected via JdbcTemplate",
    "codeExample": "List<SavingsAccountTransactionData> results = this.jdbcTemplate.query(query.toString(), tm, args);"
  },
  {
    "path": "org.apache.fineract.portfolio.search.service",
    "mechanism": "JDBC",
    "name": "SearchUtil",
    "description": "This class acts as a utility for JDBC-based database interactions. It does not execute queries itself but prepares SQL fragments (WHERE clauses) and processes JDBC `SqlRowSet` results. It bridges the gap between API search parameters and raw SQL execution, handling dialect differences via `DatabaseSpecificSQLGenerator`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation for filtering (WHERE clauses)",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "public static void buildCondition(...) {\n    where.append(operator.formatPlaceholder(sqlGenerator, definition, paramCount, alias));\n    if (values != null) {\n        params.addAll(values);\n    }\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.search.service.SearchReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "NamedParameterJdbcTemplate",
    "description": "The class uses Spring's NamedParameterJdbcTemplate to execute raw SQL queries. It manually constructs SQL strings involving multiple joins and unions to aggregate data from various tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client",
      "m_office",
      "m_loan",
      "m_group",
      "m_product_loan",
      "m_savings_account",
      "m_savings_product",
      "m_share_account",
      "m_share_product",
      "m_client_identifier"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex dynamic SQL generation using StringBuilder, UNIONs across multiple entity tables, and dynamic WHERE clauses based on filter criteria.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "return namedParameterJdbcTemplate.query(searchSchema(searchConditions), params, rm);"
  },
  {
    "path": "org.apache.fineract.portfolio.search.starter",
    "mechanism": "JDBC",
    "name": "SearchReadPlatformService Configuration",
    "description": "This configuration class injects the 'NamedParameterJdbcTemplate' into the 'SearchReadPlatformService', enabling the service to perform database operations. While this file does not execute SQL directly, it is responsible for wiring the database access component.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Configured via NamedParameterJdbcTemplate",
    "codeExample": "public SearchReadPlatformService searchReadPlatformService(NamedParameterJdbcTemplate namedParameterJdbcTemplate, ...) { return new SearchReadPlatformServiceImpl(namedParameterJdbcTemplate, ...); }"
  },
  {
    "path": "org.apache.fineract.portfolio.self.account.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries against the application database. It performs complex read operations involving joins across multiple tables and a UNION of two select statements.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_appuser",
      "m_selfservice_user_client_mapping",
      "m_client",
      "m_office",
      "m_savings_account",
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex SQL query using INNER JOINs across 5 tables and a UNION operator to combine results from savings and loan tables.",
    "transactionHandling": "None explicit (likely relies on default auto-commit for read operations or higher-level transaction management).",
    "protocol": "SQL",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "this.jdbcTemplate.query(sql.toString(), mapper, new Object[] { user.getId(), user.getId() });"
  },
  {
    "path": "org.apache.fineract.portfolio.self.account.service.SelfBeneficiariesTPTReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "SelfBeneficiariesTPTReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries. It constructs complex SQL strings involving joins and unions within inner mapper classes and executes them to retrieve data mapped to Java objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_selfservice_beneficiaries_tpt",
      "m_office",
      "m_client",
      "m_savings_account",
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses parameterized SQL queries constructed via StringBuilder. It features complex patterns including INNER JOINs across multiple tables (office, client, savings/loan) and UNION ALL to combine results for different account types (savings vs loans).",
    "transactionHandling": "No explicit transaction handling is observed in this read-only service; it likely relies on the default auto-commit behavior or a higher-level transaction context.",
    "protocol": "SQL",
    "connectionInfo": "n/a",
    "codeExample": "this.jdbcTemplate.query(this.mapper.schema(), this.mapper, new Object[] { user.getId(), user.getId() });"
  },
  {
    "path": "org.apache.fineract.portfolio.self.client.service.AppuserClientMapperReadServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database to verify user-client mappings.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_selfservice_user_client_mapping"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT count query with a case statement to return a boolean.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "this.jdbcTemplate.queryForObject(\n        \"select case when (count(*) > 0) then true else false end \"\n                + \" from m_selfservice_user_client_mapping where client_id = ? and appuser_id = ?\",\n        Boolean.class, clientId, appUserId);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.loanaccount.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries directly against the database to check for data existence.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_selfservice_user_client_mapping",
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SQL SELECT with a LEFT JOIN and a CASE statement to return a boolean based on row count.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "this.jdbcTemplate.queryForObject(\"select case when (count(*) > 0) then true else false end ...\", Boolean.class, loanId, appUserId);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.loanaccount.starter.SelfLoanAccountConfiguration",
    "mechanism": "JDBC",
    "name": "AppuserLoansMapperReadService",
    "description": "The class configures a service that interacts with the database using Spring's JdbcTemplate. While this specific file does not contain SQL queries, it injects the JdbcTemplate into the service implementation (AppuserLoansMapperReadServiceImpl) which performs the actual database operations.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "public AppuserLoansMapperReadService appuserLoansMapperReadService(JdbcTemplate jdbcTemplate) {\n    return new AppuserLoansMapperReadServiceImpl(jdbcTemplate);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.self.pockets.service",
    "mechanism": "JDBC",
    "name": "PocketAccountMappingReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate for direct SQL execution to validate mappings and Repository wrappers (likely wrapping JPA/Spring Data) for retrieving domain entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_pocket_accounts_mapping"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT count query and repository finders.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "final String sql = \"select count(id) from m_pocket_accounts_mapping mapping where pocket_id = ? and account_id = ? and account_type = ?\";\nint count = this.jdbcTemplate.queryForObject(sql, Integer.class, pocketId, accountId, accountType);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.registration.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT COUNT query with dynamic filtering criteria.",
    "transactionHandling": "unknown",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring DataSource",
    "codeExample": "String sql = \"select count(*) from m_client where account_no = ? ...\";\nint count = this.jdbcTemplate.queryForObject(sql, Integer.class, params);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.savings.service",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries directly against the database to check for the existence of a relationship between users and savings accounts.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_selfservice_user_client_mapping",
      "m_savings_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL query using joins and aggregation (count) to return a boolean.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.jdbcTemplate.queryForObject(\"select case when (count(*) > 0) then true else false end ...\", Boolean.class, savingsId, appUserId);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.savings.starter.SelfSavingsConfiguration",
    "mechanism": "JDBC",
    "name": "AppuserSavingsMapperReadService",
    "description": "The configuration class injects a Spring `JdbcTemplate` and passes it to the `AppuserSavingsMapperReadServiceImpl`. This indicates that the underlying service performs database operations using the JDBC template abstraction, likely executing raw SQL queries to read data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The configuration itself does not contain queries, but it wires up a service that likely performs SQL SELECT operations via JdbcTemplate.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "configured via Spring Boot DataSource (injected)",
    "codeExample": "public AppuserSavingsMapperReadService appuserSavingsMapperReadService(JdbcTemplate jdbcTemplate) {\n    return new AppuserSavingsMapperReadServiceImpl(jdbcTemplate);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.self.shareaccounts.service",
    "mechanism": "JDBC",
    "name": "AppUserShareAccountsMapperReadPlatformServiceImpl",
    "description": "Uses Spring JdbcTemplate to execute a raw SQL SELECT query to verify data existence.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_selfservice_user_client_mapping",
      "m_share_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL query with a LEFT JOIN and WHERE clause to count records.",
    "transactionHandling": "None explicit, likely relies on caller or default auto-commit for reads.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.jdbcTemplate.queryForObject(\"select case when (count(*) > 0) then true else false end ...\", Boolean.class, accountId, appUserId);"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.service",
    "mechanism": "JDBC",
    "name": "ShareAccountChargeReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries. It manually constructs SQL strings involving joins between charge, currency, and share account charge tables and maps the results to Data Transfer Objects (DTOs).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_charge",
      "m_organisation_currency",
      "m_share_account_charge"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with JOINs and dynamic WHERE clauses based on status.",
    "transactionHandling": "None (Read-only operations, likely relying on default auto-commit or higher-level transaction scope)",
    "protocol": "SQL",
    "connectionInfo": "DataSource injected via JdbcTemplate",
    "codeExample": "this.jdbcTemplate.query(sqlBuilder.toString(), rm, new Object[] { accountId });"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.service",
    "mechanism": "JDBC",
    "name": "PurchasedSharesReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL queries against the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_share_account_transactions"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT query with WHERE clause filtering by account_id and is_active status.",
    "transactionHandling": "None (Read-only operation, relies on default auto-commit or surrounding transaction context)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring JdbcTemplate",
    "codeExample": "this.jdbcTemplate.query(sql, mapper, new Object[] { accountId });"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.service.ShareAccountDividendReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "Share Account Dividend Database Access",
    "description": "The class interacts directly with the database using Spring's JdbcTemplate. It constructs SQL queries manually to join multiple tables related to share accounts and dividends. It uses a custom RowMapper to map the result set to domain objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_share_account_dividend_details",
      "m_share_product_dividend_pay_out",
      "m_share_account",
      "m_client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins with dynamic filtering and pagination logic constructed via StringBuilder.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "sb.append(\"select \");\n sb.append(\" sadd.id as id, \");\n sb.append(\" sa.savings_account_id as savingsAccountId \");\n sb.append(\" from m_share_account_dividend_details sadd\");\n // ... joins ...\n return this.jdbcTemplate.queryForList(sb.toString(), ...);"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.service.ShareAccountReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "ShareAccountReadPlatformServiceImpl",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL SELECT queries against the database. It constructs SQL strings manually (often using StringBuilder) and maps the ResultSets to Java objects using inner class RowMappers. This approach is used for read-only operations to optimize performance and avoid the overhead of JPA entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_share_account",
      "m_share_product",
      "m_currency",
      "m_client",
      "m_appuser",
      "m_savings_account",
      "m_share_account_transactions",
      "m_share_account_dividend_details",
      "m_share_product_dividend_pay_out"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Complex joins across multiple tables (account, product, client, currency, users) with dynamic filtering and pagination.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "String query = \"select \" + mapper.schema() + \"where sa.id=?\";\nShareAccountData data = (ShareAccountData) this.jdbcTemplate.queryForObject(query, mapper, id);"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.service",
    "mechanism": "JDBC",
    "name": "ShareProductDividendReadPlatformService",
    "description": "The class uses Spring's JdbcTemplate to execute SQL queries directly against the database. It constructs SELECT statements with joins between 'm_share_product_dividend_pay_out' and 'm_share_product' tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_share_product_dividend_pay_out",
      "m_share_product"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL construction with inner joins and conditional filtering based on input parameters.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final StringBuilder sqlBuilder = new StringBuilder(200);\nsqlBuilder.append(\"select \" + sqlGenerator.calcFoundRows() + \" \");\nsqlBuilder.append(shareProductDividendMapper.schema());\nsqlBuilder.append(\" where sp.id = ? \");\n// ...\nreturn this.paginationHelper.fetchPage(this.jdbcTemplate, sqlBuilder.toString(), paramsObj, shareProductDividendMapper);"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.service.ShareProductReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "shareReadPlatformService",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries against the database. It manually maps ResultSets to Java objects using custom RowMapper implementations. It constructs SQL strings dynamically for pagination and filtering.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_share_product",
      "m_share_product_market_price",
      "m_currency",
      "m_appuser"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD operations using SELECT statements with LEFT JOINs. Pagination is handled via LIMIT/OFFSET.",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final String sql = \"select \" + mapper.schema() + \" where shareproduct.id = ?\";\nShareProductData data = (ShareProductData) this.jdbcTemplate.queryForObject(sql, mapper, new Object[] { productId });"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.service.TaxReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "JdbcTemplate",
    "description": "The class uses Spring's JdbcTemplate to execute raw SQL queries. It defines SQL schemas within private static inner classes (RowMappers) using StringBuilder. It performs READ operations on tax-related tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_tax_component",
      "acc_gl_account",
      "m_tax_component_history",
      "m_tax_group",
      "m_tax_group_mappings"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses raw SQL SELECT statements constructed via StringBuilders. It performs complex joins (LEFT JOIN, INNER JOIN) to link tax components with GL accounts and history, and tax groups with their mappings. The RowMappers contain logic to handle one-to-many relationships by iterating the ResultSet.",
    "transactionHandling": "NONE",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "String sql = \"select \" + TAX_COMPONENT_MAPPER.getSchema();\nreturn this.jdbcTemplate.query(sql, TAX_COMPONENT_MAPPER);"
  },
  {
    "path": "org.apache.fineract.spm.service.ScorecardReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "ScorecardReadPlatformServiceImpl",
    "description": "The service uses Spring's JdbcTemplate to execute raw SQL SELECT queries. It manually maps ResultSets to objects using inner RowMapper classes.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_survey_scorecards",
      "m_surveys",
      "m_appuser"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard SELECT queries with LEFT JOINs and GROUP BY clauses.",
    "transactionHandling": "None explicit (likely read-only or auto-commit)",
    "protocol": "JDBC",
    "connectionInfo": "Injected via JdbcTemplate",
    "codeExample": "this.jdbcTemplate.query(sql, scm, new Object[] { surveyId });"
  },
  {
    "path": "org.apache.fineract.useradministration.service",
    "mechanism": "JDBC",
    "name": "RoleReadPlatformServiceImpl",
    "description": "The class interacts directly with the database using Spring's JdbcTemplate. It constructs raw SQL strings for SELECT operations and maps the results to Java objects using a custom RowMapper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_role",
      "m_appuser_role"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Inline SQL SELECT statements with simple WHERE clauses and one INNER JOIN.",
    "transactionHandling": "None explicitly defined in this class (likely read-only auto-commit or handled by caller).",
    "protocol": "SQL",
    "connectionInfo": "Managed by Spring JdbcTemplate (DataSource injected)",
    "codeExample": "this.jdbcTemplate.query(sql, this.roleRowMapper);"
  },
  {
    "path": "org.apache.fineract.useradministration.service",
    "mechanism": "JDBC",
    "name": "PermissionReadPlatformServiceImpl",
    "description": "The class uses Spring's `JdbcTemplate` to execute raw SQL SELECT queries. It manually maps the results to objects using a custom `RowMapper`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_permission",
      "m_role_permission"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard SQL SELECT statements with filtering (WHERE clauses using LIKE and inequality) and LEFT JOINs. Uses COALESCE for sorting.",
    "transactionHandling": "None explicit (likely relies on default read-only transaction or auto-commit context)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "return this.jdbcTemplate.query(sql, mapper, new Object[] {});"
  },
  {
    "path": "org.apache.fineract.useradministration.service",
    "mechanism": "JDBC",
    "name": "AppUserReadPlatformService Database Access",
    "description": "The class uses a hybrid approach. It primarily uses Spring JDBC (JdbcTemplate) for read-heavy operations (lists, lookups, existence checks) by executing raw SQL queries against the 'm_appuser' and 'm_office' tables. It also uses Spring Data JPA (AppUserRepository) to retrieve full domain entities for detailed single-user views.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_appuser",
      "m_office",
      "m_role",
      "m_staff",
      "m_client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code uses raw SQL SELECT statements with joins for list retrieval and JPA findById for single entity retrieval. It includes hierarchy-based filtering using 'like' clauses.",
    "transactionHandling": "No explicit transaction annotations are present on this class, implying read-only operations or reliance on the service layer default transaction configuration.",
    "protocol": "JDBC / JPA",
    "connectionInfo": "Managed by Spring DataSource (injected via JdbcTemplate)",
    "codeExample": "final String sql = \"select \" + mapper.schema();\nreturn this.jdbcTemplate.query(sql, mapper, new Object[] { hierarchySearchString });"
  },
  {
    "path": "org.apache.fineract.useradministration.service.PasswordValidationPolicyReadPlatformServiceImpl",
    "mechanism": "JDBC",
    "name": "PasswordValidationPolicyReadPlatformServiceImpl",
    "description": "The class interacts directly with the database using Spring's JdbcTemplate to execute SQL queries. It reads from the 'm_password_validation_policy' table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_password_validation_policy"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple SELECT queries with basic filtering and ordering.",
    "transactionHandling": "None (Read-only operations, likely relies on auto-commit or upper-layer transaction management)",
    "protocol": "JDBC",
    "connectionInfo": "Managed by Spring JdbcTemplate (DataSource injected)",
    "codeExample": "this.jdbcTemplate.query(sql, this.passwordValidationPolicyMapper);"
  },
  {
    "path": "fineract-provider/dependencies.gradle",
    "mechanism": "JPA",
    "name": "EclipseLink JPA",
    "description": "The build file defines the database technology stack by importing `spring-boot-starter-data-jpa` and explicitly swapping the default Hibernate provider for EclipseLink (`org.eclipse.persistence.jpa`). It also includes the `liquibase-core` library for database schema migrations and the `mysql-socket-factory-connector-j-8` for connecting to MySQL databases (specifically Google Cloud SQL).",
    "databaseName": "n/a",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional (inferred from spring-boot-starter-data-jpa dependency)",
    "protocol": "MySQL (Google Cloud SQL)",
    "connectionInfo": "n/a",
    "codeExample": "implementation ('org.springframework.boot:spring-boot-starter-data-jpa') {\n    exclude group: 'org.hibernate'\n}\nimplementation('org.eclipse.persistence:org.eclipse.persistence.jpa') {\n    exclude group: 'org.eclipse.persistence', module: 'jakarta.persistence'\n}\n// ...\nimplementation 'com.google.cloud.sql:mysql-socket-factory-connector-j-8'"
  },
  {
    "path": "fineract-core/dependencies.gradle",
    "mechanism": "JPA",
    "name": "EclipseLink JPA via Spring Data",
    "description": "The build file defines the persistence stack by importing 'spring-boot-starter-data-jpa' while explicitly excluding the default 'org.hibernate' group. It simultaneously adds 'org.eclipse.persistence.jpa', thereby configuring the application to use the Java Persistence API (JPA) with EclipseLink as the underlying ORM provider instead of Hibernate.",
    "databaseName": "not identifiable from code",
    "tablesAccessed": [
      "not identifiable from code"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The dependencies suggest the use of JPA Entities and Repositories (Spring Data), likely involving JPQL or Criteria API, but specific patterns are not visible in this build file.",
    "transactionHandling": "Spring @Transactional (implied by the inclusion of spring-boot-starter-data-jpa)",
    "protocol": "not identifiable from code",
    "connectionInfo": "not identifiable from code",
    "codeExample": "implementation ('org.springframework.boot:spring-boot-starter-data-jpa') {\n    exclude group: 'org.hibernate'\n}\nimplementation('org.eclipse.persistence:org.eclipse.persistence.jpa') {\n    exclude group: 'org.eclipse.persistence', module: 'jakarta.persistence'\n}"
  },
  {
    "path": "fineract-investor/dependencies.gradle",
    "mechanism": "JPA",
    "name": "Spring Data JPA with EclipseLink",
    "description": "The build file configures the project's database integration layer by importing the Spring Boot Data JPA starter. Crucially, it explicitly excludes the default Hibernate provider and includes the EclipseLink JPA library instead, establishing EclipseLink as the ORM provider for the application.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM capabilities provided via libraries (no actual queries in build file)",
    "transactionHandling": "Spring @Transactional (implied by dependencies)",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "implementation ('org.springframework.boot:spring-boot-starter-data-jpa') {\n    exclude group: 'org.hibernate'\n}\nimplementation('org.eclipse.persistence:org.eclipse.persistence.jpa')"
  },
  {
    "path": "org.apache.fineract.accounting.closure.domain",
    "mechanism": "JPA",
    "name": "GLClosure",
    "description": "The class is a JPA entity annotated with @Entity, mapping to the 'acc_gl_closure' table. It uses @ManyToOne for the relationship with the Office entity and defines a unique constraint on office_id and closing_date.",
    "databaseName": "acc_gl_closure",
    "tablesAccessed": [
      "acc_gl_closure"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity mapping",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JPA / JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"acc_gl_closure\", uniqueConstraints = {\n        @UniqueConstraint(columnNames = { \"office_id\", \"closing_date\" }, name = \"office_id_closing_date\") })\npublic class GLClosure extends AbstractAuditableCustom {"
  },
  {
    "path": "org.apache.fineract.accounting.financialactivityaccount.domain.FinancialActivityAccount",
    "mechanism": "JPA",
    "name": "FinancialActivityAccount",
    "description": "The class is a JPA entity that maps to a relational database table. It defines the schema for storing financial activity account mappings, including a foreign key relationship to the GL Account table.",
    "databaseName": "acc_gl_financial_activity_account",
    "tablesAccessed": [
      "acc_gl_financial_activity_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"acc_gl_financial_activity_account\")\npublic class FinancialActivityAccount extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.domain",
    "mechanism": "JPA",
    "name": "TrialBalance",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It defines column mappings for financial data.",
    "databaseName": "m_trial_balance",
    "tablesAccessed": [
      "m_trial_balance"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping for standard CRUD operations",
    "transactionHandling": "JPA EntityTransaction (implicit via container or framework)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_trial_balance\")\npublic class TrialBalance extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.domain.GLAccount",
    "mechanism": "JPA",
    "name": "GLAccount Entity",
    "description": "The class is a JPA Entity annotated with @Entity and @Table. It maps to the 'acc_gl_account' table. It defines relationships using @ManyToOne for the parent account and tag, and @OneToMany for child accounts. It uses @Column annotations to define constraints like nullability and length.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_gl_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with lazy loading for parent/child relationships.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"acc_gl_account\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"gl_code\" }, name = \"acc_gl_code\") })\npublic class GLAccount extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.accounting.journalentry.domain",
    "mechanism": "JPA",
    "name": "JournalEntry",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping directly to the relational database table 'acc_gl_journal_entry'. It uses @ManyToOne annotations to define foreign key relationships with Office, PaymentDetail, and GLAccount tables.",
    "databaseName": "acc_gl_journal_entry",
    "tablesAccessed": [
      "acc_gl_journal_entry"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"acc_gl_journal_entry\")\npublic class JournalEntry extends AbstractAuditableWithUTCDateTimeCustom {"
  },
  {
    "path": "org.apache.fineract.accounting.producttoaccountmapping.domain.ProductToGLAccountMapping",
    "mechanism": "JPA",
    "name": "ProductToGLAccountMapping",
    "description": "The class is a JPA Entity mapped to the 'acc_product_mapping' table. It uses Jakarta Persistence annotations to define the table structure, columns, and foreign key relationships to other tables (GL Accounts, Charges, Payment Types).",
    "databaseName": "acc_product_mapping",
    "tablesAccessed": [
      "acc_product_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"acc_product_mapping\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"product_id\", \"product_type\",\n        \"financial_account_type\", \"payment_type\" }, name = \"financial_action\") })\npublic class ProductToGLAccountMapping extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.accounting.producttoaccountmapping.service",
    "mechanism": "JPA",
    "name": "ProductToGLAccountMappingHelpers",
    "description": "The service uses Spring's `@Transactional` annotation to manage transaction boundaries. It delegates actual database persistence operations to helper classes (`LoanProductToGLAccountMappingHelper`, etc.), which likely use JPA or Spring Data Repositories to save mapping entities to the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_product_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "CRUD operations via helper classes",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.loanProductToGLAccountMappingHelper.saveLoanToAssetOrLiabilityAccountMapping(element, LoanProductAccountingParams.FUND_SOURCE.getValue(), loanProductId, CashAccountsForLoan.FUND_SOURCE.getValue());"
  },
  {
    "path": "org.apache.fineract.accounting.provisioning.domain",
    "mechanism": "JPA",
    "name": "ProvisioningEntry Entity",
    "description": "The class is a JPA entity that maps to the 'm_provisioning_history' table. It defines columns for journal entry status and audit dates, and manages relationships to other entities.",
    "databaseName": "m_provisioning_history",
    "tablesAccessed": [
      "m_provisioning_history",
      "m_loanproduct_provisioning_entry",
      "m_appuser"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_provisioning_history\")\npublic class ProvisioningEntry extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.accounting.provisioning.domain.LoanProductProvisioningEntry",
    "mechanism": "JPA",
    "name": "LoanProductProvisioningEntry",
    "description": "The class is a JPA Entity that maps directly to the 'm_loanproduct_provisioning_entry' database table. It defines Many-to-One relationships with other entities such as ProvisioningEntry, Office, LoanProduct, ProvisioningCategory, and GLAccount.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loanproduct_provisioning_entry"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loanproduct_provisioning_entry\")\npublic class LoanProductProvisioningEntry extends AbstractPersistableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"history_id\", referencedColumnName = \"id\", nullable = false)\n    private ProvisioningEntry entry;"
  },
  {
    "path": "org.apache.fineract.accounting.rule.domain",
    "mechanism": "JPA",
    "name": "AccountingTagRule",
    "description": "The class is a JPA entity mapped to the 'acc_rule_tags' table using Jakarta Persistence annotations. It defines the schema structure including unique constraints and foreign key relationships.",
    "databaseName": "acc_rule_tags",
    "tablesAccessed": [
      "acc_rule_tags"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM entity mapping for CRUD operations.",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"acc_rule_tags\"...)\npublic class AccountingTagRule extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.accounting.rule.domain.AccountingRule",
    "mechanism": "JPA",
    "name": "AccountingRule",
    "description": "The class is a JPA Entity mapped to the 'acc_accounting_rule' table. It defines relationships with 'Office' (ManyToOne), 'GLAccount' (ManyToOne for debit/credit accounts), and 'AccountingTagRule' (OneToMany).",
    "databaseName": "acc_accounting_rule",
    "tablesAccessed": [
      "acc_accounting_rule",
      "acc_accounting_tag_rule"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with standard CRUD operations managed by the persistence context.",
    "transactionHandling": "JPA EntityTransaction (implicitly managed by container/framework)",
    "protocol": "JPA 3.0 / Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"acc_accounting_rule\", uniqueConstraints = {\n        @UniqueConstraint(columnNames = { \"name\" }, name = \"accounting_rule_name_unique\") })\npublic class AccountingRule extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.adhocquery.domain.AdHoc",
    "mechanism": "JPA",
    "name": "AdHoc",
    "description": "The class is a JPA entity mapped to the 'm_adhoc' database table using Jakarta Persistence annotations.",
    "databaseName": "m_adhoc",
    "tablesAccessed": [
      "m_adhoc"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_adhoc\")\npublic class AdHoc extends AbstractAuditableCustom {"
  },
  {
    "path": "org.apache.fineract.batch.service.BatchApiServiceImpl",
    "mechanism": "JPA",
    "name": "BatchApiServiceImpl",
    "description": "The class directly manages database interactions through programmatic transaction control using Spring's 'PlatformTransactionManager' and 'TransactionTemplate'. It injects a 'jakarta.persistence.EntityManager' via '@PersistenceContext' to interact with the persistence layer. Transactions are not managed declaratively with '@Transactional' annotations, but are instead explicitly started and controlled within the 'callInTransaction' method. This allows for two distinct modes: one where the entire batch runs in a single transaction, and another where each root request gets a new transaction. Before executing a command, it explicitly calls 'entityManager.flush()' to synchronize the persistence context with the database within an active transaction.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The class itself does not contain specific queries. It orchestrates the execution of 'CommandStrategy' objects, which are responsible for performing the actual database operations. The interaction is at the ORM level through the JPA EntityManager, implying that the underlying queries are likely JPQL or generated by JPA provider.",
    "transactionHandling": "Programmatic transaction management using Spring's 'TransactionTemplate' and 'PlatformTransactionManager'. The 'callInTransaction' method creates a 'TransactionTemplate', which executes a block of code within a transaction, handling commit and rollback. One mode uses a single transaction for the whole batch, while the other uses 'PROPAGATION_REQUIRES_NEW' to create a new transaction for each root request.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return transactionTemplate.execute(status -> {\n    BatchRequestContextHolder.setEnclosingTransaction(Optional.of(status));\n    try {\n        responseList.addAll(request.get());\n        return responseList;\n    } catch (BatchExecutionException ex) {\n        status.setRollbackOnly();\n        return List.of(buildErrorResponse(ex.getCause(), ex.getRequest()));\n    } catch (RuntimeException ex) {\n        status.setRollbackOnly();\n        return buildErrorResponses(ex, responseList);\n    }\n});"
  },
  {
    "path": "org.apache.fineract.cob.domain",
    "mechanism": "JPA",
    "name": "LoanAccountLock",
    "description": "The class is a JPA Entity that maps directly to the 'm_loan_account_locks' table. It uses standard Jakarta Persistence annotations to define the schema mapping, including primary key, columns, and optimistic locking version.",
    "databaseName": "m_loan_account_locks",
    "tablesAccessed": [
      "m_loan_account_locks"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_loan_account_locks\")\npublic class LoanAccountLock {\n    @Id\n    @Column(name = \"loan_id\", nullable = false)\n    private Long loanId;\n..."
  },
  {
    "path": "org.apache.fineract.cob.domain",
    "mechanism": "JPA",
    "name": "BatchBusinessStep",
    "description": "The class is a JPA Entity mapped to the 'm_batch_business_steps' table. It uses annotations to define column mappings for job configuration data.",
    "databaseName": "m_batch_business_steps",
    "tablesAccessed": [
      "m_batch_business_steps"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_batch_business_steps\")\npublic class BatchBusinessStep extends AbstractPersistableCustom {\n    @Column(name = \"job_name\", nullable = false)\n    private String jobName;\n}"
  },
  {
    "path": "org.apache.fineract.cob.domain",
    "mechanism": "JPA",
    "name": "CustomLoanAccountLockRepositoryImpl",
    "description": "The class uses the JPA EntityManager to execute a native SQL UPDATE statement. It interacts directly with the 'm_loan' and 'm_loan_account_locks' tables to perform a bulk update based on complex criteria involving subqueries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_loan_account_locks"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Native SQL UPDATE with subqueries and database-specific date functions",
    "transactionHandling": "Implicit (likely managed by Spring service layer calling this repository)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "entityManager.createNativeQuery(sql).executeUpdate();"
  },
  {
    "path": "org.apache.fineract.cob.service",
    "mechanism": "JPA",
    "name": "PersistenceContext",
    "description": "This interface is explicitly designed to manage the lifecycle of JPA entities (indicated by the extension of AbstractPersistableCustom). Implementations will interact with the database to refresh entity states.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Entity refresh/reload by ID",
    "transactionHandling": "Likely managed by Spring @Transactional in implementations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "S reload(S input);"
  },
  {
    "path": "org.apache.fineract.commands.domain.CommandSource",
    "mechanism": "JPA",
    "name": "CommandSource Entity",
    "description": "The class is a JPA Entity annotated with @Entity and @Table(name = 'm_portfolio_command_source'). It maps Java fields to database columns using @Column, @ManyToOne, and @JoinColumn annotations. It relies on a JPA provider (like Hibernate) to handle persistence operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_portfolio_command_source"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for CRUD operations",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JPA 3.0 / Hibernate",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_portfolio_command_source\")\npublic class CommandSource extends AbstractPersistableCustom {\n    @Column(name = \"action_name\", nullable = true, length = 100)\n    private String actionName;\n    // ..."
  },
  {
    "path": "org.apache.fineract.commands.service",
    "mechanism": "JPA",
    "name": "DummyCommandSource",
    "description": "The file defines a static inner class `DummyCommandSource` annotated as a JPA entity, likely used to simulate database persistence objects during the test execution without hitting a real database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_portfolio_command_source"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "ORM mapping definition only",
    "transactionHandling": "Mocked via FineractRequestContextHolder",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n    @Table(name = \"m_portfolio_command_source\")\n    public static class DummyCommandSource extends CommandSource {"
  },
  {
    "path": "org.apache.fineract.infrastructure.accountnumberformat.domain",
    "mechanism": "JPA",
    "name": "AccountNumberFormat",
    "description": "The class is a JPA Entity mapped to a database table. It uses Jakarta Persistence annotations to define the table name, unique constraints, and column mappings for account type, prefix type, and prefix character.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountNumberFormatConstants.ACCOUNT_NUMBER_FORMAT_TABLE_NAME"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = AccountNumberFormatConstants.ACCOUNT_NUMBER_FORMAT_TABLE_NAME...)\npublic class AccountNumberFormat extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.bulkimport.domain.ImportDocument",
    "mechanism": "JPA",
    "name": "ImportDocument",
    "description": "The class is a JPA Entity mapped to the 'm_import_document' table. It uses annotations to define column mappings, relationships (OneToOne, ManyToOne), and table configuration.",
    "databaseName": "m_import_document",
    "tablesAccessed": [
      "m_import_document"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_import_document\")\npublic class ImportDocument extends AbstractPersistableCustom {\n    @OneToOne\n    @JoinColumn(name = \"document_id\")\n    private Document document;\n    // ..."
  },
  {
    "path": "org.apache.fineract.infrastructure.businessdate.domain.BusinessDate",
    "mechanism": "JPA",
    "name": "BusinessDate Entity",
    "description": "The class is a JPA entity mapped to the relational database table 'm_business_date'. It uses standard Jakarta Persistence annotations to define the mapping, including column definitions and unique constraints.",
    "databaseName": "m_business_date",
    "tablesAccessed": [
      "m_business_date"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_business_date\", uniqueConstraints = { @UniqueConstraint(name = \"uq_business_date_type\", columnNames = { \"type\" }) })\npublic class BusinessDate extends AbstractAuditableWithUTCDateTimeCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.cache.domain.PlatformCache",
    "mechanism": "JPA",
    "name": "PlatformCache",
    "description": "The class is a JPA Entity that maps to the 'c_cache' database table. It uses standard Jakarta Persistence annotations to define the table name and column mappings for the cache configuration.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "c_cache"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"c_cache\")\npublic class PlatformCache extends AbstractPersistableCustom {\n    @Column(name = \"cache_type_enum\")\n    private Integer cacheType;"
  },
  {
    "path": "org.apache.fineract.infrastructure.cache.service",
    "mechanism": "JPA",
    "name": "ConfigurationDomainService",
    "description": "The class participates in database transactions via the Spring `@Transactional` annotation. While it does not execute SQL directly, it delegates persistence operations to `ConfigurationDomainService`, which updates the cache configuration in the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to domain service for updates",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic Map<String, Object> switchToCache(final CacheType toCacheType) {\n    // ...\n    if (!changes.isEmpty()) {\n        this.configurationDomainService.updateCache(toCacheType);\n    }\n    return changes;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.domain",
    "mechanism": "JPA",
    "name": "EmailConfiguration",
    "description": "This class is a JPA Entity that maps directly to a relational database table named 'scheduled_email_configuration'. It defines the schema for storing email configuration settings, specifically a name and a value column.",
    "databaseName": "scheduled_email_configuration",
    "tablesAccessed": [
      "scheduled_email_configuration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for simple CRUD operations.",
    "transactionHandling": "JPA EntityTransaction (managed by container or framework)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"scheduled_email_configuration\")\npublic class EmailConfiguration extends AbstractPersistableCustom {\n    @Column(name = \"name\", nullable = false)\n    private String name;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.domain.EmailCampaign",
    "mechanism": "JPA",
    "name": "EmailCampaign Entity",
    "description": "The class is a JPA Entity mapped to the 'scheduled_email_campaign' table. It uses Jakarta Persistence annotations to define the table mapping, column definitions, and relationships (ManyToOne) with other entities like AppUser and Report.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "scheduled_email_campaign"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"scheduled_email_campaign\")\npublic class EmailCampaign extends AbstractPersistableCustom {\n    @Column(name = \"campaign_name\", nullable = false)\n    private String campaignName;\n    ..."
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.domain.EmailMessage",
    "mechanism": "JPA",
    "name": "EmailMessage",
    "description": "The class is a JPA Entity mapped to the 'scheduled_email_messages_outbound' table. It uses standard Jakarta Persistence annotations to define the table mapping, columns, and relationships (ManyToOne) with other entities like Group, Client, and Staff.",
    "databaseName": "scheduled_email_messages_outbound",
    "tablesAccessed": [
      "scheduled_email_messages_outbound"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"scheduled_email_messages_outbound\")\npublic class EmailMessage extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.handler",
    "mechanism": "JPA",
    "name": "EmailCampaignWritePlatformService",
    "description": "The class defines a transactional boundary using Spring's `@Transactional` annotation for a database write operation. While it does not execute SQL or JPA calls directly, it delegates to `EmailCampaignWritePlatformService` which performs the persistence logic (likely using JPA/Hibernate given the Fineract context).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for deletion",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand command) {\n    return this.emailCampaignWritePlatformService.delete(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.handler",
    "mechanism": "JPA",
    "name": "EmailWritePlatformService",
    "description": "The class manages database transactions via the `@Transactional` annotation while delegating the actual data modification (deletion) to the `EmailWritePlatformService`. Although direct SQL or Repository calls are not present in this file, it orchestrates the transactional context for the database operation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EMAIL"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.delete(command.entityId());\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.sms.domain.SmsCampaign",
    "mechanism": "JPA",
    "name": "SmsCampaign Entity",
    "description": "The class is a standard JPA Entity mapped to the 'sms_campaign' table. It uses Jakarta Persistence annotations to define the table structure, columns, and relationships (ManyToOne with Report and AppUser).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "sms_campaign"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"sms_campaign\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"campaign_name\" }, name = \"campaign_name_UNIQUE\") })\npublic class SmsCampaign extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.domain.Code",
    "mechanism": "JPA",
    "name": "Code",
    "description": "The class is a JPA Entity mapped to the 'm_code' table. It defines columns for 'code_name' and 'is_system_defined'. It also manages a One-to-Many relationship with the 'CodeValue' entity.",
    "databaseName": "m_code",
    "tablesAccessed": [
      "m_code"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_code\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"code_name\" }, name = \"code_name\") })\npublic class Code extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.domain.CodeValue",
    "mechanism": "JPA",
    "name": "CodeValue",
    "description": "The class is a JPA Entity mapped to the 'm_code_value' table. It defines columns for code values, ordering, and relationships to the parent 'Code' entity.",
    "databaseName": "m_code_value",
    "tablesAccessed": [
      "m_code_value"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_code_value\", uniqueConstraints = {\n        @UniqueConstraint(columnNames = { \"code_id\", \"code_value\" }, name = \"code_value_duplicate\") })\npublic class CodeValue extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.domain",
    "mechanism": "JPA",
    "name": "GlobalConfigurationProperty",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping directly to the 'c_configuration' table in the database. It uses standard Jakarta Persistence annotations to define column mappings.",
    "databaseName": "c_configuration",
    "tablesAccessed": [
      "c_configuration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"c_configuration\")\npublic class GlobalConfigurationProperty extends AbstractPersistableCustom {\n    @Column(name = \"name\", nullable = false)\n    private String name;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.domain.ExternalService",
    "mechanism": "JPA",
    "name": "ExternalService",
    "description": "The class is a JPA entity mapped to the 'c_external_service' table. It defines a unique constraint on the 'name' column and inherits persistence capabilities from a base class.",
    "databaseName": "c_external_service",
    "tablesAccessed": [
      "c_external_service"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA 3.0 / Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"c_external_service\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"name_UNIQUE\") })\npublic class ExternalService extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.domain.ExternalServicePropertiesPK",
    "mechanism": "JPA",
    "name": "ExternalServicePropertiesPK",
    "description": "This class is a JPA Embeddable type that maps a composite primary key to database columns. It defines the structure of the key used to access specific rows in the associated table.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Column(name = \"external_service_id\")\nprivate Long externalServiceId;"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.domain.ExternalServicesProperties",
    "mechanism": "JPA",
    "name": "ExternalServicesProperties Entity",
    "description": "This class is a JPA Entity that maps directly to the 'c_external_service_properties' table. It uses an embedded composite ID for the primary key.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "c_external_service_properties"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"c_external_service_properties\")\npublic class ExternalServicesProperties {\n    @EmbeddedId\n    ExternalServicePropertiesPK externalServicePropertiesPK;\n    @Column(name = \"value\", length = 250)\n    private String value;"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.config.jpa",
    "mechanism": "JPA",
    "name": "JPA Configuration",
    "description": "This class configures the JPA layer using EclipseLink. It sets up the EntityManagerFactory, defines the persistence unit 'jpa-pu', and enables Spring Data JPA repositories. It uses a RoutingDataSource, implying support for dynamic or multi-tenant database connections.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown (scans packages org.apache.fineract.**.domain)"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM configuration for entity scanning and persistence unit management.",
    "transactionHandling": "Configures PlatformTransactionManager and provides a TransactionTemplate for programmatic transactions.",
    "protocol": "EclipseLink JPA",
    "connectionInfo": "DataSource provided by RoutingDataSource",
    "codeExample": "return factoryBuilder.dataSource(getDataSource()).properties(vendorProperties).persistenceUnit(\"jpa-pu\").packages(packagesToScan).jta(false).build();"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.config.jpa.EntityManagerFactoryCustomizer",
    "mechanism": "JPA",
    "name": "EntityManagerFactoryCustomizer",
    "description": "This interface is a configuration hook for the JPA layer. While it does not execute queries itself, it is integral to the setup of the database interaction layer by defining how the EntityManagerFactory is customized (e.g., scanning for entities, setting vendor properties).",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "JPA (EclipseLink)",
    "connectionInfo": "n/a",
    "codeExample": "default Map<String, Object> additionalVendorProperties() {\n    return Collections.emptyMap();\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.data.GenericEnumListConverter",
    "mechanism": "JPA",
    "name": "JPA AttributeConverter",
    "description": "This class implements the JPA `AttributeConverter` interface to handle the conversion of Java types to JDBC types automatically. It is used to map a `List<Enum>` in a Java Entity to a single `VARCHAR` or `TEXT` column in the database containing comma-separated values.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping logic",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA 3.0+ (Jakarta Persistence)",
    "connectionInfo": "n/a",
    "codeExample": "public abstract class GenericEnumListConverter<E extends Enum<E>> implements AttributeConverter<List<E>, String> { ... return valueStream.map(Enum::name).collect(Collectors.joining(SPLIT_CHAR)); }"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.diagnostics.jpa",
    "mechanism": "JPA",
    "name": "EntityManager",
    "description": "The class interacts directly with the JPA EntityManager infrastructure to provide diagnostic information. It specifically relies on the EclipseLink implementation (EntityManagerImpl) to access internal details like the UnitOfWork and ChangeSets.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Relies on existing Spring managed transactions via EntityManagerFactoryUtils",
    "protocol": "EclipseLink JPA",
    "connectionInfo": "unknown",
    "codeExample": "EntityManagerFactory emf = applicationContext.getBean(EntityManagerFactory.class);\nreturn (EntityManagerImpl) EntityManagerFactoryUtils.getTransactionalEntityManager(emf);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.diagnostics.jpa.StatementLoggingCustomizer",
    "mechanism": "JPA",
    "name": "EclipseLink Configuration",
    "description": "Configures the EclipseLink JPA provider to output SQL statements and parameters to the logs. It does not perform data access itself but modifies the behavior of the persistence unit to enable diagnostic logging.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "EclipseLink JPA",
    "connectionInfo": "n/a",
    "codeExample": "return Map.of(\"eclipselink.logging.level.sql\", SessionLog.FINE_LABEL, PersistenceUnitProperties.LOGGING_PARAMETERS, Boolean.TRUE.toString());"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.domain",
    "mechanism": "JPA",
    "name": "AbstractAuditableCustom",
    "description": "The class uses Jakarta Persistence (JPA) annotations to define a mapped superclass. It maps Java fields to specific database columns (e.g., 'createdby_id', 'created_date') to store audit information. Subclasses of this class will include these columns in their respective database tables.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Column(name = \"createdby_id\")\nprivate Long createdBy;"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.domain",
    "mechanism": "JPA",
    "name": "ExternalIdConverter",
    "description": "This class is a JPA AttributeConverter that automatically maps the 'ExternalId' Java type to a database column (likely VARCHAR) and vice versa.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM type conversion",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA 3.0",
    "connectionInfo": "n/a",
    "codeExample": "@Override\npublic String convertToDatabaseColumn(ExternalId externalId) {\n    return externalId != null ? externalId.getValue() : null;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.domain",
    "mechanism": "JPA",
    "name": "AbstractPersistableCustom",
    "description": "The class acts as a JPA MappedSuperclass, defining the common database identity column and persistence lifecycle behavior for inheriting entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping definition",
    "transactionHandling": "JPA lifecycle callbacks",
    "protocol": "JPA 3.0+ (Jakarta Persistence)",
    "connectionInfo": "n/a",
    "codeExample": "@Id\n@GeneratedValue(strategy = GenerationType.IDENTITY)\nprivate Long id;"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.domain",
    "mechanism": "JPA",
    "name": "AbstractAuditableWithUTCDateTimeCustom",
    "description": "The class uses Jakarta Persistence API (JPA) annotations to define a mapped superclass. It maps Java fields to specific database columns for auditing purposes (created/modified by/date). It does not access the database directly but defines the schema for subclasses.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Column(name = CREATED_BY_DB_FIELD, nullable = false)\n@Setter(onMethod = @__(@Override))\nprivate Long createdBy;"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.jpa",
    "mechanism": "JPA",
    "name": "EntityManager",
    "description": "The class interacts directly with the Jakarta Persistence API (JPA) EntityManager to construct and execute dynamic queries. It uses the Criteria API to build queries programmatically based on Spring Data Specifications and Pageable objects.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic criteria queries constructed at runtime based on Specifications and Pageable inputs. Includes count queries for pagination.",
    "transactionHandling": "unknown",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "CriteriaBuilder builder = entityManager.getCriteriaBuilder();\nCriteriaQuery<Long> query = builder.createQuery(Long.class);\nRoot<S> root = query.from(domainClass);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.persistence",
    "mechanism": "JPA",
    "name": "ExtendedJpaTransactionManager",
    "description": "This class acts as the Transaction Manager for JPA operations. It interacts directly with the Jakarta Persistence `EntityManager` to manage transaction states, specifically optimizing read-only operations by manipulating flush modes and clearing the persistence context.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "EntityManager entityManager = getCurrentEntityManager();\nif (entityManager != null) {\n    entityManager.setFlushMode(FlushModeType.COMMIT);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.persistence",
    "mechanism": "JPA",
    "name": "DatabaseSelectingPersistenceUnitPostProcessor",
    "description": "This class configures the JPA provider (EclipseLink) to use the correct SQL dialect for the connected database (MySQL or PostgreSQL). It does not execute queries itself but ensures the ORM layer is correctly configured to do so.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "n/a",
    "protocol": "MySQL or PostgreSQL",
    "connectionInfo": "n/a",
    "codeExample": "pui.addProperty(PersistenceUnitProperties.TARGET_DATABASE, targetDatabase);"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain",
    "mechanism": "JPA",
    "name": "CreditBureauToken",
    "description": "The class is a JPA Entity that maps to the 'm_creditbureau_token' table. It uses standard Jakarta Persistence annotations to define the table name and column mappings for token properties.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_creditbureau_token"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for standard CRUD operations.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC/JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_creditbureau_token\")\npublic class CreditBureauToken extends AbstractPersistableCustom {\n    @Column(name = \"token\")\n    private String accessToken;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain",
    "mechanism": "JPA",
    "name": "CreditBureauConfiguration",
    "description": "The class is a JPA Entity mapped to a relational database table. It defines columns for configuration keys, values, and descriptions, and establishes a Many-to-One relationship with the OrganisationCreditBureau entity.",
    "databaseName": "m_creditbureau_configuration",
    "tablesAccessed": [
      "m_creditbureau_configuration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_creditbureau_configuration\")\npublic class CreditBureauConfiguration extends AbstractPersistableCustom {\n    @Column(name = \"configkey\")\n    private String configurationKey;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain.CreditBureau",
    "mechanism": "JPA",
    "name": "CreditBureau",
    "description": "This class is a JPA Entity that maps directly to a database table using Jakarta Persistence annotations.",
    "databaseName": "m_creditbureau",
    "tablesAccessed": [
      "m_creditbureau"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM mapping for CRUD operations.",
    "transactionHandling": "Managed by the JPA provider and Spring context (likely @Transactional in service layer).",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_creditbureau\")\npublic class CreditBureau extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain.CreditBureauLoanProductMapping",
    "mechanism": "JPA",
    "name": "CreditBureauLoanProductMapping",
    "description": "The class is a JPA Entity mapped to the 'm_creditbureau_loanproduct_mapping' table. It defines columns for configuration settings and relationships to other entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_creditbureau_loanproduct_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with relationships (ManyToOne, OneToOne).",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_creditbureau_loanproduct_mapping\")\npublic class CreditBureauLoanProductMapping extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain.CreditReport",
    "mechanism": "JPA",
    "name": "CreditReport",
    "description": "The class is a JPA Entity mapped to the relational database. It defines the schema for storing credit reports, including a lazy-loaded BLOB column for the report data.",
    "databaseName": "m_creditreport",
    "tablesAccessed": [
      "m_creditreport"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM mapping with lazy loading for binary data",
    "transactionHandling": "Managed by the JPA Persistence Context",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_creditreport\")\npublic class CreditReport extends AbstractPersistableCustom {\n    @Column(name = \"credit_bureau_id\")\n    private Long creditBureauId;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain.OrganisationCreditBureau",
    "mechanism": "JPA",
    "name": "OrganisationCreditBureau",
    "description": "The class is a JPA entity mapped to the 'm_organisation_creditbureau' table. It manages persistence for organisation-specific credit bureau configurations.",
    "databaseName": "m_organisation_creditbureau",
    "tablesAccessed": [
      "m_organisation_creditbureau"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_organisation_creditbureau\")\npublic class OrganisationCreditBureau extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.handler",
    "mechanism": "JPA",
    "name": "CreditBureauConfigurationWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's @Transactional annotation. While it does not execute SQL directly, it orchestrates a write operation via the injected service, ensuring that the underlying database updates performed by the service are committed or rolled back atomically.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CREDITBUREAU_CONFIGURATION"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.updateCreditBureauConfiguration(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain.EntityDatatableChecks",
    "mechanism": "JPA",
    "name": "EntityDatatableChecks",
    "description": "The class is a JPA Entity mapped to a relational database table using Jakarta Persistence annotations.",
    "databaseName": "m_entity_datatable_check",
    "tablesAccessed": [
      "m_entity_datatable_check"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_entity_datatable_check\")\npublic class EntityDatatableChecks extends AbstractPersistableCustom {\n    @Column(name = \"application_table_name\", nullable = false)\n    private String entity;"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain.RegisteredDatatable",
    "mechanism": "JPA",
    "name": "RegisteredDatatable",
    "description": "The class is a JPA Entity mapped to the 'x_registered_table' database table. It defines the schema for storing metadata about registered extension tables using Jakarta Persistence annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "x_registered_table"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM entity mapping for CRUD operations.",
    "transactionHandling": "Transactions are managed by the container or service layer interacting with this entity (likely Spring @Transactional).",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"x_registered_table\")\npublic class RegisteredDatatable extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain.Report",
    "mechanism": "JPA",
    "name": "Report",
    "description": "The class is a JPA Entity mapped to the 'stretchy_report' table. It uses standard Jakarta Persistence annotations to define the schema mapping, including columns, unique constraints, and relationships.",
    "databaseName": "stretchy_report",
    "tablesAccessed": [
      "stretchy_report"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"stretchy_report\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"report_name\" }, name = \"unq_report_name\") })\npublic final class Report extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain.ReportParameter",
    "mechanism": "JPA",
    "name": "ReportParameter",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses Jakarta Persistence annotations to define the mapping strategy.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "stretchy_parameter"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping for CRUD operations",
    "transactionHandling": "Relies on the container or service layer transaction management (JPA)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"stretchy_parameter\")\npublic class ReportParameter extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain.ReportParameterUsage",
    "mechanism": "JPA",
    "name": "ReportParameterUsage",
    "description": "The class is a JPA Entity that maps to the 'stretchy_report_parameter' table. It manages the many-to-many relationship (with extra attributes) between Reports and ReportParameters.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "stretchy_report_parameter"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"stretchy_report_parameter\")\npublic final class ReportParameterUsage extends AbstractPersistableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"report_id\", nullable = false)\n    private Report report;"
  },
  {
    "path": "org.apache.fineract.infrastructure.documentmanagement.domain",
    "mechanism": "JPA",
    "name": "Image",
    "description": "The class is a JPA Entity that maps directly to the 'm_image' database table using Jakarta Persistence annotations.",
    "databaseName": "m_image",
    "tablesAccessed": [
      "m_image"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_image\")\npublic final class Image extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.infrastructure.documentmanagement.domain.Document",
    "mechanism": "JPA",
    "name": "Document",
    "description": "The class is a JPA entity mapped to the 'm_document' table using standard Jakarta Persistence annotations. It defines columns for document attributes and manages persistence through the JPA provider.",
    "databaseName": "m_document",
    "tablesAccessed": [
      "m_document"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_document\")\npublic class Document extends AbstractPersistableCustom {\n    @Column(name = \"name\", length = 250)\n    private String name;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.domain.FineractEntityAccess",
    "mechanism": "JPA",
    "name": "FineractEntityAccess",
    "description": "The class is a JPA Entity mapped to a relational database table. It uses annotations to define the table name and column mappings, including a Many-to-One relationship.",
    "databaseName": "m_entity_to_entity_access",
    "tablesAccessed": [
      "m_entity_to_entity_access"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_entity_to_entity_access\")\npublic class FineractEntityAccess extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.domain.FineractEntityRelation",
    "mechanism": "JPA",
    "name": "FineractEntityRelation",
    "description": "The class is a JPA entity that maps directly to the 'm_entity_relation' table in the database. It defines the schema for storing entity relationship definitions, including columns for 'from_entity_type', 'to_entity_type', and 'code_name'. It also manages a one-to-many relationship with the 'FineractEntityToEntityMapping' entity, configured with CascadeType.ALL and orphan removal.",
    "databaseName": "m_entity_relation",
    "tablesAccessed": [
      "m_entity_relation",
      "m_entity_to_entity_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA / JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_entity_relation\")\npublic class FineractEntityRelation extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.domain.FineractEntityToEntityMapping",
    "mechanism": "JPA",
    "name": "FineractEntityToEntityMapping",
    "description": "The class is a JPA entity mapped to the 'm_entity_to_entity_mapping' table. It uses Jakarta Persistence annotations to define the table structure, columns, and relationships (Many-to-One with FineractEntityRelation).",
    "databaseName": "m_entity_to_entity_mapping",
    "tablesAccessed": [
      "m_entity_to_entity_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_entity_to_entity_mapping\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"rel_id\", \"from_id\", \"to_id\" }) })\npublic class FineractEntityToEntityMapping extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.repository",
    "mechanism": "JPA",
    "name": "CustomExternalEventConfigurationRepositoryImpl",
    "description": "The class uses the Jakarta Persistence API (JPA) EntityManager to perform direct entity lookups against the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalEventConfiguration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD lookup by primary key",
    "transactionHandling": "Implicitly managed by the container or Spring context (no explicit annotations on this class)",
    "protocol": "JPA (Jakarta Persistence)",
    "connectionInfo": "Managed by Spring/Container DataSource",
    "codeExample": "final ExternalEventConfiguration configuration = entityManager.find(ExternalEventConfiguration.class, externalEventType);"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.repository.domain.ExternalEvent",
    "mechanism": "JPA",
    "name": "ExternalEvent",
    "description": "The class is a JPA Entity that maps directly to the 'm_external_event' database table. It uses Jakarta Persistence annotations to define the schema mapping, including column names, nullability, and fetch types (e.g., Lazy fetching for the binary data blob).",
    "databaseName": "m_external_event",
    "tablesAccessed": [
      "m_external_event"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA (Jakarta Persistence)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_external_event\")\npublic class ExternalEvent extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.repository.domain.ExternalEventConfiguration",
    "mechanism": "JPA",
    "name": "ExternalEventConfiguration",
    "description": "The class is a JPA Entity that maps directly to a relational database table using Jakarta Persistence annotations.",
    "databaseName": "m_external_event_configuration",
    "tablesAccessed": [
      "m_external_event_configuration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_external_event_configuration\")\npublic class ExternalEventConfiguration {\n    @Id\n    @Column(name = \"type\", nullable = false)\n    private String type;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.service.ExternalEventService",
    "mechanism": "JPA",
    "name": "ExternalEventRepository",
    "description": "The service interacts with the database primarily through the ExternalEventRepository (likely a Spring Data JPA repository) to save event entities. It also directly uses the JPA EntityManager to flush the persistence context to ensure data consistency before event serialization.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalEvent"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "repository.save(externalEvent);"
  },
  {
    "path": "org.apache.fineract.infrastructure.gcm.domain.DeviceRegistration",
    "mechanism": "JPA",
    "name": "DeviceRegistration",
    "description": "This class is a JPA Entity that maps directly to the 'client_device_registration' database table. It defines the schema structure including a foreign key to the client table and a unique constraint on the registration ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "client_device_registration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM entity mapping for CRUD operations.",
    "transactionHandling": "Managed by the JPA persistence context (likely Spring @Transactional in service layer).",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"client_device_registration\")\npublic class DeviceRegistration extends AbstractPersistableCustom {\n    @OneToOne\n    @JoinColumn(name = \"client_id\", nullable = false, unique = true)\n    private Client client;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.domain.Hook",
    "mechanism": "JPA",
    "name": "Hook",
    "description": "The class is a JPA Entity mapped to the 'm_hook' table. It defines columns for properties and manages relationships with other entities.",
    "databaseName": "m_hook",
    "tablesAccessed": [
      "m_hook"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity mapping with OneToMany relationships.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JPA/Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_hook\")\npublic final class Hook extends AbstractAuditableCustom {\n    @Column(name = \"name\", nullable = false, length = 100)\n    private String name;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.domain.HookConfiguration",
    "mechanism": "JPA",
    "name": "HookConfiguration",
    "description": "The class is a JPA Entity mapped to the 'm_hook_configuration' table. It defines columns for configuration details and a foreign key relationship to the 'm_hook' table.",
    "databaseName": "m_hook_configuration",
    "tablesAccessed": [
      "m_hook_configuration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_hook_configuration\")\npublic class HookConfiguration extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.domain.HookResource",
    "mechanism": "JPA",
    "name": "HookResource",
    "description": "The class is a JPA entity that maps to the relational database table 'm_hook_registered_events'. It defines the schema for storing webhook event triggers, including a foreign key relationship to the main hook table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_hook_registered_events"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_hook_registered_events\")\npublic class HookResource extends AbstractPersistableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"hook_id\", referencedColumnName = \"id\", nullable = false)\n    private Hook hook;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.domain.HookTemplate",
    "mechanism": "JPA",
    "name": "HookTemplate",
    "description": "The class is a JPA Entity mapped to the 'm_hook_templates' table using Jakarta Persistence annotations. It defines a one-to-many relationship with the 'Schema' entity.",
    "databaseName": "m_hook_templates",
    "tablesAccessed": [
      "m_hook_templates"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_hook_templates\")\npublic final class HookTemplate extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.domain.Schema",
    "mechanism": "JPA",
    "name": "Schema",
    "description": "The class is a Java Persistence API (JPA) entity that maps directly to the relational database table 'm_hook_schema'. It defines the schema for storing hook configuration field definitions, including relationships to the hook template and column definitions for field metadata.",
    "databaseName": "m_hook_schema",
    "tablesAccessed": [
      "m_hook_schema"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_hook_schema\")\npublic class Schema extends AbstractPersistableCustom {\n    @Column(name = \"field_name\", nullable = false, length = 100)\n    private String fieldName;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain",
    "mechanism": "JPA",
    "name": "CustomJobParameter",
    "description": "This class is a JPA Entity that maps to a relational database table using Jakarta Persistence annotations.",
    "databaseName": "batch_custom_job_parameters",
    "tablesAccessed": [
      "batch_custom_job_parameters"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA Entity mapping for CRUD operations.",
    "transactionHandling": "Managed by JPA Context/Container",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"batch_custom_job_parameters\")\npublic class CustomJobParameter extends AbstractPersistableCustom {\n    @Column(name = \"parameter_json\", nullable = false, columnDefinition = \"json\")\n    private String parameterJson;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain",
    "mechanism": "JPA",
    "name": "SchedulerDetail",
    "description": "The class is a JPA Entity that maps the 'SchedulerDetail' object to the 'scheduler_detail' table in the database using Jakarta Persistence annotations.",
    "databaseName": "scheduler_detail",
    "tablesAccessed": [
      "scheduler_detail"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for standard CRUD operations.",
    "transactionHandling": "Managed via JPA context/Spring Data (implicit in entity definition).",
    "protocol": "JPA/JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"scheduler_detail\")\npublic class SchedulerDetail extends AbstractPersistableCustom {\n    @Column(name = \"execute_misfired_jobs\")\n    private boolean executeInstructionForMisfiredJobs;"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain.JobParameter",
    "mechanism": "JPA",
    "name": "JobParameter",
    "description": "The class is a JPA Entity that maps directly to a relational database table to persist job parameter data.",
    "databaseName": "job_parameters",
    "tablesAccessed": [
      "job_parameters"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM mapping for CRUD operations.",
    "transactionHandling": "Transactions are managed by the persistence context, typically via Spring's @Transactional in the service layer.",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"job_parameters\")\npublic class JobParameter extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain.ScheduledJobDetail",
    "mechanism": "JPA",
    "name": "ScheduledJobDetail",
    "description": "The class is a JPA entity mapped to the 'job' database table using Jakarta Persistence annotations. It defines the schema mapping for job scheduling details, including columns for job name, cron expression, and execution timestamps.",
    "databaseName": "job",
    "tablesAccessed": [
      "job"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for standard CRUD operations.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"job\")\npublic class ScheduledJobDetail extends AbstractPersistableCustom {\n    @Column(name = \"cron_expression\")\n    private String cronExpression;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain.ScheduledJobRunHistory",
    "mechanism": "JPA",
    "name": "ScheduledJobRunHistory",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses Jakarta Persistence annotations to define the table name, column mappings, and relationships.",
    "databaseName": "job_run_history",
    "tablesAccessed": [
      "job_run_history",
      "scheduled_job_detail"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for CRUD operations",
    "transactionHandling": "JPA EntityTransaction (managed by container/context)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"job_run_history\")\npublic class ScheduledJobRunHistory extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.domain.ReportMailingJob",
    "mechanism": "JPA",
    "name": "ReportMailingJob",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping directly to the 'm_report_mailing_job' table. It uses Jakarta Persistence annotations to define column mappings, unique constraints, and relationships (ManyToOne) with other entities like 'Report' and 'AppUser'.",
    "databaseName": "m_report_mailing_job",
    "tablesAccessed": [
      "m_report_mailing_job"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "Unknown (JPA abstraction)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_report_mailing_job\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"unique_name\") })\npublic class ReportMailingJob extends AbstractAuditableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.domain.ReportMailingJobConfiguration",
    "mechanism": "JPA",
    "name": "ReportMailingJobConfiguration",
    "description": "The class is a JPA Entity mapped to a relational database table. It uses Jakarta Persistence annotations to define the schema mapping, including table name, column definitions, and unique constraints.",
    "databaseName": "m_report_mailing_job_configuration",
    "tablesAccessed": [
      "m_report_mailing_job_configuration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC/JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_report_mailing_job_configuration\", uniqueConstraints = {\n        @UniqueConstraint(columnNames = { \"name\" }, name = \"unique_name\") })\npublic class ReportMailingJobConfiguration extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.domain.ReportMailingJobRunHistory",
    "mechanism": "JPA",
    "name": "ReportMailingJobRunHistory",
    "description": "The class is a JPA Entity that maps to a relational database table to store job execution history records.",
    "databaseName": "m_report_mailing_job_run_history",
    "tablesAccessed": [
      "m_report_mailing_job_run_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM mapping for CRUD operations.",
    "transactionHandling": "Managed by the JPA provider and Spring transaction management context.",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_report_mailing_job_run_history\")\npublic class ReportMailingJobRunHistory extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.api",
    "mechanism": "JPA",
    "name": "AppUser Entity / ClientReadPlatformService",
    "description": "The code interacts with the database primarily through the `AppUser` JPA entity (retrieved via the Authentication principal) and the `ClientReadPlatformService`. It traverses entity relationships (Roles, Office) which may trigger lazy loading from the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_appuser",
      "m_role",
      "m_office",
      "m_client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Entity traversal and service-based read operations",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final AppUser principal = (AppUser) authenticationCheck.getPrincipal();\nfinal Set<Role> userRoles = principal.getRoles();\nfor (final Role role : userRoles) {\n    roles.add(role.toData());\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.domain",
    "mechanism": "JPA",
    "name": "TFAccessToken",
    "description": "The class is a JPA Entity mapped to the 'twofactor_access_token' table. It defines columns for the token string, validity timestamps, enabled status, and a foreign key relationship to the AppUser entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "twofactor_access_token"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"twofactor_access_token\"...)\npublic class TFAccessToken extends AbstractPersistableCustom {\n    @Column(name = \"token\", nullable = false, length = 32)\n    private String token;\n    ..."
  },
  {
    "path": "org.apache.fineract.infrastructure.security.domain.TwoFactorConfiguration",
    "mechanism": "JPA",
    "name": "TwoFactorConfiguration",
    "description": "The class is a JPA Entity mapped to the 'twofactor_configuration' table. It defines columns for 'name' and 'value' and enforces a unique constraint on the 'name' column.",
    "databaseName": "twofactor_configuration",
    "tablesAccessed": [
      "twofactor_configuration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity mapping for CRUD operations.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JPA (Jakarta Persistence)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"twofactor_configuration\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"name_UNIQUE\") })\npublic class TwoFactorConfiguration extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.sms.domain.SmsMessage",
    "mechanism": "JPA",
    "name": "SmsMessage",
    "description": "The class is a JPA Entity mapped to the 'sms_messages_outbound' table. It defines columns for message details, status, and timestamps, and Many-to-One relationships with Group, Client, Staff, and SmsCampaign entities.",
    "databaseName": "sms_messages_outbound",
    "tablesAccessed": [
      "sms_messages_outbound"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"sms_messages_outbound\")\npublic class SmsMessage extends AbstractPersistableCustom {\n    @Column(name = \"mobile_no\", length = 50)\n    private String mobileNo;\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.survey.domain.Likelihood",
    "mechanism": "JPA",
    "name": "Likelihood",
    "description": "The class is a JPA entity mapped to a relational database table. It uses standard Jakarta Persistence annotations to define the table mapping and column constraints.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ppi_likelihoods_ppi"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"ppi_likelihoods_ppi\")\npublic final class Likelihood extends AbstractPersistableCustom {\n    @Column(name = \"ppi_name\", nullable = false)\n    private String ppiName;\n    ..."
  },
  {
    "path": "org.apache.fineract.interoperation.domain.InteropIdentifier",
    "mechanism": "JPA",
    "name": "InteropIdentifier",
    "description": "The class is a JPA Entity mapped to the 'interop_identifier' table. It defines columns for account association, identifier type, value, and audit logs. It enforces unique constraints on (account_id, type) and (type, a_value, sub_value_or_type).",
    "databaseName": "interop_identifier",
    "tablesAccessed": [
      "interop_identifier"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"interop_identifier\", uniqueConstraints = {\n        @UniqueConstraint(name = \"uk_hathor_identifier_account\", columnNames = { \"account_id\", \"type\" }),...})\npublic class InteropIdentifier extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.investor.domain",
    "mechanism": "JPA",
    "name": "ExternalAssetOwnerTransferDetails",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses Jakarta Persistence annotations to define the table name, column mappings, and relationships.",
    "databaseName": "m_external_asset_owner_transfer_details",
    "tablesAccessed": [
      "m_external_asset_owner_transfer_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_external_asset_owner_transfer_details\")\npublic class ExternalAssetOwnerTransferDetails extends AbstractAuditableWithUTCDateTimeCustom {\n    @Column(name = \"total_outstanding_derived\", scale = 6, precision = 19, nullable = false)\n    private BigDecimal totalOutstanding;\n}"
  },
  {
    "path": "org.apache.fineract.investor.domain",
    "mechanism": "JPA",
    "name": "ExternalAssetOwnerJournalEntryMapping",
    "description": "The class is a JPA entity that maps directly to the 'm_external_asset_owner_journal_entry_mapping' table. It defines foreign key relationships to the 'journal_entry_id' and 'owner_id' columns.",
    "databaseName": "m_external_asset_owner_journal_entry_mapping",
    "tablesAccessed": [
      "m_external_asset_owner_journal_entry_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM entity mapping used for CRUD operations via a JPA repository.",
    "transactionHandling": "Transactions are managed by the container or Spring context wrapping the JPA operations.",
    "protocol": "JPA 3.0+ (Jakarta Persistence)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_external_asset_owner_journal_entry_mapping\")\npublic class ExternalAssetOwnerJournalEntryMapping extends AbstractAuditableWithUTCDateTimeCustom {\n    @OneToOne\n    @JoinColumn(name = \"journal_entry_id\", nullable = false)\n    private JournalEntry journalEntry;\n}"
  },
  {
    "path": "org.apache.fineract.investor.domain.ExternalAssetOwner",
    "mechanism": "JPA",
    "name": "ExternalAssetOwner",
    "description": "The class is a JPA Entity that maps directly to a database table using Jakarta Persistence annotations. It defines column mappings and constraints (unique, nullable) for the external ID.",
    "databaseName": "m_external_asset_owner",
    "tablesAccessed": [
      "m_external_asset_owner"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_external_asset_owner\")\npublic class ExternalAssetOwner extends AbstractAuditableWithUTCDateTimeCustom {\n    @Column(name = \"external_id\", nullable = false, length = 100, unique = true)\n    private ExternalId externalId;\n}"
  },
  {
    "path": "org.apache.fineract.investor.domain.ExternalAssetOwnerTransfer",
    "mechanism": "JPA",
    "name": "ExternalAssetOwnerTransfer",
    "description": "The class is a JPA Entity mapped to the `m_external_asset_owner_transfer` table. It defines the schema for storing asset owner transfer records, including foreign keys to the owner table and mapping of enum values to database columns.",
    "databaseName": "m_external_asset_owner_transfer",
    "tablesAccessed": [
      "m_external_asset_owner_transfer"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM entity mapping for CRUD operations.",
    "transactionHandling": "Transactions are typically managed by the container or Spring service layer interacting with this entity.",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_external_asset_owner_transfer\")\npublic class ExternalAssetOwnerTransfer extends AbstractAuditableWithUTCDateTimeCustom {"
  },
  {
    "path": "org.apache.fineract.investor.domain.ExternalAssetOwnerTransferJournalEntryMapping",
    "mechanism": "JPA",
    "name": "ExternalAssetOwnerTransferJournalEntryMapping",
    "description": "The class uses Jakarta Persistence (JPA) annotations to map the object directly to a relational database table. It defines foreign key relationships to the JournalEntry and ExternalAssetOwnerTransfer entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_external_asset_owner_transfer_journal_entry_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM mapping for CRUD operations.",
    "transactionHandling": "Implicitly handled by the JPA provider/container context.",
    "protocol": "JDBC/JPA",
    "connectionInfo": "configured in application properties",
    "codeExample": "@Entity\n@Table(name = \"m_external_asset_owner_transfer_journal_entry_mapping\")\npublic class ExternalAssetOwnerTransferJournalEntryMapping extends AbstractAuditableWithUTCDateTimeCustom {\n    @OneToOne\n    @JoinColumn(name = \"journal_entry_id\", nullable = false)\n    private JournalEntry journalEntry;\n}"
  },
  {
    "path": "org.apache.fineract.investor.domain.ExternalAssetOwnerTransferLoanMapping",
    "mechanism": "JPA",
    "name": "ExternalAssetOwnerTransferLoanMapping",
    "description": "The class is a JPA Entity mapped to the 'm_external_asset_owner_transfer_loan_mapping' table. It manages the persistence of loan transfer mappings using Jakarta Persistence annotations.",
    "databaseName": "m_external_asset_owner_transfer_loan_mapping",
    "tablesAccessed": [
      "m_external_asset_owner_transfer_loan_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_external_asset_owner_transfer_loan_mapping\")\npublic class ExternalAssetOwnerTransferLoanMapping extends AbstractAuditableWithUTCDateTimeCustom {\n    @Column(name = \"loan_id\", nullable = false)\n    private Long loanId;\n}"
  },
  {
    "path": "org.apache.fineract.investor.domain.ExternalIdConverter",
    "mechanism": "JPA",
    "name": "ExternalIdConverter",
    "description": "This class is a JPA AttributeConverter that handles the serialization and deserialization of the ExternalId custom type to a database column (String). It is marked with @Converter(autoApply = true), meaning it automatically intercepts database reads and writes for fields of type ExternalId across the persistence context.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Converter(autoApply = true)\npublic class ExternalIdConverter implements AttributeConverter<ExternalId, String> {\n    @Override\n    public String convertToDatabaseColumn(ExternalId externalId) {\n        return externalId != null ? externalId.getValue() : null;\n    }\n}"
  },
  {
    "path": "org.apache.fineract.investor.domain.search",
    "mechanism": "JPA",
    "name": "SearchingExternalAssetOwnerRepositoryImpl",
    "description": "The class uses the JPA Criteria API via an injected EntityManager to perform dynamic, type-safe database queries. It constructs complex joins and predicates programmatically based on user input.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransfer",
      "ExternalAssetOwnerTransferDetails",
      "ExternalAssetOwner"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic JPA Criteria queries with joins and filtering predicates.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "CriteriaBuilder cb = entityManager.getCriteriaBuilder();\nCriteriaQuery<SearchedExternalAssetOwner> query = cb.createQuery(SearchedExternalAssetOwner.class);\nRoot<ExternalAssetOwnerTransfer> root = query.from(ExternalAssetOwnerTransfer.class);"
  },
  {
    "path": "org.apache.fineract.mix.domain.MixTaxonomyMapping",
    "mechanism": "JPA",
    "name": "MixTaxonomyMapping",
    "description": "The class is a JPA Entity mapped to a relational database table using Jakarta Persistence annotations. It defines columns for identifier, config, and currency.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "mix_taxonomy_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations managed via JPA/Hibernate.",
    "transactionHandling": "JPA EntityTransaction (implied by context)",
    "protocol": "JDBC/JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"mix_taxonomy_mapping\")\npublic final class MixTaxonomyMapping extends AbstractPersistableCustom {\n    @Column(name = \"identifier\")\n    private String identifier;"
  },
  {
    "path": "org.apache.fineract.notification.domain.Notification",
    "mechanism": "JPA",
    "name": "Notification",
    "description": "The class is a JPA Entity that maps the Notification object to the relational database table 'notification_generator'. It uses Jakarta Persistence annotations to define the table mapping and column definitions for storing notification details.",
    "databaseName": "notification_generator",
    "tablesAccessed": [
      "notification_generator"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for standard CRUD operations.",
    "transactionHandling": "JPA EntityTransaction (managed by container/context)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"notification_generator\")\npublic class Notification extends AbstractPersistableCustom {\n    @Column(name = \"object_type\")\n    private String objectType;\n}"
  },
  {
    "path": "org.apache.fineract.notification.domain.NotificationMapper",
    "mechanism": "JPA",
    "name": "NotificationMapper",
    "description": "The class is a JPA Entity that maps directly to a relational database table named 'notification_mapper'. It uses Jakarta Persistence annotations to define the table mapping, column definitions, and foreign key relationships to other entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "notification_mapper"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"notification_mapper\")\npublic class NotificationMapper extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"notification_id\")\n    private Notification notification;\n}"
  },
  {
    "path": "org.apache.fineract.organisation.holiday.domain.Holiday",
    "mechanism": "JPA",
    "name": "Holiday",
    "description": "The class is a JPA Entity mapped to the 'm_holiday' table. It uses standard Jakarta Persistence annotations to define the schema, including unique constraints and column definitions. It also manages a Many-to-Many relationship with the 'Office' entity via the 'm_holiday_office' join table.",
    "databaseName": "m_holiday",
    "tablesAccessed": [
      "m_holiday",
      "m_holiday_office"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_holiday\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"holiday_name\") })\npublic class Holiday extends AbstractPersistableCustom {\n    @Column(name = \"name\", unique = true, nullable = false, length = 100)\n    private String name;\n    // ...\n    @ManyToMany(fetch = FetchType.EAGER)\n    @JoinTable(name = \"m_holiday_office\", joinColumns = @JoinColumn(name = \"holiday_id\"), inverseJoinColumns = @JoinColumn(name = \"office_id\"))\n    private Set<Office> offices;\n}"
  },
  {
    "path": "org.apache.fineract.organisation.holiday.handler",
    "mechanism": "JPA",
    "name": "HolidayWritePlatformService",
    "description": "The class manages database transactions via the Spring `@Transactional` annotation while delegating the actual data modification to the `HolidayWritePlatformService`. It ensures the delete operation is atomic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.holidayWritePlatformService.deleteHoliday(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.organisation.monetary.domain.ApplicationCurrency",
    "mechanism": "JPA",
    "name": "ApplicationCurrency",
    "description": "The class is a JPA entity mapped to the 'm_currency' database table. It uses Jakarta Persistence annotations to define the table name and column mappings for currency attributes.",
    "databaseName": "m_currency",
    "tablesAccessed": [
      "m_currency"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_currency\")\npublic class ApplicationCurrency extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.organisation.monetary.domain.MonetaryCurrency",
    "mechanism": "JPA",
    "name": "MonetaryCurrency Embeddable",
    "description": "The class is a JPA `@Embeddable` component. It does not have its own table but defines columns that are added to the tables of entities that embed it. It maps the currency code, decimal digits, and multiples-of values to specific database columns.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown (dependent on embedding entity)"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a (Embeddable definition only)",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Embeddable\npublic class MonetaryCurrency {\n    @Column(name = \"currency_code\", length = 3, nullable = false)\n    private String code;\n    @Column(name = \"currency_digits\", nullable = false)\n    private int digitsAfterDecimal;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.organisation.monetary.domain.Money",
    "mechanism": "JPA",
    "name": "Money Embeddable",
    "description": "The Money class is annotated with @Embeddable, indicating that its instances are stored as an intrinsic part of an owning entity and share the same database table. It maps its fields (currencyCode, currencyDigitsAfterDecimal, inMultiplesOf, amount) to specific columns in the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Embeddable\npublic class Money implements Comparable<Money> {\n    @Column(name = \"currency_code\", length = 3)\n    private String currencyCode;\n    @Column(name = \"amount\", scale = 6, precision = 19)\n    private BigDecimal amount;\n}"
  },
  {
    "path": "org.apache.fineract.organisation.office.domain.Office",
    "mechanism": "JPA",
    "name": "Office",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping to the 'm_office' table. It defines relationships using @ManyToOne and @OneToMany for the parent-child office structure.",
    "databaseName": "m_office",
    "tablesAccessed": [
      "m_office"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_office\"...)\npublic class Office extends AbstractPersistableCustom..."
  },
  {
    "path": "org.apache.fineract.organisation.office.domain.OfficeTransaction",
    "mechanism": "JPA",
    "name": "OfficeTransaction",
    "description": "The class is a JPA entity that maps directly to a relational database table. It uses annotations to define the table name, column mappings, and relationships (Many-to-One) with other entities.",
    "databaseName": "m_office_transaction",
    "tablesAccessed": [
      "m_office_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA / JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_office_transaction\")\npublic class OfficeTransaction extends AbstractPersistableCustom {\n    @Column(name = \"transaction_amount\", scale = 6, precision = 19, nullable = false)\n    private BigDecimal transactionAmount;"
  },
  {
    "path": "org.apache.fineract.organisation.office.domain.OrganisationCurrency",
    "mechanism": "JPA",
    "name": "OrganisationCurrency",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping directly to a relational database table. It uses @Column annotations to define column mappings for currency properties.",
    "databaseName": "m_organisation_currency",
    "tablesAccessed": [
      "m_organisation_currency"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_organisation_currency\")\npublic class OrganisationCurrency extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.domain.LoanProductProvisionCriteria",
    "mechanism": "JPA",
    "name": "LoanProductProvisionCriteria",
    "description": "The class is a JPA Entity that maps directly to a relational database table using Jakarta Persistence annotations. It defines foreign key relationships to other entities.",
    "databaseName": "m_loanproduct_provisioning_mapping",
    "tablesAccessed": [
      "m_loanproduct_provisioning_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with ManyToOne relationships",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loanproduct_provisioning_mapping\"...)\npublic class LoanProductProvisionCriteria extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.domain.ProvisioningCategory",
    "mechanism": "JPA",
    "name": "ProvisioningCategory",
    "description": "The class is a JPA Entity mapped to the 'm_provision_category' database table. It uses Jakarta Persistence annotations to define the table name, unique constraints, and column mappings.",
    "databaseName": "m_provision_category",
    "tablesAccessed": [
      "m_provision_category"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_provision_category\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"category_name\" }, name = \"category_name\") })\npublic class ProvisioningCategory extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.domain.ProvisioningCriteria",
    "mechanism": "JPA",
    "name": "ProvisioningCriteria",
    "description": "The class is a JPA Entity mapped to the 'm_provisioning_criteria' table. It manages relationships with other entities ('ProvisioningCriteriaDefinition' and 'LoanProductProvisionCriteria') using standard JPA annotations.",
    "databaseName": "m_provisioning_criteria",
    "tablesAccessed": [
      "m_provisioning_criteria",
      "m_provisioning_criteria_definition",
      "m_loan_product_provisioning_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with OneToMany relationships and CascadeType.ALL",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_provisioning_criteria\", uniqueConstraints = {\n        @UniqueConstraint(columnNames = { \"criteria_name\" }, name = \"criteria_name\") })\npublic class ProvisioningCriteria extends AbstractAuditableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.domain.ProvisioningCriteriaDefinition",
    "mechanism": "JPA",
    "name": "ProvisioningCriteriaDefinition",
    "description": "The class is a JPA Entity mapped to a relational database table. It uses annotations to define the table name, column mappings, and foreign key relationships to other entities.",
    "databaseName": "m_provisioning_criteria_definition",
    "tablesAccessed": [
      "m_provisioning_criteria_definition"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_provisioning_criteria_definition\")\npublic class ProvisioningCriteriaDefinition extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.organisation.staff.domain.Staff",
    "mechanism": "JPA",
    "name": "Staff",
    "description": "The class is a JPA Entity mapped to the 'm_staff' table. It uses standard Jakarta Persistence annotations to define the table structure, unique constraints, and relationships (Many-to-One with Office, One-to-One with Image).",
    "databaseName": "m_staff",
    "tablesAccessed": [
      "m_staff"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_staff\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"display_name\" }, name = \"display_name\") })\npublic class Staff extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.organisation.teller.domain.Cashier",
    "mechanism": "JPA",
    "name": "Cashier Entity",
    "description": "The class is a standard JPA Entity mapped to a relational database table. It uses Jakarta Persistence annotations to define the table name, column mappings, unique constraints, and relationships to other entities (Staff, Teller).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_cashiers"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with lazy loading for relationships.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_cashiers\", uniqueConstraints = {\n        @UniqueConstraint(name = \"ux_cashiers_staff_teller\", columnNames = { \"staff_id\", \"teller_id\" }) })\npublic class Cashier extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.organisation.teller.domain.CashierTransaction",
    "mechanism": "JPA",
    "name": "CashierTransaction",
    "description": "The class is a JPA entity mapped to the 'm_cashier_transactions' table using Jakarta Persistence annotations. It defines columns for transaction details and a Many-to-One relationship with the Cashier entity.",
    "databaseName": "m_cashier_transactions",
    "tablesAccessed": [
      "m_cashier_transactions"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_cashier_transactions\")\npublic class CashierTransaction extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.organisation.teller.domain.Teller",
    "mechanism": "JPA",
    "name": "Teller",
    "description": "The class is a JPA Entity mapped to the 'm_tellers' table. It uses standard Jakarta Persistence annotations to define the table structure, constraints, and relationships.",
    "databaseName": "m_tellers",
    "tablesAccessed": [
      "m_tellers"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping with lazy loading for relationships.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JPA 3.0+ (Jakarta)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_tellers\", uniqueConstraints = { @UniqueConstraint(name = \"ux_tellers_name\", columnNames = { \"name\" }) })\npublic class Teller extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.organisation.teller.domain.TellerTransaction",
    "mechanism": "JPA",
    "name": "TellerTransaction",
    "description": "This class is a JPA Entity mapped to the 'm_teller_transactions' table. It uses Jakarta Persistence annotations to define the table mapping, column constraints, and foreign key relationships to other entities like Office, Teller, and Client.",
    "databaseName": "m_teller_transactions",
    "tablesAccessed": [
      "m_teller_transactions"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity mapping for CRUD operations.",
    "transactionHandling": "Managed by the JPA provider and persistence context.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_teller_transactions\")\npublic class TellerTransaction extends AbstractPersistableCustom {\n    @Column(name = \"amount\", nullable = false)\n    private Double amount;\n}"
  },
  {
    "path": "org.apache.fineract.organisation.workingdays.domain",
    "mechanism": "JPA",
    "name": "m_working_days",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping directly to the 'm_working_days' database table. It inherits ID management from AbstractPersistableCustom.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_working_days"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping for standard CRUD operations.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_working_days\")\npublic class WorkingDays extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.account.domain",
    "mechanism": "JPA",
    "name": "AccountTransferDetails",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping Java objects to the 'm_account_transfer_details' database table. It defines relationships using @ManyToOne, @OneToMany, and @OneToOne annotations to link with other domain entities like Office, Client, Loan, and SavingsAccount.",
    "databaseName": "m_account_transfer_details",
    "tablesAccessed": [
      "m_account_transfer_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_account_transfer_details\")\npublic class AccountTransferDetails extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.account.domain.AccountAssociations",
    "mechanism": "JPA",
    "name": "AccountAssociations Entity",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses annotations to define the table name, column mappings, and foreign key relationships to other entities (Loan and SavingsAccount).",
    "databaseName": "m_portfolio_account_associations",
    "tablesAccessed": [
      "m_portfolio_account_associations"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA / JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_portfolio_account_associations\")\npublic class AccountAssociations extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.account.domain.AccountTransferStandingInstruction",
    "mechanism": "JPA",
    "name": "AccountTransferStandingInstruction",
    "description": "The class is a JPA entity mapped to the 'm_account_transfer_standing_instructions' table. It uses Jakarta Persistence annotations to define the table structure, unique constraints, and column mappings. It maintains a Many-to-One relationship with the 'AccountTransferDetails' entity.",
    "databaseName": "m_account_transfer_standing_instructions",
    "tablesAccessed": [
      "m_account_transfer_standing_instructions",
      "m_account_transfer_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "Unknown (JPA abstraction)",
    "connectionInfo": "Not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_account_transfer_standing_instructions\", uniqueConstraints = {\n        @UniqueConstraint(columnNames = { \"name\" }, name = \"name\") })\npublic class AccountTransferStandingInstruction extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.account.domain.AccountTransferTransaction",
    "mechanism": "JPA",
    "name": "AccountTransferTransaction",
    "description": "The class is a JPA Entity mapped to the 'm_account_transfer_transaction' table. It uses Jakarta Persistence annotations to define the table mapping, column definitions, and relationships with other entities.",
    "databaseName": "m_account_transfer_transaction",
    "tablesAccessed": [
      "m_account_transfer_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_account_transfer_transaction\")\n@Getter\npublic class AccountTransferTransaction extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.account.handler",
    "mechanism": "JPA",
    "name": "AccountTransfersWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions for the refund operation. While the direct database access code is not in this file, it orchestrates a write operation via the injected `AccountTransfersWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.refundByTransfer(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.address.domain",
    "mechanism": "JPA",
    "name": "FieldConfiguration",
    "description": "The class is a JPA Entity mapped to a relational database table using Jakarta Persistence annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_field_configuration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM mapping for CRUD operations.",
    "transactionHandling": "Managed by the JPA provider (likely via Spring @Transactional in the service layer).",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_field_configuration\")\npublic class FieldConfiguration extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.address.domain.Address",
    "mechanism": "JPA",
    "name": "Address Entity",
    "description": "The class is a JPA Entity mapped to the 'm_address' table. It uses Jakarta Persistence annotations to define the schema mapping, including columns, relationships (ManyToOne, OneToMany), and cascading rules.",
    "databaseName": "m_address",
    "tablesAccessed": [
      "m_address"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA/Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_address\")\npublic class Address extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.domain.Calendar",
    "mechanism": "JPA",
    "name": "Calendar Entity",
    "description": "The class is a JPA Entity annotated with @Entity and @Table(name = 'm_calendar'). It maps class fields to database columns using @Column and manages a one-to-many relationship with CalendarHistory.",
    "databaseName": "m_calendar",
    "tablesAccessed": [
      "m_calendar",
      "m_calendar_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity mapping with relationship management.",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_calendar\")\npublic class Calendar extends AbstractAuditableWithUTCDateTimeCustom {\n    @Column(name = \"title\", length = 50, nullable = false)\n    private String title;"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.domain.CalendarHistory",
    "mechanism": "JPA",
    "name": "CalendarHistory",
    "description": "The class is a JPA Entity mapped to the 'm_calendar_history' table. It uses standard Jakarta Persistence annotations to define the schema mapping, relationships (ManyToOne with Calendar), and column definitions.",
    "databaseName": "m_calendar_history",
    "tablesAccessed": [
      "m_calendar_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_calendar_history\")\npublic class CalendarHistory extends AbstractPersistableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"calendar_id\", referencedColumnName = \"id\", nullable = false)\n    private Calendar calendar;"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.domain.CalendarInstance",
    "mechanism": "JPA",
    "name": "CalendarInstance",
    "description": "The class is a JPA Entity mapped to the 'm_calendar_instance' table. It manages persistence for calendar associations using Jakarta Persistence annotations.",
    "databaseName": "m_calendar_instance",
    "tablesAccessed": [
      "m_calendar_instance"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_calendar_instance\")\npublic class CalendarInstance extends AbstractPersistableCustom {\n    @ManyToOne(cascade = CascadeType.PERSIST)\n    @JoinColumn(name = \"calendar_id\", nullable = false)\n    private Calendar calendar;"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.handler",
    "mechanism": "JPA",
    "name": "CalendarWritePlatformService",
    "description": "The class manages a database transaction via the `@Transactional` annotation and delegates the actual persistence operation (deletion) to the `CalendarWritePlatformService`. While the SQL/ORM code isn't inline, this class defines the transaction boundary for the database write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CALENDAR"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for deletion logic",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.deleteCalendar(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.charge.domain.Charge",
    "mechanism": "JPA",
    "name": "Charge",
    "description": "The class is a JPA entity mapped to the 'm_charge' table. It uses standard Jakarta Persistence annotations to define the table mapping, columns, and relationships (ManyToOne) with other entities like PaymentType, GLAccount, and TaxGroup.",
    "databaseName": "m_charge",
    "tablesAccessed": [
      "m_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "Unknown (JPA abstraction)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_charge\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"name\") })\npublic class Charge extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.charge.handler",
    "mechanism": "JPA",
    "name": "ChargeWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions for the delete operation. While it does not execute SQL directly, it orchestrates the transaction for the underlying service layer which interacts with the database.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.clientWritePlatformService.deleteCharge(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.charge.handler",
    "mechanism": "JPA",
    "name": "ChargeWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation, implying that the underlying service method `updateCharge` performs database write operations, likely via JPA or a similar ORM used in the application.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CHARGE"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.clientWritePlatformService.updateCharge(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain",
    "mechanism": "JPA",
    "name": "ClientIdentifier",
    "description": "The class is a JPA Entity mapped to the 'm_client_identifier' table. It defines relationships to other entities (Client, CodeValue) and specifies unique constraints on the database schema.",
    "databaseName": "m_client_identifier",
    "tablesAccessed": [
      "m_client_identifier"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_client_identifier\", uniqueConstraints = { ... })\npublic class ClientIdentifier extends AbstractAuditableWithUTCDateTimeCustom { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain",
    "mechanism": "JPA",
    "name": "ClientAddress",
    "description": "The class is a JPA Entity that maps to the 'm_client_address' table in the database. It uses Jakarta Persistence annotations to define the table name, columns, and relationships (Many-to-One) with other entities.",
    "databaseName": "m_client_address",
    "tablesAccessed": [
      "m_client_address"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM mapping for a join table with additional attributes.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_client_address\")\npublic class ClientAddress extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain",
    "mechanism": "JPA",
    "name": "ClientChargePaidBy",
    "description": "The class is a JPA Entity mapped to the 'm_client_charge_paid_by' table. It uses Jakarta Persistence annotations to define the table name, column mappings, and relationships. It specifically maps foreign keys to 'm_client_transaction' and 'm_client_charge' tables via @ManyToOne and @JoinColumn annotations.",
    "databaseName": "m_client_charge_paid_by",
    "tablesAccessed": [
      "m_client_charge_paid_by"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_client_charge_paid_by\")\npublic class ClientChargePaidBy extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"client_transaction_id\", nullable = false)\n    private ClientTransaction clientTransaction;\n    //..."
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.Client",
    "mechanism": "JPA",
    "name": "Client Entity",
    "description": "The class is a JPA Entity mapped to the 'm_client' table. It uses standard Jakarta Persistence annotations to define columns, relationships, and constraints.",
    "databaseName": "m_client",
    "tablesAccessed": [
      "m_client",
      "m_group_client"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with lazy loading for relationships.",
    "transactionHandling": "JPA EntityTransaction (managed by container/service layer)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_client\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"account_no\" }, name = \"account_no_UNIQUE\") })\npublic class Client extends AbstractAuditableWithUTCDateTimeCustom { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientCharge",
    "mechanism": "JPA",
    "name": "ClientCharge Entity",
    "description": "The class is a standard JPA Entity annotated with @Entity and @Table. It maps to the 'm_client_charge' table and uses @ManyToOne relationships for linking to Client and Charge entities.",
    "databaseName": "m_client_charge",
    "tablesAccessed": [
      "m_client_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA ORM mapping with derived fields and relationships.",
    "transactionHandling": "Implicitly handled by the persistence context/service layer (not visible in entity code).",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_client_charge\")\npublic class ClientCharge extends AbstractPersistableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"client_id\", referencedColumnName = \"id\", nullable = false)\n    private Client client;\n    // ..."
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientFamilyMembers",
    "mechanism": "JPA",
    "name": "ClientFamilyMembers",
    "description": "The class is a JPA entity mapped to the 'm_family_members' table. It uses Jakarta Persistence annotations to define the table mapping, column definitions, and relationships with other entities like 'Client' and 'CodeValue'.",
    "databaseName": "m_family_members",
    "tablesAccessed": [
      "m_family_members"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_family_members\")\npublic class ClientFamilyMembers extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private Client client;\n    // ..."
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientNonPerson",
    "mechanism": "JPA",
    "name": "ClientNonPerson",
    "description": "The class is a JPA entity mapped to the 'm_client_non_person' table. It uses standard Jakarta Persistence annotations to define the table mapping, column constraints, and relationships (OneToOne with Client, ManyToOne with CodeValue).",
    "databaseName": "m_client_non_person",
    "tablesAccessed": [
      "m_client_non_person"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "Unknown (JPA abstraction)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_client_non_person\")\npublic class ClientNonPerson extends AbstractPersistableCustom {\n    @OneToOne(optional = false)\n    @JoinColumn(name = \"client_id\", referencedColumnName = \"id\", nullable = false, unique = true)\n    private Client client;\n    ..."
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientTransaction",
    "mechanism": "JPA",
    "name": "ClientTransaction",
    "description": "The class is a JPA Entity mapped to the 'm_client_transaction' table. It uses Jakarta Persistence annotations to define the schema mapping, including column definitions, unique constraints, and relationships with other entities (Client, Office, PaymentDetail).",
    "databaseName": "m_client_transaction",
    "tablesAccessed": [
      "m_client_transaction",
      "m_client",
      "m_office",
      "m_payment_detail",
      "m_client_charge_paid_by"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with standard relationships (ManyToOne, OneToMany).",
    "transactionHandling": "JPA EntityTransaction (implicit in usage context)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_client_transaction\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"external_id\" }, name = \"external_id\") })\npublic class ClientTransaction extends AbstractAuditableWithUTCDateTimeCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"client_id\", nullable = false)\n    private Client client;"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientTransferDetails",
    "mechanism": "JPA",
    "name": "ClientTransferDetails",
    "description": "The class is a JPA Entity mapped to the relational database table 'm_client_transfer_details'. It defines the schema mapping for client transfer records using annotations.",
    "databaseName": "m_client_transfer_details",
    "tablesAccessed": [
      "m_client_transfer_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_client_transfer_details\")\npublic class ClientTransferDetails extends AbstractPersistableCustom {\n    @Column(name = \"client_id\", length = 20, unique = true, nullable = false)\n    private Long clientId;"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.search",
    "mechanism": "JPA",
    "name": "SearchingClientRepositoryImpl",
    "description": "The class interacts with the database using the Jakarta Persistence API (JPA) Criteria API via an injected EntityManager. It dynamically constructs SQL queries to retrieve client data based on search criteria.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Client",
      "Office"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic criteria query with joins, filtering (LIKE, OR, AND), and DTO projection",
    "transactionHandling": "unknown",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "CriteriaBuilder cb = entityManager.getCriteriaBuilder();\nCriteriaQuery<SearchedClient> query = cb.createQuery(SearchedClient.class);\nRoot<Client> root = query.from(Client.class);\n// ... predicates ...\nTypedQuery<SearchedClient> queryToExecute = entityManager.createQuery(query);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.handler.UndoClientTransactionCommandHandler",
    "mechanism": "JPA",
    "name": "ClientTransactionWritePlatformService",
    "description": "The class uses Spring's @Transactional annotation to manage database transactions. While it does not execute SQL or JPQL directly, it defines the transaction boundary for the 'undo' operation delegated to the service layer.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.undo(command.getClientId(), command.entityId());\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service",
    "mechanism": "JPA",
    "name": "ClientTransactionReadPlatformService",
    "description": "The interface uses Spring's @Transactional annotation, indicating that its implementations interact with a database within a transaction context. While the implementation details (JDBC vs JPA) are not visible in the interface, the return of a domain entity (ClientTransaction) in one method and the transactional nature implies database interaction.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientTransaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional(readOnly = true)\nPage<ClientTransactionData> retrieveAllTransactions(Long clientId, SearchParameters parameters);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service.ClientWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "JPA",
    "name": "ClientRepositoryWrapper",
    "description": "The class uses Spring Data JPA repositories wrapped in service wrappers (e.g., ClientRepositoryWrapper, ClientNonPersonRepositoryWrapper) to perform CRUD operations. It uses standard JPA entity management including saveAndFlush, delete, and findOne.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client",
      "m_client_non_person",
      "m_note",
      "m_group",
      "m_staff",
      "m_office",
      "m_savings_account",
      "m_loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, delete, findById) with some custom finders in the wrappers.",
    "transactionHandling": "Spring @Transactional annotations on the class and methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.clientRepository.saveAndFlush(newClient);"
  },
  {
    "path": "org.apache.fineract.portfolio.collateral.domain.LoanCollateral",
    "mechanism": "JPA",
    "name": "LoanCollateral",
    "description": "The class is a JPA Entity mapped to the 'm_loan_collateral' database table. It uses annotations to define column mappings, relationships (ManyToOne with Loan and CodeValue), and constraints.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_collateral"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_loan_collateral\")\npublic class LoanCollateral extends AbstractPersistableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"loan_id\", nullable = false)\n    private Loan loan;\n    ..."
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.domain",
    "mechanism": "JPA",
    "name": "CollateralManagementDomain",
    "description": "The class is a standard JPA Entity mapped to a relational database table. It uses Jakarta Persistence annotations to define the table name, column mappings, and relationships.",
    "databaseName": "m_collateral_management",
    "tablesAccessed": [
      "m_collateral_management"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for standard CRUD operations.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_collateral_management\")\npublic class CollateralManagementDomain extends AbstractPersistableCustom {\n    @Column(name = \"base_price\", nullable = false, scale = 5, precision = 20)\n    private BigDecimal basePrice;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.domain.ClientCollateralManagement",
    "mechanism": "JPA",
    "name": "ClientCollateralManagement",
    "description": "The class is a JPA entity mapped to the 'm_client_collateral_management' table. It uses standard Jakarta Persistence annotations to define the table mapping, column constraints, and relationships with other entities (Client, CollateralManagementDomain, LoanCollateralManagement).",
    "databaseName": "m_client_collateral_management",
    "tablesAccessed": [
      "m_client_collateral_management"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM entity mapping with relationships",
    "transactionHandling": "JPA EntityTransaction (implicit via container)",
    "protocol": "JPA 3.0 / Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_client_collateral_management\")\npublic class ClientCollateralManagement extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.handler",
    "mechanism": "JPA",
    "name": "CollateralManagementWritePlatformService",
    "description": "The class defines a transaction boundary using the @Transactional annotation, implying interaction with a transactional resource (likely a database) via the delegated service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "COLLATERAL_PRODUCT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Jakarta @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand jsonCommand) {\n    return this.collateralManagementWritePlatformService.createCollateral(jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.handler",
    "mechanism": "JPA",
    "name": "CollateralManagementWritePlatformService",
    "description": "The class defines transaction boundaries using the @Transactional annotation, ensuring that the database operations performed by the invoked service are atomic. While it does not execute SQL directly, it orchestrates the transaction for the persistence layer.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "COLLATERAL_PRODUCT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Jakarta @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.collateralManagementWritePlatformService.updateCollateral(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.handler",
    "mechanism": "JPA",
    "name": "CollateralManagementWritePlatformService",
    "description": "The class manages database transactions using the @Transactional annotation while delegating the actual persistence operations to the CollateralManagementWritePlatformService. It ensures that the delete operation performed by the service is committed or rolled back atomically.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "COLLATERAL_PRODUCT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for deletion logic",
    "transactionHandling": "Jakarta @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand command) {\n    return this.collateralManagementWritePlatformService.deleteCollateral(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.handler",
    "mechanism": "JPA",
    "name": "ClientCollateralManagementWritePlatformService",
    "description": "The class defines a transaction boundary using the `@Transactional` annotation, ensuring that the underlying service operation to add a collateral product is executed within a database transaction.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CLIENT_COLLATERAL_PRODUCT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Jakarta @Transactional annotation managed by Spring",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand jsonCommand) {\n    return this.clientCollateralManagementWritePlatformService.addClientCollateralProduct(jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.handler",
    "mechanism": "JPA",
    "name": "ClientCollateralManagementWritePlatformService",
    "description": "The class defines a transactional boundary using the @Transactional annotation, implying interaction with a database via the injected service. While the SQL or ORM logic is not present in this file, this handler manages the transaction lifecycle for the database write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Jakarta @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand jsonCommand) {"
  },
  {
    "path": "org.apache.fineract.portfolio.collectionsheet.service.CollectionSheetWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "JPA",
    "name": "CollectionSheetWritePlatformService",
    "description": "This class functions as a service layer implementation (suffixed JpaRepositoryImpl) that orchestrates database writes. While it does not contain direct EntityManager calls or SQL queries itself, it delegates to other services (LoanWritePlatformService, PaymentDetailWritePlatformService, etc.) that persist entities (PaymentDetail, SavingsAccountTransaction, Loan) using JPA/Spring Data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PaymentDetail",
      "SavingsAccountTransaction",
      "Loan",
      "Meeting"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Orchestration of multiple entity updates (Loans, Savings, Payments) within a single logical transaction.",
    "transactionHandling": "Likely handled by Spring @Transactional at the interface level or within the delegated services (not explicitly visible in this file but implied by the 'Service' stereotype and 'JpaRepositoryImpl' naming convention).",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final PaymentDetail paymentDetail = this.paymentDetailWritePlatformService.createAndPersistPaymentDetail(command, changes);"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.domain.DelinquencyBucket",
    "mechanism": "JPA",
    "name": "DelinquencyBucket Entity",
    "description": "This class is a JPA Entity that maps directly to the relational database table 'm_delinquency_bucket'. It defines column mappings, unique constraints, and relationships to other entities.",
    "databaseName": "m_delinquency_bucket",
    "tablesAccessed": [
      "m_delinquency_bucket",
      "m_delinquency_bucket_mappings",
      "DelinquencyRange"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA / JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_delinquency_bucket\", uniqueConstraints = {\n        @UniqueConstraint(name = \"uq_delinquency_bucket_name\", columnNames = { \"name\" }) })\npublic class DelinquencyBucket extends AbstractAuditableWithUTCDateTimeCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.domain.DelinquencyBucketMappings",
    "mechanism": "JPA",
    "name": "DelinquencyBucketMappings",
    "description": "This class is a JPA Entity that maps to the relational database table 'm_delinquency_bucket_mappings'. It handles the persistence of the relationship between delinquency buckets and ranges.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_delinquency_bucket_mappings"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_delinquency_bucket_mappings\"...)\npublic class DelinquencyBucketMappings extends AbstractAuditableWithUTCDateTimeCustom { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.domain.DelinquencyRange",
    "mechanism": "JPA",
    "name": "DelinquencyRange",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses standard Jakarta Persistence annotations to define the table name, column mappings, and constraints.",
    "databaseName": "m_delinquency_range",
    "tablesAccessed": [
      "m_delinquency_range"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA 3.0+",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_delinquency_range\", uniqueConstraints = {\n        @UniqueConstraint(name = \"uq_delinquency_range_classification\", columnNames = { \"classification\" }) })\npublic class DelinquencyRange extends AbstractAuditableWithUTCDateTimeCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.domain.LoanDelinquencyTagHistory",
    "mechanism": "JPA",
    "name": "LoanDelinquencyTagHistory",
    "description": "The class is a JPA Entity mapped to the 'm_loan_delinquency_tag_history' table. It uses Jakarta Persistence annotations to define the schema mapping and relationships.",
    "databaseName": "m_loan_delinquency_tag_history",
    "tablesAccessed": [
      "m_loan_delinquency_tag_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for CRUD operations",
    "transactionHandling": "JPA EntityTransaction (managed by container/context)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_loan_delinquency_tag_history\")\npublic class LoanDelinquencyTagHistory extends AbstractAuditableWithUTCDateTimeCustom {\n    @ManyToOne\n    @JoinColumn(name = \"delinquency_range_id\", nullable = false)\n    private DelinquencyRange delinquencyRange;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.handler",
    "mechanism": "JPA",
    "name": "DelinquencyWritePlatformService",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL or JPA queries directly, it orchestrates the transaction for the `DelinquencyWritePlatformService` which performs the actual database writes.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DELINQUENCY_RANGE"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.createDelinquencyRange(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.handler",
    "mechanism": "JPA",
    "name": "DelinquencyWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions. While it does not execute SQL directly, it delegates to `DelinquencyWritePlatformService`, which performs the data persistence operations related to loan delinquency.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for updates",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.applyDelinquencyTagToLoan(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.service.LoanDelinquencyDomainServiceImpl",
    "mechanism": "JPA",
    "name": "LoanDelinquencyDomainService",
    "description": "The class uses Spring's @Transactional annotation to manage database transactions. While it does not contain direct SQL or Repository calls, it operates on JPA Entities (Loan, LoanRepaymentScheduleInstallment, LoanTransaction). Accessing collections on these entities (e.g., loan.getRepaymentScheduleInstallments()) triggers lazy loading of related database records within the transaction scope.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan",
      "LoanRepaymentScheduleInstallment",
      "LoanTransaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Traverses entity graph relationships (One-to-Many) which likely triggers Hibernate lazy-loading SQL selects.",
    "transactionHandling": "Spring @Transactional(readOnly = true)",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Override\n@Transactional(readOnly = true)\npublic CollectionData getOverdueCollectionData(final Loan loan) {\n    // ...\n    // Accessing lazy-loaded collection triggers DB read\n    for (LoanRepaymentScheduleInstallment installment : loan.getRepaymentScheduleInstallments()) {\n       // ...\n    }\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.floatingrates.domain.FloatingRate",
    "mechanism": "JPA",
    "name": "FloatingRate",
    "description": "The class is a JPA Entity mapped to the 'm_floating_rates' table. It uses standard Jakarta Persistence annotations for ORM mapping.",
    "databaseName": "m_floating_rates",
    "tablesAccessed": [
      "m_floating_rates"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity mapping with OneToMany relationship.",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_floating_rates\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"unq_name\") })\npublic class FloatingRate extends AbstractAuditableWithUTCDateTimeCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.floatingrates.domain.FloatingRatePeriod",
    "mechanism": "JPA",
    "name": "FloatingRatePeriod",
    "description": "The class is a JPA Entity mapped to the 'm_floating_rates_periods' table. It uses standard Jakarta Persistence annotations to define the table mapping, column constraints (precision, scale, nullability), and relationships (ManyToOne to FloatingRate).",
    "databaseName": "m_floating_rates_periods",
    "tablesAccessed": [
      "m_floating_rates_periods"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_floating_rates_periods\")\npublic class FloatingRatePeriod extends AbstractAuditableWithUTCDateTimeCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.fund.domain.Fund",
    "mechanism": "JPA",
    "name": "Fund",
    "description": "The class is a JPA Entity mapped to the 'm_fund' table using Jakarta Persistence annotations. It defines columns and unique constraints for data persistence.",
    "databaseName": "m_fund",
    "tablesAccessed": [
      "m_fund"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM mapping for CRUD operations.",
    "transactionHandling": "Relies on the container or service layer to manage transactions via the EntityManager.",
    "protocol": "JPA (Jakarta Persistence)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_fund\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"fund_name_org\") })\npublic class Fund extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.group.domain.Group",
    "mechanism": "JPA",
    "name": "Group Entity",
    "description": "The class is a JPA entity mapped to the 'm_group' table. It uses standard Jakarta Persistence annotations to define columns, relationships (OneToMany, ManyToOne, ManyToMany), and join tables.",
    "databaseName": "m_group",
    "tablesAccessed": [
      "m_group",
      "m_group_client",
      "m_staff_assignment_history",
      "m_group_roles"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM entity mapping with lazy and eager fetching strategies.",
    "transactionHandling": "JPA EntityTransaction (implicit via container or service layer)",
    "protocol": "JPA/JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_group\")\npublic final class Group extends AbstractPersistableCustom {\n    @Column(name = \"external_id\", length = 100, unique = true)\n    private String externalId;\n    @ManyToMany\n    @JoinTable(name = \"m_group_client\", joinColumns = @JoinColumn(name = \"group_id\"), inverseJoinColumns = @JoinColumn(name = \"client_id\"))\n    private Set<Client> clientMembers = new HashSet<>();\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.group.domain.GroupLevel",
    "mechanism": "JPA",
    "name": "GroupLevel",
    "description": "The class is a JPA Entity mapped to the 'm_group_level' table. It uses standard Jakarta Persistence annotations to define the table name and column mappings.",
    "databaseName": "m_group_level",
    "tablesAccessed": [
      "m_group_level"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_group_level\")\npublic class GroupLevel extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.group.domain.GroupRole",
    "mechanism": "JPA",
    "name": "GroupRole",
    "description": "The class is a JPA Entity mapped to the 'm_group_roles' table. It uses annotations to define the table name and relationships (ManyToOne) with other entities (Group, Client, CodeValue).",
    "databaseName": "m_group_roles",
    "tablesAccessed": [
      "m_group_roles"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_group_roles\")\npublic class GroupRole extends AbstractPersistableCustom {\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"group_id\")\n    private Group group;"
  },
  {
    "path": "org.apache.fineract.portfolio.group.domain.StaffAssignmentHistory",
    "mechanism": "JPA",
    "name": "StaffAssignmentHistory",
    "description": "The class is a JPA Entity that maps directly to the 'm_staff_assignment_history' table. It uses standard Jakarta Persistence annotations to define the table mapping, column definitions, and relationships (ManyToOne) with other entities.",
    "databaseName": "m_staff_assignment_history",
    "tablesAccessed": [
      "m_staff_assignment_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_staff_assignment_history\")\npublic class StaffAssignmentHistory extends AbstractAuditableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"centre_id\", nullable = true)\n    private Group center;"
  },
  {
    "path": "org.apache.fineract.portfolio.group.handler",
    "mechanism": "JPA",
    "name": "GroupingTypesWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL directly, it manages the transaction for the underlying service (`GroupingTypesWritePlatformService`) which performs the actual database persistence (likely via JPA/Hibernate).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_group"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for update operations",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.groupWritePlatformService.updateCenter(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.group.handler.UnassignRoleCommandHandler",
    "mechanism": "JPA",
    "name": "GroupRolesWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL directly, it orchestrates a write operation (delete) delegated to the `GroupRolesWritePlatformService`, which interacts with the persistence layer (likely JPA/Hibernate repositories).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for deletion",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Override\n@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.groupRolesWritePlatformService.deleteRole(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.domain",
    "mechanism": "JPA",
    "name": "InterestRateChartFields",
    "description": "The class is a JPA Embeddable component. It defines the schema for columns that will be embedded in the table of the parent entity using @Column annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings via annotations",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Embeddable\npublic class InterestRateChartFields {\n    @Column(name = \"name\", length = 100, unique = false, nullable = false)\n    private String name;\n    // ..."
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.domain",
    "mechanism": "JPA",
    "name": "InterestRateChartSlabFields",
    "description": "This class is an Embeddable JPA component. It does not correspond to a standalone table but defines a set of columns that are embedded into the table of the parent entity (likely InterestRateChartSlab). It uses standard Jakarta Persistence annotations to define column properties such as name, precision, scale, and nullability.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Embeddable\npublic class InterestRateChartSlabFields {\n    @Column(name = \"description\", nullable = true)\n    private String description;\n\n    @Column(name = \"annual_interest_rate\", scale = 6, precision = 19, nullable = false)\n    private BigDecimal annualInterestRate;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.domain.InterestIncentives",
    "mechanism": "JPA",
    "name": "InterestIncentives",
    "description": "The class is a JPA entity mapped to the 'm_interest_incentives' table. It uses annotations to define the table mapping, relationships (ManyToOne), and embedded fields.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_interest_incentives"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_interest_incentives\")\npublic class InterestIncentives extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"interest_rate_slab_id\", nullable = false)\n    private InterestRateChartSlab interestRateChartSlab;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.domain.InterestIncentivesFields",
    "mechanism": "JPA",
    "name": "InterestIncentivesFields",
    "description": "The class is an `@Embeddable` component used to map a set of related fields to database columns within a parent entity. It defines column mappings for incentive details.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Embeddable\npublic class InterestIncentivesFields {\n    @Column(name = \"entiry_type\", nullable = false)\n    private Integer entityType;\n    @Column(name = \"attribute_name\", nullable = false)\n    private Integer attributeName;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.domain.InterestRateChart",
    "mechanism": "JPA",
    "name": "InterestRateChart Entity",
    "description": "The class is a standard JPA Entity mapped to a relational database table. It uses Jakarta Persistence annotations to define the mapping, including embedded fields and one-to-many relationships.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_interest_rate_chart"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with One-To-Many relationship fetching",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC/JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_interest_rate_chart\")\npublic class InterestRateChart extends AbstractPersistableCustom {\n    @Embedded\n    private InterestRateChartFields chartFields;\n    @OneToMany(mappedBy = \"interestRateChart\", cascade = CascadeType.ALL...)\n    private Set<InterestRateChartSlab> chartSlabs..."
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.domain.InterestRateChartSlab",
    "mechanism": "JPA",
    "name": "InterestRateChartSlab Entity",
    "description": "The class is a JPA entity mapped to the 'm_interest_rate_slab' table. It uses standard Jakarta Persistence annotations to define the table mapping, embedded fields, and relationships with other entities.",
    "databaseName": "m_interest_rate_slab",
    "tablesAccessed": [
      "m_interest_rate_slab"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with One-to-Many and Many-to-One relationships.",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA / JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_interest_rate_slab\")\npublic class InterestRateChartSlab extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "JPA",
    "name": "LoanOfficerAssignmentHistory",
    "description": "The class is a JPA Entity mapped to the 'm_loan_officer_assignment_history' table. It uses standard Jakarta Persistence annotations to define the table mapping and relationships (ManyToOne) with Loan and Staff entities.",
    "databaseName": "m_loan_officer_assignment_history",
    "tablesAccessed": [
      "m_loan_officer_assignment_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_officer_assignment_history\")\npublic class LoanOfficerAssignmentHistory extends AbstractAuditableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"loan_id\", nullable = false)\n    private Loan loan;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "JPA",
    "name": "LoanRescheduleRequestToTermVariationMapping",
    "description": "The class is a JPA entity that maps directly to a database table used for linking two other entities. It defines foreign key relationships via annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_reschedule_request_term_variations_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for a join table.",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_loan_reschedule_request_term_variations_mapping\")\npublic class LoanRescheduleRequestToTermVariationMapping..."
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "JPA",
    "name": "LoanPaymentAllocationRule",
    "description": "The class is a JPA entity mapped to the 'm_loan_payment_allocation_rule' table. It defines a unique constraint on the combination of 'loan_id' and 'transaction_type'. It uses a custom converter (AllocationTypeListConverter) to handle the persistence of the 'allocationTypes' list and standard enumerations for transaction and rule types.",
    "databaseName": "m_loan_payment_allocation_rule",
    "tablesAccessed": [
      "m_loan_payment_allocation_rule"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA / JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_payment_allocation_rule\", uniqueConstraints = {\n        @UniqueConstraint(columnNames = { \"loan_id\", \"transaction_type\" }, name = \"uq_m_loan_payment_allocation_rule\") })\npublic class LoanPaymentAllocationRule extends AbstractAuditableWithUTCDateTimeCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "JPA",
    "name": "Loan Persistence",
    "description": "The interface defines methods that explicitly handle the persistence of Loan and LoanTransaction entities. Methods like 'saveAndFlushLoanWithDataIntegrityViolationChecks' and 'saveLoanWithDataIntegrityViolationChecks' indicate that the implementation of this service is responsible for interacting with the database to save state changes, likely wrapping JPA repository calls with additional validation logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan",
      "LoanTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM entity persistence and flushing",
    "transactionHandling": "Likely Spring @Transactional in implementation",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "Loan saveAndFlushLoanWithDataIntegrityViolationChecks(Loan loan);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "JPA",
    "name": "LoanTransactionToRepaymentScheduleMapping",
    "description": "The class is a JPA Entity that maps to the 'm_loan_transaction_repayment_schedule_mapping' database table. It uses standard Jakarta Persistence annotations to define the table name, column mappings, and relationships (ManyToOne) to other entities.",
    "databaseName": "m_loan_transaction_repayment_schedule_mapping",
    "tablesAccessed": [
      "m_loan_transaction_repayment_schedule_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_transaction_repayment_schedule_mapping\")\npublic class LoanTransactionToRepaymentScheduleMapping extends AbstractPersistableCustom {\n    @ManyToOne(optional = false, cascade = CascadeType.PERSIST)\n    @JoinColumn(name = \"loan_transaction_id\", nullable = false)\n    private LoanTransaction loanTransaction;\n    // ..."
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "JPA",
    "name": "LoanTransactionRelation",
    "description": "The class is a JPA Entity mapped to the 'm_loan_transaction_relation' table. It manages foreign key relationships to the 'm_loan_transaction' table (via 'from_loan_transaction_id' and 'to_loan_transaction_id') and the 'm_loan_charge' table (via 'to_loan_charge_id').",
    "databaseName": "m_loan_transaction_relation",
    "tablesAccessed": [
      "m_loan_transaction_relation",
      "m_loan_transaction",
      "m_loan_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_transaction_relation\")\npublic class LoanTransactionRelation extends AbstractAuditableWithUTCDateTimeCustom {\n    @ManyToOne\n    @JoinColumn(name = \"from_loan_transaction_id\", nullable = false)\n    private LoanTransaction fromTransaction;"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "JPA",
    "name": "LoanCollateralManagement",
    "description": "The class is a JPA Entity mapped to the 'm_loan_collateral_management' table. It uses Jakarta Persistence annotations to define the table mapping, column constraints (precision, scale, nullability), and relationships (ManyToOne) with other entities.",
    "databaseName": "m_loan_collateral_management",
    "tablesAccessed": [
      "m_loan_collateral_management"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA/Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_collateral_management\")\npublic class LoanCollateralManagement extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "JPA",
    "name": "GroupLoanIndividualMonitoringAccount",
    "description": "The class is a JPA Entity that maps to the 'glim_accounts' table. It defines the schema structure including columns for account details and relationships to Group and Loan entities.",
    "databaseName": "glim_accounts",
    "tablesAccessed": [
      "glim_accounts"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"glim_accounts\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"account_number\" }, name = \"FK_glim_id\") })\npublic class GroupLoanIndividualMonitoringAccount extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "JPA",
    "name": "LoanTransaction",
    "description": "The class is a JPA Entity mapped to the 'm_loan_transaction' table. It uses standard Jakarta Persistence annotations to define the mapping, including relationships to other entities like 'Loan' and 'Office'.",
    "databaseName": "m_loan_transaction",
    "tablesAccessed": [
      "m_loan_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_loan_transaction\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"external_id\" }, name = \"external_id_UNIQUE\") })\npublic class LoanTransaction extends AbstractAuditableWithUTCDateTimeCustom {\n\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"loan_id\", nullable = false)\n    private Loan loan;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "JPA",
    "name": "LoanInterestRecalcualtionAdditionalDetails",
    "description": "The class is a JPA entity mapped to the database table 'm_loan_interest_recalculation_additional_details'. It uses Jakarta Persistence annotations to define the table name, column mappings (including precision and scale for the amount), and a Many-to-One relationship with the LoanRepaymentScheduleInstallment entity via a foreign key column.",
    "databaseName": "m_loan_interest_recalculation_additional_details",
    "tablesAccessed": [
      "m_loan_interest_recalculation_additional_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_loan_interest_recalculation_additional_details\")\npublic class LoanInterestRecalcualtionAdditionalDetails extends AbstractPersistableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"loan_repayment_schedule_id\", nullable = false)\n    private LoanRepaymentScheduleInstallment loanRepaymentScheduleInstallment;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.Loan",
    "mechanism": "JPA",
    "name": "Loan Entity",
    "description": "The class is a JPA Entity mapped to the 'm_loan' table. It uses standard Jakarta Persistence annotations to define the mapping of fields to database columns and relationships to other entities (Client, Group, LoanProduct, etc.).",
    "databaseName": "m_loan",
    "tablesAccessed": [
      "m_loan",
      "m_loan_rate",
      "m_loan_charge",
      "m_loan_collateral",
      "m_loan_collateral_management",
      "m_loan_officer_assignment_history",
      "m_loan_repayment_schedule",
      "m_loan_transaction",
      "m_loan_disbursement_detail",
      "m_loan_term_variations",
      "m_loan_interest_recalculation_details",
      "m_loan_topup_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM-based CRUD operations managed by the persistence context.",
    "transactionHandling": "JPA EntityTransaction (managed by the container/service layer)",
    "protocol": "JDBC (via Hibernate/JPA)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"account_no\" }, name = \"loan_account_no_UNIQUE\"),\n        @UniqueConstraint(columnNames = { \"external_id\" }, name = \"loan_externalid_UNIQUE\") })\npublic class Loan extends AbstractAuditableWithUTCDateTimeCustom {\n    @Column(name = \"account_no\", length = 20, unique = true, nullable = false)\n    private String accountNumber;\n    ..."
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanAccountDomainServiceJpa",
    "mechanism": "JPA",
    "name": "LoanRepositoryWrapper, LoanTransactionRepository",
    "description": "The class uses Spring Data JPA repositories (and wrapper services around them) to persist `Loan`, `LoanTransaction`, `Note`, and other related entities. It relies on `@Transactional` annotations to manage database transactions.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_loan_transaction",
      "m_note",
      "m_holiday",
      "m_working_days",
      "m_account_transfer_transaction",
      "m_standing_instruction",
      "m_post_dated_checks",
      "m_loan_collateral_management"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "CRUD operations via repositories, with some complex object graph traversals handled by Hibernate.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.loanTransactionRepository.saveAndFlush(newRepaymentTransaction);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanCharge",
    "mechanism": "JPA",
    "name": "LoanCharge Entity",
    "description": "The class is a JPA Entity mapped to the 'm_loan_charge' table. It uses standard Jakarta Persistence annotations to define the table structure, columns, and relationships (ManyToOne with Loan and Charge, OneToMany with LoanInstallmentCharge).",
    "databaseName": "m_loan_charge",
    "tablesAccessed": [
      "m_loan_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "Unknown (JPA abstraction)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_charge\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"external_id\" }, name = \"external_id\") })\npublic class LoanCharge extends AbstractAuditableWithUTCDateTimeCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"loan_id\", referencedColumnName = \"id\", nullable = false)\n    private Loan loan;\n    ..."
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanChargePaidBy",
    "mechanism": "JPA",
    "name": "LoanChargePaidBy",
    "description": "The class is a JPA entity mapped to the 'm_loan_charge_paid_by' table. It uses Jakarta Persistence annotations to define the table mapping, column constraints (precision, scale, nullability), and foreign key relationships to the 'm_loan_transaction' and 'm_loan_charge' tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_charge_paid_by"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_charge_paid_by\")\npublic class LoanChargePaidBy extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanDisbursementDetails",
    "mechanism": "JPA",
    "name": "LoanDisbursementDetails",
    "description": "The class is a JPA Entity mapped to the 'm_loan_disbursement_detail' table. It uses standard Jakarta Persistence annotations to define the table mapping, column definitions (precision, scale), and relationships (ManyToOne to Loan).",
    "databaseName": "m_loan_disbursement_detail",
    "tablesAccessed": [
      "m_loan_disbursement_detail"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_loan_disbursement_detail\")\npublic class LoanDisbursementDetails extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"loan_id\", nullable = false)\n    private Loan loan;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanInstallmentCharge",
    "mechanism": "JPA",
    "name": "LoanInstallmentCharge Entity",
    "description": "The class is a JPA Entity mapped to the 'm_loan_installment_charge' table. It defines the schema for storing loan installment charges, including columns for amounts (amount, paid, waived, written off, outstanding) and relationships to the 'm_loan_charge' and 'm_loan_repayment_schedule' tables via ManyToOne associations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_installment_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_loan_installment_charge\")\npublic class LoanInstallmentCharge extends AbstractPersistableCustom implements Comparable<LoanInstallmentCharge> {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"loan_charge_id\", referencedColumnName = \"id\", nullable = false)\n    private LoanCharge loancharge;"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanInterestRecalculationDetails",
    "mechanism": "JPA",
    "name": "LoanInterestRecalculationDetails",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping directly to the 'm_loan_recalculation_details' table. It uses standard JPA annotations for column mapping and relationships.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_recalculation_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM entity mapping without explicit queries in this file.",
    "transactionHandling": "Implicitly handled by the JPA provider/container (likely Spring @Transactional in service layer).",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_recalculation_details\")\npublic class LoanInterestRecalculationDetails extends AbstractPersistableCustom {\n    @OneToOne\n    @JoinColumn(name = \"loan_id\", nullable = false)\n    private Loan loan;\n    ..."
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanOverdueInstallmentCharge",
    "mechanism": "JPA",
    "name": "LoanOverdueInstallmentCharge",
    "description": "The class is a JPA entity mapped to the 'm_loan_overdue_installment_charge' table using Jakarta Persistence annotations.",
    "databaseName": "m_loan_overdue_installment_charge",
    "tablesAccessed": [
      "m_loan_overdue_installment_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM entity mapping for CRUD operations.",
    "transactionHandling": "Implicitly handled by the JPA provider and container transaction management.",
    "protocol": "JDBC (via JPA)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_overdue_installment_charge\")\npublic class LoanOverdueInstallmentCharge extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanRepaymentScheduleInstallment",
    "mechanism": "JPA",
    "name": "LoanRepaymentScheduleInstallment Entity",
    "description": "The class is a standard JPA Entity annotated with @Entity and @Table(name = 'm_loan_repayment_schedule'). It maps class fields to database columns using @Column. It uses @ManyToOne for the relationship to the Loan table and @OneToMany for child collections like installment charges.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_repayment_schedule"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with standard CRUD operations managed by the persistence context.",
    "transactionHandling": "JPA EntityTransaction (implicit via framework usage)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_loan_repayment_schedule\")\npublic class LoanRepaymentScheduleInstallment ... {\n    @Column(name = \"principal_amount\", scale = 6, precision = 19, nullable = true)\n    private BigDecimal principal;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanSummary",
    "mechanism": "JPA",
    "name": "LoanSummary",
    "description": "The class is an @Embeddable JPA component. Its fields are mapped to database columns in the table of the owning entity (likely the Loan table) using @Column annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping of embedded fields",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Column(name = \"principal_disbursed_derived\", scale = 6, precision = 19)\nprivate BigDecimal totalPrincipalDisbursed;"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanTermVariations",
    "mechanism": "JPA",
    "name": "LoanTermVariations",
    "description": "The class is a JPA entity mapped to the 'm_loan_term_variations' table using Jakarta Persistence annotations. It defines columns for term details and relationships to the Loan entity.",
    "databaseName": "m_loan_term_variations",
    "tablesAccessed": [
      "m_loan_term_variations"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_term_variations\")\npublic class LoanTermVariations extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanTopupDetails",
    "mechanism": "JPA",
    "name": "LoanTopupDetails",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses Jakarta Persistence annotations to define the schema mapping, including table name, column definitions, and foreign key relationships.",
    "databaseName": "m_loan_topup",
    "tablesAccessed": [
      "m_loan_topup"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_loan_topup\")\npublic class LoanTopupDetails extends AbstractPersistableCustom {\n    @OneToOne\n    @JoinColumn(name = \"loan_id\", nullable = false)\n    private Loan loan;"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanTrancheCharge",
    "mechanism": "JPA",
    "name": "LoanTrancheCharge",
    "description": "The class is a JPA entity mapped to the 'm_loan_tranche_charges' table. It uses Jakarta Persistence annotations to define the schema mapping and relationships.",
    "databaseName": "m_loan_tranche_charges",
    "tablesAccessed": [
      "m_loan_tranche_charges"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM mappings for CRUD operations managed by the persistence provider.",
    "transactionHandling": "Transactions are managed implicitly by the JPA EntityTransaction or Spring container context.",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_tranche_charges\")\npublic class LoanTrancheCharge extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanTrancheDisbursementCharge",
    "mechanism": "JPA",
    "name": "LoanTrancheDisbursementCharge",
    "description": "The class is a JPA Entity mapped to the 'm_loan_tranche_disbursement_charge' table. It uses Jakarta Persistence annotations to define the table name and column mappings. It establishes foreign key relationships to the 'm_loan_charge' table (via 'loan_charge_id') and the 'm_loan_disbursement_detail' table (via 'disbursement_detail_id').",
    "databaseName": "m_loan_tranche_disbursement_charge",
    "tablesAccessed": [
      "m_loan_tranche_disbursement_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_tranche_disbursement_charge\")\npublic class LoanTrancheDisbursementCharge extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"loan_charge_id\", referencedColumnName = \"id\", nullable = false)\n    private LoanCharge loancharge;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.guarantor.domain.Guarantor",
    "mechanism": "JPA",
    "name": "Guarantor Entity",
    "description": "The class is a JPA entity mapped to the 'm_guarantor' table. It uses standard Jakarta Persistence annotations to define the schema mapping, relationships (ManyToOne with Loan, OneToMany with GuarantorFundingDetails), and column definitions.",
    "databaseName": "m_guarantor",
    "tablesAccessed": [
      "m_guarantor"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity mapping with relationships.",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_guarantor\")\npublic class Guarantor extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"loan_id\", nullable = false)\n    private Loan loan;"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.guarantor.domain.GuarantorFundingDetails",
    "mechanism": "JPA",
    "name": "GuarantorFundingDetails",
    "description": "The class is a JPA Entity mapped to the 'm_guarantor_funding_details' table. It uses standard Jakarta Persistence annotations to define the table mapping, columns, and relationships (ManyToOne, OneToMany).",
    "databaseName": "m_guarantor_funding_details",
    "tablesAccessed": [
      "m_guarantor_funding_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_guarantor_funding_details\")\npublic class GuarantorFundingDetails extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.guarantor.domain.GuarantorFundingTransaction",
    "mechanism": "JPA",
    "name": "GuarantorFundingTransaction",
    "description": "The class is a JPA Entity that maps to the 'm_guarantor_transaction' table. It uses Jakarta Persistence annotations to define the table mapping, column constraints, and relationships with other entities (Many-to-One and One-to-One).",
    "databaseName": "m_guarantor_transaction",
    "tablesAccessed": [
      "m_guarantor_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity mapping with relationship navigation.",
    "transactionHandling": "JPA EntityTransaction (managed by container/context)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_guarantor_transaction\")\npublic class GuarantorFundingTransaction extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.guarantor.service.GuarantorWritePlatformServiceJpaRepositoryIImpl",
    "mechanism": "JPA",
    "name": "GuarantorRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs CRUD operations on Guarantor, Loan, and AccountAssociations entities. It uses @Transactional to manage transaction boundaries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_guarantor",
      "m_loan",
      "m_portfolio_account_associations",
      "m_code_value",
      "m_client",
      "m_staff",
      "m_savings_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, findOne, findByLoan) and some domain service calls.",
    "transactionHandling": "Spring @Transactional annotations on public methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.guarantorRepository.saveAndFlush(guarantor);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "JPA",
    "name": "LoanWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation and handles JPA-specific exceptions (`JpaSystemException`), indicating interaction with a JPA persistence layer via the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Transactional service method invocation",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    try {\n        return this.writePlatformService.makeLoanRepayment(...);\n    } catch (final JpaSystemException | DataIntegrityViolationException dve) {\n        // handle error\n    }\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "JPA",
    "name": "LoanWritePlatformService",
    "description": "The class manages database transactions via Spring's `@Transactional` annotation and handles JPA-specific exceptions (`JpaSystemException`). While it does not execute SQL directly, it orchestrates a write operation (`makeLoanRepayment`) on the Loan entity through the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_loan_transaction"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for transactional writes",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    try {\n        return this.writePlatformService.makeLoanRepayment(LoanTransactionType.MERCHANT_ISSUED_REFUND, ...);\n    } catch (final JpaSystemException | DataIntegrityViolationException dve) { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "JPA",
    "name": "LoanWritePlatformService",
    "description": "The class manages the transaction boundary for database operations using Spring's `@Transactional` annotation. While it delegates the actual persistence calls to `LoanWritePlatformService`, it explicitly handles JPA-specific exceptions (`JpaSystemException`) and database constraint violations (`DataIntegrityViolationException`), indicating it is tightly coupled to the database interaction layer.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Transactional write operation delegated to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        try {\n            // ...\n            return this.writePlatformService.makeLoanRepayment(LoanTransactionType.REPAYMENT, ...);\n        } catch (final JpaSystemException | DataIntegrityViolationException dve) {\n            // ...\n        }\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "JPA",
    "name": "LoanWritePlatformService",
    "description": "The class manages database transactions via Spring's @Transactional annotation and handles JPA-specific exceptions (JpaSystemException, DataIntegrityViolationException), although the direct database writes are delegated to the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LOAN"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Transactional write operation delegated to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    try {\n        return this.writePlatformService.disburseLoan(command.entityId(), command, false);\n    } catch (final JpaSystemException | DataIntegrityViolationException dve) { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "JPA",
    "name": "LoanChargeWritePlatformService",
    "description": "The class manages database transactions via Spring's `@Transactional` annotation and handles JPA-specific exceptions (`JpaSystemException`, `DataIntegrityViolationException`). While it does not execute SQL directly, it orchestrates the transaction for the `LoanChargeWritePlatformService` which performs the persistence operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Transactional service delegation",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    try {\n        return this.writePlatformService.loanChargeRefund(command.getLoanId(), command);\n    } catch (final JpaSystemException | DataIntegrityViolationException dve) { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "JPA",
    "name": "LoanWritePlatformService",
    "description": "The class manages a database transaction using Spring's @Transactional annotation and handles JPA-specific exceptions (JpaSystemException). While it does not execute SQL directly, it orchestrates a write operation (refund) via the LoanWritePlatformService which interacts with the persistence layer.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Transactional write operation delegated to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    try {\n        return this.writePlatformService.creditBalanceRefund(command.getLoanId(), command);\n    } catch (final JpaSystemException | DataIntegrityViolationException dve) { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.AddLoanChargeCommandHandler",
    "mechanism": "JPA",
    "name": "LoanChargeWritePlatformService",
    "description": "The class manages database transactions via Spring's @Transactional annotation and handles JPA-specific exceptions (JpaSystemException, DataIntegrityViolationException). While it delegates the actual persistence logic to the LoanChargeWritePlatformService, it acts as the transaction boundary and error handling layer for database interactions related to creating loan charges.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    try {\n        return this.writePlatformService.addLoanCharge(command.getLoanId(), command);\n    } catch (final JpaSystemException | DataIntegrityViolationException dve) { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.LoanPayoutRefundCommandHandler",
    "mechanism": "JPA",
    "name": "LoanWritePlatformService",
    "description": "The class interacts with the database indirectly through the `LoanWritePlatformService`. It manages the transaction boundary using Spring's `@Transactional` annotation. The explicit handling of `JpaSystemException` and `DataIntegrityViolationException` confirms that the underlying service interacts with a JPA-based persistence layer.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "The code delegates to a service layer, but the context implies a write/update operation (Repayment) on Loan entities.",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        try {\n            // ...\n            return this.writePlatformService.makeLoanRepayment(LoanTransactionType.PAYOUT_REFUND, ...);\n        } catch (final JpaSystemException | DataIntegrityViolationException dve) {\n            // ...\n        }\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.UpdateLoanOfficerCommandHandler",
    "mechanism": "JPA",
    "name": "LoanWritePlatformService",
    "description": "This class initiates a database write operation by delegating to the `LoanWritePlatformService`. The `processCommand` method is annotated with `@Transactional`, indicating that the call to `writePlatformService.loanReassignment` is executed within a database transaction managed by the Spring framework. The actual database interaction logic (e.g., finding the loan entity, updating its officer field, and saving the changes) resides within the `LoanWritePlatformService`, which uses JPA for persistence.",
    "databaseName": "not identifiable from code",
    "tablesAccessed": [
      "m_loan"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "ORM-based entity update",
    "transactionHandling": "Spring @Transactional",
    "protocol": "not identifiable from code",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return this.writePlatformService.loanReassignment(command.getLoanId(), command);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.loanschedule.domain",
    "mechanism": "JPA",
    "name": "LoanRepaymentScheduleHistory",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses Jakarta Persistence annotations to define the table name, column mappings, precision for decimal values, and foreign key relationships.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_repayment_schedule_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_loan_repayment_schedule_history\")\npublic class LoanRepaymentScheduleHistory extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.loanschedule.service",
    "mechanism": "JPA",
    "name": "LoanAccountDomainService",
    "description": "The class interacts with the database primarily through the `LoanAccountDomainService` to persist changes to the `Loan` entity and its related `LoanTermVariations`. It also uses `LoanAssembler` to fetch entities. The operations are wrapped in a Spring `@Transactional` annotation to ensure atomicity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_loan_term_variations"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM entity retrieval and save operations",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "loanAccountDomainService.saveLoanWithDataIntegrityViolationChecks(loan);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.rescheduleloan.domain.LoanRescheduleRequest",
    "mechanism": "JPA",
    "name": "LoanRescheduleRequest",
    "description": "The class is a JPA Entity mapped to the 'm_loan_reschedule_request' table. It uses Jakarta Persistence annotations to define the schema mapping and relationships.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_reschedule_request"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_loan_reschedule_request\")\npublic class LoanRescheduleRequest extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.rescheduleloan.handler",
    "mechanism": "JPA",
    "name": "LoanRescheduleRequestWritePlatformService",
    "description": "The class participates in database transactions via the Spring `@Transactional` annotation. While it does not execute SQL directly, it defines the transaction boundary for the `approve` operation performed by the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n        return this.loanRescheduleRequestWritePlatformService.approve(jsonCommand);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service",
    "mechanism": "JPA",
    "name": "LoanArrearsAgingService",
    "description": "The interface interacts with the database primarily through the 'Loan' domain entity (likely JPA) and explicitly through the generation of SQL statements in 'createInsertStatements'. This suggests a hybrid approach using both ORM for entity management and raw SQL generation for bulk operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan",
      "LoanSchedule"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Hybrid approach: ORM-based entity updates and manual SQL string generation for batch inserts.",
    "transactionHandling": "Likely managed by Spring @Transactional in the implementation classes.",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "void createInsertStatements(List<String> insertStatement, ...)"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service.LoanApplicationWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "JPA",
    "name": "LoanRepositoryWrapper, ClientRepositoryWrapper, etc.",
    "description": "The class uses Spring Data JPA repositories (wrapped in custom wrapper classes) to interact with the database. It performs CRUD operations on entities like Loan, Client, Group, LoanProduct, CalendarInstance, and Note. It uses `@Transactional` to ensure atomicity of complex operations involving multiple tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_client",
      "m_group",
      "m_product_loan",
      "m_calendar",
      "m_calendar_instance",
      "m_note",
      "m_portfolio_account_associations",
      "glim_account_info_table",
      "m_loan_collateral_management",
      "m_client_collateral_management"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code primarily uses `findById`, `save`, `saveAndFlush`, and `delete` methods provided by the repositories. There are also custom finder methods like `findActiveLoansLoanProductIdsByGroup` and `findNonClosedLoanThatBelongsToClient` which likely execute JPQL queries.",
    "transactionHandling": "Spring @Transactional annotations are used on public methods to manage transaction boundaries.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.loanRepositoryWrapper.saveAndFlush(newLoanApplication);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service.LoanWritePlatformService",
    "mechanism": "JPA",
    "name": "LoanWritePlatformService",
    "description": "The service manages write operations for loans, which involves persisting changes to Loan and LoanTransaction entities within transactions. It uses Spring's @Transactional annotation to manage transaction boundaries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan",
      "LoanTransaction",
      "Office",
      "Staff",
      "Calendar",
      "CalendarInstance"
    ],
    "operationType": [
      "WRITE",
      "READ_WRITE"
    ],
    "queryPatterns": "Transactional updates to domain entities.",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\nCommandProcessingResult makeLoanRepaymentWithChargeRefundChargeType(LoanTransactionType repaymentTransactionType, Long loanId, JsonCommand command, boolean isRecoveryRepayment, String chargeRefundChargeType);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service.LoanWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "JPA",
    "name": "LoanRepositoryWrapper",
    "description": "The service uses Spring Data JPA repositories (wrapped in wrapper classes like `LoanRepositoryWrapper`) to interact with the database. It performs CRUD operations on `Loan`, `LoanTransaction`, and related entities. It uses `@Transactional` to ensure atomicity of complex business operations involving multiple tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_loan_transaction",
      "m_note",
      "m_loan_charge",
      "m_loan_collateral_management",
      "m_loan_disbursement_detail",
      "m_loan_repayment_schedule",
      "glim_accounts",
      "m_calendar_instance",
      "m_holiday",
      "m_working_days"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM-based CRUD operations, finding entities by ID, saving entities with cascade updates.",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "loanRepaymentScheduleInstallmentRepository.saveAll(loan.getRepaymentScheduleInstallments());\nreturn this.loanRepositoryWrapper.saveAndFlush(loan);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain",
    "mechanism": "JPA",
    "name": "LoanProductBorrowerCycleVariations",
    "description": "The class is a JPA Entity mapped to the `m_product_loan_variations_borrower_cycle` table. It uses standard Jakarta Persistence annotations to define the table name, column mappings (including precision/scale for BigDecimals), and a Many-to-One relationship with the `LoanProduct` entity.",
    "databaseName": "m_product_loan_variations_borrower_cycle",
    "tablesAccessed": [
      "m_product_loan_variations_borrower_cycle"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_product_loan_variations_borrower_cycle\")\npublic class LoanProductBorrowerCycleVariations extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain",
    "mechanism": "JPA",
    "name": "LoanProductConfigurableAttributes",
    "description": "The class is a JPA Entity mapped to the 'm_product_loan_configurable_attributes' table using Jakarta Persistence annotations. It uses a One-to-One relationship with the LoanProduct entity.",
    "databaseName": "m_product_loan_configurable_attributes",
    "tablesAccessed": [
      "m_product_loan_configurable_attributes"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_product_loan_configurable_attributes\")\npublic class LoanProductConfigurableAttributes extends AbstractPersistableCustom implements Serializable {\n    @OneToOne\n    @JoinColumn(name = \"loan_product_id\", nullable = false)\n    private LoanProduct loanProduct;"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain",
    "mechanism": "JPA",
    "name": "LoanProductRelatedDetail",
    "description": "This class is a JPA Embeddable component. It does not represent a standalone table but defines a set of columns that are embedded into the tables of entities that use it (likely Loan or LoanProduct tables). It uses standard Jakarta Persistence annotations to map fields to database columns.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Embeddable (tables depend on embedding entity)"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings via @Embeddable and @Column",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Embeddable\npublic class LoanProductRelatedDetail implements LoanProductMinimumRepaymentScheduleRelatedDetail {\n    @Column(name = \"principal_amount\", scale = 6, precision = 19)\n    private BigDecimal principal;\n    @Enumerated(EnumType.ORDINAL)\n    @Column(name = \"interest_period_frequency_enum\")\n    private PeriodFrequencyType interestPeriodFrequencyType;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain",
    "mechanism": "JPA",
    "name": "LoanProductPaymentAllocationRule",
    "description": "The class uses Jakarta Persistence (JPA) annotations to map the object model to the relational database table 'm_loan_product_payment_allocation_rule'. It defines column mappings, constraints, and relationships.",
    "databaseName": "m_loan_product_payment_allocation_rule",
    "tablesAccessed": [
      "m_loan_product_payment_allocation_rule"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for CRUD operations",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JPA / Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_loan_product_payment_allocation_rule\", uniqueConstraints = {\n        @UniqueConstraint(columnNames = { \"loan_product_id\", \"transaction_type\" }, name = \"uq_m_loan_product_payment_allocation_rule\") })\npublic class LoanProductPaymentAllocationRule extends AbstractAuditableWithUTCDateTimeCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain",
    "mechanism": "JPA",
    "name": "LoanProductMinMaxConstraints",
    "description": "The class is a JPA Embeddable component. It defines the schema for min/max constraints columns (e.g., 'min_principal_amount', 'max_principal_amount') which are embedded into the table of the parent entity (likely LoanProduct).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Embeddable\npublic class LoanProductMinMaxConstraints {\n    @Column(name = \"min_principal_amount\", scale = 6, precision = 19)\n    private BigDecimal minPrincipal;\n    // ..."
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain",
    "mechanism": "JPA",
    "name": "AllocationTypeListConverter",
    "description": "This class is a JPA AttributeConverter. It intercepts database read and write operations for attributes of type List<PaymentAllocationType>, converting them to a String format (likely CSV) for the database and back to a List for the Java entity.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM conversion logic",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Converter(autoApply = true)\npublic class AllocationTypeListConverter extends GenericEnumListConverter<PaymentAllocationType>\n        implements AttributeConverter<List<PaymentAllocationType>, String>"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain.LoanProduct",
    "mechanism": "JPA",
    "name": "LoanProduct Entity",
    "description": "The class is a standard JPA Entity annotated with @Entity and @Table. It maps to the 'm_product_loan' table. It uses @OneToMany, @ManyToOne, @ManyToMany, and @OneToOne annotations to define relationships with other entities like Fund, Charge, Rate, and various configuration details. It uses @Embedded to flatten complex value objects into the main table.",
    "databaseName": "m_product_loan",
    "tablesAccessed": [
      "m_product_loan",
      "m_product_loan_charge",
      "m_product_loan_rate"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_product_loan\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"unq_name\"), ... })\npublic class LoanProduct extends AbstractPersistableCustom {\n    @Column(name = \"name\", nullable = false, unique = true)\n    private String name;\n    ..."
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain.LoanProductFloatingRates",
    "mechanism": "JPA",
    "name": "LoanProductFloatingRates",
    "description": "The class is a JPA Entity mapped to the 'm_product_loan_floating_rates' table. It uses Jakarta Persistence annotations to define the table mapping, column constraints, and relationships (OneToOne, ManyToOne).",
    "databaseName": "m_product_loan_floating_rates",
    "tablesAccessed": [
      "m_product_loan_floating_rates"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with relationship handling",
    "transactionHandling": "JPA EntityTransaction (implicit via container)",
    "protocol": "JPA/JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_product_loan_floating_rates\")\npublic class LoanProductFloatingRates extends AbstractPersistableCustom {\n    @OneToOne\n    @JoinColumn(name = \"loan_product_id\", nullable = false)\n    private LoanProduct loanProduct;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain.LoanProductGuaranteeDetails",
    "mechanism": "JPA",
    "name": "LoanProductGuaranteeDetails",
    "description": "The class is a JPA Entity mapped to a relational database table. It uses Jakarta Persistence annotations to define the table name, column mappings, and relationships.",
    "databaseName": "m_product_loan_guarantee_details",
    "tablesAccessed": [
      "m_product_loan_guarantee_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "Unknown (JPA abstraction)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_product_loan_guarantee_details\")\npublic class LoanProductGuaranteeDetails extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain.LoanProductInterestRecalculationDetails",
    "mechanism": "JPA",
    "name": "LoanProductInterestRecalculationDetails",
    "description": "The class is a JPA Entity that maps to the 'm_product_loan_recalculation_details' table. It uses Jakarta Persistence annotations (@Entity, @Table, @Column, @OneToOne) to define the schema mapping. It maintains a one-to-one relationship with the 'LoanProduct' entity via the 'product_id' join column.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_product_loan_recalculation_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for CRUD operations",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_product_loan_recalculation_details\")\npublic class LoanProductInterestRecalculationDetails extends AbstractPersistableCustom {\n    @OneToOne\n    @JoinColumn(name = \"product_id\", nullable = false)\n    private LoanProduct loanProduct;\n    // ..."
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain.LoanProductTrancheDetails",
    "mechanism": "JPA",
    "name": "LoanProductTrancheDetails",
    "description": "The class is a JPA Embeddable component. It defines database column mappings for tranche-related fields which will be part of the table of the entity that embeds this class (likely the Loan Product table).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Column(name = \"max_outstanding_loan_balance\", scale = 6, precision = 19)\nprivate BigDecimal outstandingLoanBalance;"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain.LoanProductVariableInstallmentConfig",
    "mechanism": "JPA",
    "name": "LoanProductVariableInstallmentConfig",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses Jakarta Persistence annotations to define the table name, column mappings, and relationships (OneToOne).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_product_loan_variable_installment_config"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_product_loan_variable_installment_config\")\npublic class LoanProductVariableInstallmentConfig extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.productmix.domain.ProductMix",
    "mechanism": "JPA",
    "name": "ProductMix Entity",
    "description": "This class is a JPA Entity that maps directly to the relational database table 'm_product_mix'. It uses annotations to define foreign key relationships to the LoanProduct table.",
    "databaseName": "m_product_mix",
    "tablesAccessed": [
      "m_product_mix"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_product_mix\")\npublic class ProductMix extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"product_id\", nullable = false)\n    private LoanProduct product;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.attendance.domain.ClientAttendance",
    "mechanism": "JPA",
    "name": "ClientAttendance",
    "description": "The class is a JPA Entity mapped to the 'm_client_attendance' table. It defines the schema structure including foreign keys to Client and Meeting tables and a unique constraint.",
    "databaseName": "m_client_attendance",
    "tablesAccessed": [
      "m_client_attendance"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_client_attendance\", uniqueConstraints = {\n        @UniqueConstraint(columnNames = { \"client_id\", \"meeting_id\" }, name = \"unique_client_meeting_attendance\") })\npublic class ClientAttendance extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.domain.Meeting",
    "mechanism": "JPA",
    "name": "Meeting",
    "description": "The class is a JPA Entity mapped to the 'm_meeting' table. It uses standard Jakarta Persistence annotations to define the table structure, unique constraints, and relationships (ManyToOne, OneToMany).",
    "databaseName": "m_meeting",
    "tablesAccessed": [
      "m_meeting",
      "m_client_attendance"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_meeting\", uniqueConstraints = {\n        @UniqueConstraint(columnNames = { \"calendar_instance_id\", \"meeting_date\" }, name = \"unique_calendar_instance_id_meeting_date\") })\npublic class Meeting extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.note.domain.Note",
    "mechanism": "JPA",
    "name": "Note",
    "description": "The class is a standard JPA Entity mapped to the 'm_note' table. It defines relationships to other tables (m_client, m_group, m_loan, etc.) using @ManyToOne annotations.",
    "databaseName": "m_note",
    "tablesAccessed": [
      "m_note"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_note\")\npublic class Note extends AbstractAuditableWithUTCDateTimeCustom {\n    @ManyToOne\n    @JoinColumn(name = \"client_id\", nullable = true)\n    private Client client;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.paymentdetail.domain",
    "mechanism": "JPA",
    "name": "PaymentDetail",
    "description": "The class is a JPA entity mapped to the 'm_payment_detail' database table. It uses annotations to define column mappings and relationships.",
    "databaseName": "m_payment_detail",
    "tablesAccessed": [
      "m_payment_detail"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_payment_detail\")\npublic final class PaymentDetail extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.paymenttype.domain.PaymentType",
    "mechanism": "JPA",
    "name": "PaymentType Entity",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses Jakarta Persistence annotations to define the table name and column mappings.",
    "databaseName": "m_payment_type",
    "tablesAccessed": [
      "m_payment_type"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA / JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_payment_type\")\npublic class PaymentType extends AbstractPersistableCustom {\n    @Column(name = \"value\")\n    private String name;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.rate.domain.Rate",
    "mechanism": "JPA",
    "name": "Rate",
    "description": "The class is a JPA entity mapped to the 'm_rate' database table. It uses Jakarta Persistence annotations to define the table structure, columns, and relationships.",
    "databaseName": "m_rate",
    "tablesAccessed": [
      "m_rate"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_rate\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"name\") })\npublic class Rate extends AbstractAuditableCustom {\n    @Column(name = \"name\", length = 250, unique = true)\n    private String name;\n    // ..."
  },
  {
    "path": "org.apache.fineract.portfolio.repaymentwithpostdatedchecks.domain.PostDatedChecks",
    "mechanism": "JPA",
    "name": "PostDatedChecks",
    "description": "The class is a JPA entity that maps to the 'm_repayment_with_post_dated_checks' table. It uses Jakarta Persistence annotations to define the table structure, column constraints, and foreign key relationships to the Loan and LoanRepaymentScheduleInstallment tables.",
    "databaseName": "m_repayment_with_post_dated_checks",
    "tablesAccessed": [
      "m_repayment_with_post_dated_checks"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for CRUD operations.",
    "transactionHandling": "Implicitly handled by the JPA provider/container.",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_repayment_with_post_dated_checks\")\npublic class PostDatedChecks extends AbstractPersistableCustom {\n    @Column(name = \"account_no\", nullable = false, length = 10)\n    private Long accountNo;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "n/a",
    "description": "The class is a JPA Embeddable component. It does not interact with the database directly but defines columns that will be part of the table of the entity embedding it.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings via annotations",
    "transactionHandling": "JPA EntityTransaction (managed by context)",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Column(name = \"is_mandatory\", nullable = true)\nprivate boolean isMandatoryDeposit;"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "SavingsAccountChargePaidBy",
    "description": "The class is a JPA entity mapped to the 'm_savings_account_charge_paid_by' table. It uses Jakarta Persistence annotations to define the table mapping and relationships (ManyToOne) with other entities.",
    "databaseName": "m_savings_account_charge_paid_by",
    "tablesAccessed": [
      "m_savings_account_charge_paid_by"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_savings_account_charge_paid_by\")\npublic class SavingsAccountChargePaidBy extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "SavingsOfficerAssignmentHistory",
    "description": "The class is a JPA entity that maps directly to the 'm_savings_officer_assignment_history' table. It uses annotations to define the table name, column mappings, and relationships (ManyToOne) to other entities (SavingsAccount, Staff).",
    "databaseName": "m_savings_officer_assignment_history",
    "tablesAccessed": [
      "m_savings_officer_assignment_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA 3.1 / Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_savings_officer_assignment_history\")\npublic class SavingsOfficerAssignmentHistory extends AbstractAuditableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"account_id\", nullable = false)\n    private SavingsAccount savingsAccount;"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "SavingsAccountTransaction",
    "description": "The class is a JPA entity mapped to the 'm_savings_account_transaction' table. It uses standard JPA annotations for ORM mapping.",
    "databaseName": "m_savings_account_transaction",
    "tablesAccessed": [
      "m_savings_account_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity operations (persist, merge, find).",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_savings_account_transaction\")\npublic final class SavingsAccountTransaction extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "SavingsAccountSummary",
    "description": "This class is a JPA Embeddable component. It does not represent a standalone table but defines columns that are embedded into the table of the owning entity (likely SavingsAccount). It uses standard Jakarta Persistence annotations to map fields to database columns with specific precision and scale.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Embeddable\npublic final class SavingsAccountSummary {\n    @Column(name = \"total_deposits_derived\", scale = 6, precision = 19)\n    private BigDecimal totalDeposits;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "SavingsAccountRepositoryWrapper",
    "description": "The class uses Spring Data JPA repositories (wrapped in wrapper classes) to interact with the database. It loads, updates, and saves `SavingsAccount`, `FixedDepositAccount`, `RecurringDepositAccount`, and `CalendarInstance` entities. It also uses `JournalEntryWritePlatformService` to write accounting entries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_calendar_instance",
      "m_account_number_format",
      "acc_gl_journal_entry"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "CRUD operations on account entities, fetching calendar instances, and persisting journal entries.",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.savingsAccountRepository.save(account);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "DepositProductTermAndPreClosure",
    "description": "The class is a JPA Entity that maps to the 'm_deposit_product_term_and_preclosure' table. It uses Jakarta Persistence annotations to define the mapping. It utilizes @Embedded to flatten the structure of related value objects (DepositPreClosureDetail, DepositTermDetail, DepositProductAmountDetails) into columns within the same table, and @OneToOne to link to the 'm_savings_product' table (via FixedDepositProduct).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_deposit_product_term_and_preclosure"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA ORM mapping with embedded objects.",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_deposit_product_term_and_preclosure\")\npublic class DepositProductTermAndPreClosure extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "DepositProductRecurringDetail",
    "description": "The class is a JPA Entity that maps to a relational database table. It uses Jakarta Persistence annotations to define the table name, relationships, and embedded fields.",
    "databaseName": "m_deposit_product_recurring_detail",
    "tablesAccessed": [
      "m_deposit_product_recurring_detail"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "Unknown (JPA abstraction)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_deposit_product_recurring_detail\")\npublic class DepositProductRecurringDetail extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "RecurringDepositAccount Entity",
    "description": "The class is a JPA entity that maps to the database table for savings accounts (likely 'm_savings_account' via inheritance). It uses a discriminator value '300' to distinguish itself from other savings account types. It manages relationships with other entities like DepositAccountTermAndPreClosure, DepositAccountRecurringDetail, and RecurringDepositScheduleInstallment using @OneToOne and @OneToMany annotations with CascadeType.ALL.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_deposit_account_term_and_pre_closure",
      "m_deposit_account_recurring_detail",
      "m_deposit_account_interest_rate_chart",
      "m_recurring_deposit_schedule_installment"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@DiscriminatorValue(\"300\")\npublic class RecurringDepositAccount extends SavingsAccount {\n    @OneToOne(mappedBy = \"account\", cascade = CascadeType.ALL)\n    private DepositAccountTermAndPreClosure accountTermAndPreClosure;\n    ..."
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "DepositAccountDomainService",
    "description": "This interface defines a domain service that orchestrates changes to JPA entities (SavingsAccount, FixedDepositAccount, RecurringDepositAccount). The @Transactional annotation on 'handleFDAccountMaturityClosure' indicates that the implementation manages database transactions to ensure data consistency during complex operations like account maturity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_savings_account_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The implementation likely uses JPA entity state transitions (modifying fields on the account objects) which are then flushed to the database.",
    "transactionHandling": "Spring @Transactional annotation is explicitly used on the maturity closure method, implying declarative transaction management.",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\nLong handleFDAccountMaturityClosure(FixedDepositAccount account, ...)"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "DepositAccountInterestRateChart",
    "description": "The class is a JPA Entity mapped to the 'm_savings_account_interest_rate_chart' table. It uses standard Jakarta Persistence annotations to define the table mapping, embedded fields, and relationships (OneToOne with SavingsAccount, OneToMany with DepositAccountInterestRateChartSlabs).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account_interest_rate_chart"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_savings_account_interest_rate_chart\")\npublic class DepositAccountInterestRateChart extends AbstractPersistableCustom {\n    @OneToOne\n    @JoinColumn(name = \"savings_account_id\", nullable = false)\n    private SavingsAccount account;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "DepositAccountOnHoldTransaction",
    "description": "The class is a JPA Entity mapped to the 'm_deposit_account_on_hold_transaction' table. It uses standard Jakarta Persistence annotations to define columns and relationships.",
    "databaseName": "m_deposit_account_on_hold_transaction",
    "tablesAccessed": [
      "m_deposit_account_on_hold_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_deposit_account_on_hold_transaction\")\npublic class DepositAccountOnHoldTransaction extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "DepositAccountRecurringDetail",
    "description": "The class is a JPA Entity mapped to the 'm_deposit_account_recurring_detail' table. It uses standard Jakarta Persistence annotations to define the table mapping, columns, and relationships (OneToOne with SavingsAccount).",
    "databaseName": "m_deposit_account_recurring_detail",
    "tablesAccessed": [
      "m_deposit_account_recurring_detail"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "Unknown (JPA abstraction)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_deposit_account_recurring_detail\")\npublic class DepositAccountRecurringDetail extends AbstractPersistableCustom {\n    @Column(name = \"mandatory_recommended_deposit_amount\"...)\n    private BigDecimal mandatoryRecommendedDepositAmount;\n    @OneToOne\n    @JoinColumn(name = \"savings_account_id\", nullable = false)\n    private SavingsAccount account;"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "JPA",
    "name": "RecurringDepositProduct",
    "description": "The class is a JPA Entity annotated with `@Entity` and `@DiscriminatorValue(\"300\")`. It extends `FixedDepositProduct`, implying a Single Table inheritance strategy where all products are stored in one table (likely `m_savings_product` or similar) distinguished by the discriminator column. It also manages a child entity `DepositProductRecurringDetail` via a `@OneToOne` relationship with `CascadeType.ALL`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RecurringDepositProduct",
      "DepositProductRecurringDetail"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@DiscriminatorValue(\"300\")\npublic class RecurringDepositProduct extends FixedDepositProduct {\n    @OneToOne(mappedBy = \"product\", cascade = CascadeType.ALL)\n    private DepositProductRecurringDetail recurringDetail;"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.DepositAccountInterestIncentive",
    "mechanism": "JPA",
    "name": "DepositAccountInterestIncentive",
    "description": "The class uses Jakarta Persistence API (JPA) annotations to map the Java object to a relational database table. It defines relationships and embedded fields that correspond to columns in the 'm_deposit_account_interest_incentives' table.",
    "databaseName": "m_deposit_account_interest_incentives",
    "tablesAccessed": [
      "m_deposit_account_interest_incentives"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA (Jakarta Persistence)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_deposit_account_interest_incentives\")\npublic class DepositAccountInterestIncentive extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.DepositAccountInterestIncentives",
    "mechanism": "JPA",
    "name": "m_savings_interest_incentives",
    "description": "The class is a JPA entity that maps directly to the 'm_savings_interest_incentives' table in the database. It uses annotations to define the table name, column mappings, and relationships (Many-to-One) with other entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_interest_incentives"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_savings_interest_incentives\")\npublic class DepositAccountInterestIncentives extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.DepositAccountInterestRateChartSlabs",
    "mechanism": "JPA",
    "name": "DepositAccountInterestRateChartSlabs",
    "description": "The class is a JPA Entity mapped to the 'm_savings_account_interest_rate_slab' table. It uses Jakarta Persistence annotations to define the table mapping, embedded fields, and relationships with other entities.",
    "databaseName": "m_savings_account_interest_rate_slab",
    "tablesAccessed": [
      "m_savings_account_interest_rate_slab"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with OneToMany and ManyToOne relationships.",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_savings_account_interest_rate_slab\")\npublic class DepositAccountInterestRateChartSlabs extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.DepositAccountTermAndPreClosure",
    "mechanism": "JPA",
    "name": "DepositAccountTermAndPreClosure",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping directly to the 'm_deposit_account_term_and_preclosure' table. It uses standard JPA annotations (@Column, @OneToOne, @Embedded) to map class fields to database columns and relationships.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_deposit_account_term_and_preclosure"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction (managed by container/framework)",
    "protocol": "JDBC/JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_deposit_account_term_and_preclosure\")\npublic class DepositAccountTermAndPreClosure extends AbstractPersistableCustom {\n    @Column(name = \"deposit_amount\", scale = 6, precision = 19, nullable = true)\n    private BigDecimal depositAmount;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.DepositPreClosureDetail",
    "mechanism": "JPA",
    "name": "DepositPreClosureDetail",
    "description": "This class is a JPA Embeddable component. It does not represent a standalone table but defines columns that are embedded into the tables of the entities that use it (e.g., FixedDepositProduct or FixedDepositAccount). It uses Jakarta Persistence annotations to map fields to database columns.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Embeddable\npublic class DepositPreClosureDetail {\n    @Column(name = \"pre_closure_penal_applicable\")\n    private boolean preClosurePenalApplicable;\n    @Column(name = \"pre_closure_penal_interest\", scale = 6, precision = 19, nullable = true)\n    private BigDecimal preClosurePenalInterest;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.DepositProductAmountDetails",
    "mechanism": "JPA",
    "name": "DepositProductAmountDetails",
    "description": "The class uses Jakarta Persistence (JPA) annotations to map its fields to database columns. It is marked as @Embeddable, meaning it does not have its own table but its columns are embedded in the table of the entity that contains it.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mapping via annotations",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Embeddable\npublic class DepositProductAmountDetails {\n    @Column(name = \"min_deposit_amount\", scale = 6, precision = 19, nullable = true)\n    private BigDecimal minDepositAmount;"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.DepositTermDetail",
    "mechanism": "JPA",
    "name": "DepositTermDetail",
    "description": "This class is a JPA Embeddable component. It does not have its own table but defines columns that are embedded into the tables of entities that use it (e.g., FixedDepositProduct).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Embeddable\npublic class DepositTermDetail {\n    @Column(name = \"min_deposit_term\", nullable = true)\n    private Integer minDepositTerm;"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.FixedDepositAccount",
    "mechanism": "JPA",
    "name": "FixedDepositAccount Entity",
    "description": "The class is a JPA Entity mapped to the database. It inherits from `SavingsAccount` and uses a discriminator value to distinguish it in the persistence layer. It uses One-to-One relationships for managing term details and interest charts.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FixedDepositAccount (mapped via SavingsAccount table)"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM-based CRUD operations, likely using Joined or Single Table inheritance strategy.",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@DiscriminatorValue(\"200\")\npublic class FixedDepositAccount extends SavingsAccount {\n    @OneToOne(mappedBy = \"account\", cascade = CascadeType.ALL)\n    private DepositAccountTermAndPreClosure accountTermAndPreClosure;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.FixedDepositProduct",
    "mechanism": "JPA",
    "name": "FixedDepositProduct Entity",
    "description": "The class is a JPA Entity annotated with @Entity and @DiscriminatorValue('200'). It maps to a database table (likely 'm_savings_product' via inheritance) and uses a join table 'm_deposit_product_interest_rate_chart' for its relationship with InterestRateChart.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_product",
      "m_deposit_product_interest_rate_chart"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with OneToOne and OneToMany relationships.",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@DiscriminatorValue(\"200\")\npublic class FixedDepositProduct extends SavingsProduct {\n    @OneToMany(fetch = FetchType.LAZY, cascade = CascadeType.ALL)\n    @JoinTable(name = \"m_deposit_product_interest_rate_chart\", ...)\n    protected Set<InterestRateChart> charts;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.GroupSavingsIndividualMonitoring",
    "mechanism": "JPA",
    "name": "GroupSavingsIndividualMonitoring",
    "description": "The class is a JPA Entity mapped to the 'gsim_accounts' table. It uses Jakarta Persistence annotations to define the schema, including columns, unique constraints, and relationships (ManyToOne with Group, OneToMany with SavingsAccount).",
    "databaseName": "gsim_accounts",
    "tablesAccessed": [
      "gsim_accounts"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"gsim_accounts\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"account_number\" }, name = \"gsim_id\") })\npublic final class GroupSavingsIndividualMonitoring extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.RecurringDepositScheduleInstallment",
    "mechanism": "JPA",
    "name": "RecurringDepositScheduleInstallment",
    "description": "The class is a JPA Entity that maps directly to the 'm_mandatory_savings_schedule' table. It uses standard Jakarta Persistence annotations to define the table name, column mappings, and relationships (ManyToOne with RecurringDepositAccount).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_mandatory_savings_schedule"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_mandatory_savings_schedule\")\npublic class RecurringDepositScheduleInstallment extends AbstractAuditableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"savings_account_id\")\n    private RecurringDepositAccount account;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.SavingsAccount",
    "mechanism": "JPA",
    "name": "SavingsAccount",
    "description": "The class is a JPA Entity mapped to the 'm_savings_account' table. It uses Single Table Inheritance with a discriminator column. It defines relationships with other entities like Client, Group, SavingsProduct, and manages collections of transactions and charges.",
    "databaseName": "m_savings_account",
    "tablesAccessed": [
      "m_savings_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity mapping with OneToMany and ManyToOne relationships.",
    "transactionHandling": "JPA EntityTransaction (implicitly managed by container/service layer)",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_savings_account\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"account_no\" }, name = \"sa_account_no_UNIQUE\"),\n        @UniqueConstraint(columnNames = { \"external_id\" }, name = \"sa_external_id_UNIQUE\") })\n@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\n@DiscriminatorColumn(name = \"deposit_type_enum\", discriminatorType = DiscriminatorType.INTEGER)\n@DiscriminatorValue(\"100\")\npublic class SavingsAccount extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.SavingsAccountCharge",
    "mechanism": "JPA",
    "name": "SavingsAccountCharge",
    "description": "The class is a JPA Entity mapped to the 'm_savings_account_charge' table. It uses standard Jakarta Persistence annotations to define the table mapping, column definitions, and relationships (ManyToOne) with SavingsAccount and Charge entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM entity mapping",
    "transactionHandling": "JPA EntityTransaction (implicit via container)",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_savings_account_charge\")\npublic class SavingsAccountCharge extends AbstractPersistableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"savings_account_id\", referencedColumnName = \"id\", nullable = false)\n    private SavingsAccount savingsAccount;\n    // ..."
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.SavingsAccountTransactionTaxDetails",
    "mechanism": "JPA",
    "name": "SavingsAccountTransactionTaxDetails",
    "description": "The class is a JPA entity mapped to the 'm_savings_account_transaction_tax_details' table. It uses standard JPA annotations to define the table mapping, column constraints, and foreign key relationships to other entities.",
    "databaseName": "m_savings_account_transaction_tax_details",
    "tablesAccessed": [
      "m_savings_account_transaction_tax_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM entity mapping with Many-to-One relationships.",
    "transactionHandling": "Implicitly handled via JPA EntityTransaction or Spring @Transactional in the service layer.",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_savings_account_transaction_tax_details\")\npublic class SavingsAccountTransactionTaxDetails extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"savings_transaction_id\", nullable = false)\n    private SavingsAccountTransaction savingsAccountTransaction;\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.SavingsProduct",
    "mechanism": "JPA",
    "name": "SavingsProduct",
    "description": "The class is a JPA Entity mapped to the 'm_savings_product' table. It uses Single Table Inheritance with a discriminator column 'deposit_type_enum'. It defines mappings for various columns including unique constraints on name and short_name, and relationships like Many-to-Many with Charges and Many-to-One with TaxGroup.",
    "databaseName": "m_savings_product",
    "tablesAccessed": [
      "m_savings_product",
      "m_savings_product_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_savings_product\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"sp_unq_name\") })\n@Inheritance\n@DiscriminatorColumn(name = \"deposit_type_enum\", discriminatorType = DiscriminatorType.INTEGER)\npublic class SavingsProduct extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "JPA",
    "name": "DepositAccountWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions. While it does not execute SQL directly, it delegates to `DepositAccountWritePlatformService` which performs write operations on the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FIXEDDEPOSITACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for update operations",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.depositAccountWritePlatformService.prematureCloseFDAccount(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "JPA",
    "name": "DepositAccountWritePlatformService",
    "description": "The class manages database transactions via the Spring `@Transactional` annotation. While it does not execute SQL directly, it defines the transaction boundary for the `depositToRDAccount` operation performed by the injected service, which likely interacts with the database using JPA.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RECURRINGDEPOSITACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.depositAccountWritePlatformService.depositToRDAccount(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "JPA",
    "name": "DepositApplicationProcessWritePlatformService",
    "description": "The class defines a transactional boundary using Spring's @Transactional annotation. While it does not execute SQL or call a repository directly, it orchestrates a write operation via the DepositApplicationProcessWritePlatformService which interacts with the database to update the state of the recurring deposit account application.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_savings_account_application"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.depositAccountWritePlatformService.undoApplicationApproval(...);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "JPA",
    "name": "DepositAccountWritePlatformService",
    "description": "The class defines a transaction boundary using the Spring `@Transactional` annotation. While it does not execute SQL or JPA queries directly, it orchestrates a transactional unit of work that delegates to the `DepositAccountWritePlatformService`, which performs the actual database persistence operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RECURRINGDEPOSITACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.depositAccountWritePlatformService.postInterest(command.entityId(), DepositAccountType.RECURRING_DEPOSIT);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "JPA",
    "name": "SavingsAccountWritePlatformService",
    "description": "The class manages database transactions via the Spring `@Transactional` annotation. While it does not execute SQL directly, it orchestrates a write operation ('UNBLOCKCREDIT') on the 'SAVINGSACCOUNT' entity through the injected service, ensuring atomicity of the database changes.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SAVINGSACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for update operations.",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.writePlatformService.unblockCredits(command.getSavingsId());\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "JPA",
    "name": "SavingsAccountWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions for the operation. It delegates the actual data modification to `SavingsAccountWritePlatformService`, which likely interacts with the `SAVINGSACCOUNT` table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SAVINGSACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.writePlatformService.blockCredits(command.getSavingsId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "JPA",
    "name": "SavingsAccountWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's @Transactional annotation for a database write operation. While it does not contain direct SQL or Repository calls, it orchestrates a persistence operation by delegating to the SavingsAccountWritePlatformService which interacts with the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for update operations",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.waiveCharge(command.getSavingsId(), command.entityId());\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler.GSIMDepositCommandHandler",
    "mechanism": "JPA",
    "name": "SavingsAccountWritePlatformService",
    "description": "The class defines a transactional boundary using Spring's `@Transactional` annotation, implying interaction with a transactional resource (database). It delegates the actual persistence logic to `SavingsAccountWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.gsimDeposit(command.getSavingsId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service",
    "mechanism": "JPA",
    "name": "DepositAccountAssembler",
    "description": "The service uses `DepositAccountAssembler` to retrieve domain entities (`SavingsAccount`, `FixedDepositAccount`, `RecurringDepositAccount`) from the database. It is also annotated with `@Transactional`, indicating it participates in a database transaction managed by Spring.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_payment_type"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Entity retrieval via assembler and reference data lookup via read platform services.",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic DepositAccountData calculatePreMatureAmount(final Long accountId, final JsonQuery query, final DepositAccountType depositAccountType) {\n    // ...\n    final SavingsAccount account = this.depositAccountAssembler.assembleFrom(accountId, depositAccountType);\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service",
    "mechanism": "JPA",
    "name": "Savings/Deposit Repositories",
    "description": "The service uses Spring Data JPA repositories to interact with the database. It injects repositories for FixedDepositAccount, RecurringDepositAccount, SavingsAccount, and related entities (Client, Group, Staff, Note). It uses the @Transactional annotation to ensure data consistency across multiple repository calls.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_deposit_account_term_and_preclosure",
      "m_deposit_account_recurring_detail",
      "m_calendar_instance",
      "m_note",
      "m_portfolio_account_associations",
      "m_client",
      "m_group",
      "m_staff"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via JPA repositories, with some complex object graph traversal and updates.",
    "transactionHandling": "Spring @Transactional annotations on the service class and methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.fixedDepositAccountRepository.saveAndFlush(account);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.DepositAccountWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "JPA",
    "name": "SavingsAccountRepositoryWrapper",
    "description": "The class uses Spring Data JPA repositories (wrapped in wrapper classes) to interact with the database. It performs CRUD operations on savings accounts, transactions, charges, and related entities. Transaction management is handled via Spring's @Transactional annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_savings_account_transaction",
      "m_note",
      "m_charge",
      "m_savings_account_charge",
      "m_calendar_instance",
      "m_holiday",
      "m_working_days",
      "m_deposit_account_on_hold_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, findOne, saveAndFlush) with some custom finders.",
    "transactionHandling": "Spring @Transactional annotations on class and methods",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.savingAccountRepositoryWrapper.saveAndFlush(account);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.account.domain.SelfBeneficiariesTPT",
    "mechanism": "JPA",
    "name": "SelfBeneficiariesTPT",
    "description": "The class is a JPA Entity mapped to a relational database table. It uses Jakarta Persistence annotations to define the table name, column mappings, and unique constraints.",
    "databaseName": "m_selfservice_beneficiaries_tpt",
    "tablesAccessed": [
      "m_selfservice_beneficiaries_tpt"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_selfservice_beneficiaries_tpt\"...)\npublic class SelfBeneficiariesTPT extends AbstractPersistableCustom {\n    @Column(name = \"app_user_id\", nullable = false)\n    private Long appUserId;\n..."
  },
  {
    "path": "org.apache.fineract.portfolio.self.pockets.domain",
    "mechanism": "JPA",
    "name": "PocketAccountMapping",
    "description": "The class is a JPA Entity mapped to the 'm_pocket_accounts_mapping' table. It uses Jakarta Persistence annotations to define the table structure and column mappings for pocket IDs and account details.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_pocket_accounts_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_pocket_accounts_mapping\")\npublic class PocketAccountMapping extends AbstractPersistableCustom {\n    @Column(name = \"pocket_id\", length = 20, nullable = false)\n    private Long pocketId;\n    // ..."
  },
  {
    "path": "org.apache.fineract.portfolio.self.pockets.domain.Pocket",
    "mechanism": "JPA",
    "name": "Pocket Entity",
    "description": "The class is a JPA Entity that maps directly to a relational database table using Jakarta Persistence annotations. It defines the table structure, column mappings, and unique constraints for the 'Pocket' domain object.",
    "databaseName": "m_pocket",
    "tablesAccessed": [
      "m_pocket"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_pocket\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"app_user_id\" }, name = \"unique_app_user\") })\npublic class Pocket extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.self.registration.domain.SelfServiceRegistration",
    "mechanism": "JPA",
    "name": "SelfServiceRegistration",
    "description": "The class is a JPA Entity mapped to the 'request_audit_table' database table. It uses Jakarta Persistence annotations to define the schema mapping, including column names, lengths, and nullability constraints. It establishes a Many-to-One relationship with the Client entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "request_audit_table"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"request_audit_table\")\npublic class SelfServiceRegistration extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"client_id\", nullable = false)\n    private Client client;"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.domain",
    "mechanism": "JPA",
    "name": "ShareAccountChargePaidBy",
    "description": "The class is a JPA entity mapped to the 'm_share_account_charge_paid_by' table. It uses foreign keys to link to 'm_share_account_transaction' and 'm_share_account_charge'.",
    "databaseName": "m_share_account_charge_paid_by",
    "tablesAccessed": [
      "m_share_account_charge_paid_by"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_share_account_charge_paid_by\")\npublic class ShareAccountChargePaidBy extends AbstractPersistableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"share_transaction_id\", referencedColumnName = \"id\", nullable = false)\n    private ShareAccountTransaction shareAccountTransaction;\n    //..."
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.domain.ShareAccount",
    "mechanism": "JPA",
    "name": "ShareAccount",
    "description": "The class is a JPA Entity mapped to the 'm_share_account' table. It uses standard Jakarta Persistence annotations (@Entity, @Table, @Column, @ManyToOne, @OneToMany) to define the mapping to the relational database schema, including relationships with Client, ShareProduct, and child entities like ShareAccountTransaction.",
    "databaseName": "m_share_account",
    "tablesAccessed": [
      "m_share_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "codeExample": "@Entity\n@Table(name = \"m_share_account\")\npublic class ShareAccount extends AbstractPersistableCustom {\n    @ManyToOne\n    @JoinColumn(name = \"client_id\")\n    private Client client;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.domain.ShareAccountCharge",
    "mechanism": "JPA",
    "name": "ShareAccountCharge Entity",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping directly to the 'm_share_account_charge' table. It uses @ManyToOne relationships for linking to ShareAccount and Charge entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_share_account_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with standard CRUD operations implied by the entity structure.",
    "transactionHandling": "JPA EntityTransaction (implicit in persistence context usage)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_share_account_charge\")\npublic class ShareAccountCharge extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.domain.ShareAccountDividendDetails",
    "mechanism": "JPA",
    "name": "ShareAccountDividendDetails",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses annotations to define column mappings, constraints, and relationships.",
    "databaseName": "m_share_account_dividend_details",
    "tablesAccessed": [
      "m_share_account_dividend_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA / JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_share_account_dividend_details\")\npublic class ShareAccountDividendDetails extends AbstractPersistableCustom {\n    @Column(name = \"account_id\", nullable = false)\n    private Long shareAccountId;"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.domain.ShareAccountTransaction",
    "mechanism": "JPA",
    "name": "ShareAccountTransaction Entity",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping to the 'm_share_account_transactions' table. It uses standard JPA annotations for column mapping (@Column), relationships (@ManyToOne, @OneToMany), and cascading operations.",
    "databaseName": "m_share_account_transactions",
    "tablesAccessed": [
      "m_share_account_transactions"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with relationship management",
    "transactionHandling": "JPA EntityTransaction (implicit via framework)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_share_account_transactions\")\npublic class ShareAccountTransaction extends AbstractPersistableCustom {\n    @ManyToOne(optional = false)\n    @JoinColumn(name = \"account_id\", referencedColumnName = \"id\", nullable = false)\n    private ShareAccount shareAccount;"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.handler",
    "mechanism": "JPA",
    "name": "ShareAccountWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's @Transactional annotation. While it does not execute SQL directly, it orchestrates a write operation (redeem shares) via the ShareAccountWritePlatformService, which implies underlying database interaction managed by JPA or a similar persistence framework.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n    return this.shareAccountWritePlatformService.redeemShares(jsonCommand.entityId(), jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.service.ShareAccountWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "JPA",
    "name": "ShareAccountRepositoryWrapper",
    "description": "The class uses Spring Data JPA repositories (wrapped in custom wrappers) to perform CRUD operations on share accounts, share products, and notes. It relies on the persistence context to manage entity states and flush changes to the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ShareAccount",
      "ShareProduct",
      "Note",
      "AccountNumberFormat"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, saveAndFlush, findOne) without explicit complex queries in this file.",
    "transactionHandling": "Implicitly handled by the service layer or repository wrappers, likely using Spring's @Transactional (though not explicitly annotated on this class, it is standard practice in this framework).",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "ShareAccount account = this.accountDataSerializer.validateAndCreate(jsonCommand);\nthis.shareAccountRepository.saveAndFlush(account);"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.domain",
    "mechanism": "JPA",
    "name": "ShareProductDividendPayOutDetails",
    "description": "The class is a standard JPA Entity mapped to a specific database table. It uses Jakarta Persistence annotations to define the schema mapping, including column definitions and relationships.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_share_product_dividend_pay_out"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_share_product_dividend_pay_out\")\npublic class ShareProductDividendPayOutDetails extends AbstractAuditableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.domain",
    "mechanism": "JPA",
    "name": "ShareProductMarketPrice",
    "description": "The class is a JPA Entity mapped to a relational database table. It uses annotations to define the table name, column mappings, and relationships (ManyToOne) to other entities.",
    "databaseName": "m_share_product_market_price",
    "tablesAccessed": [
      "m_share_product_market_price"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for standard CRUD operations.",
    "transactionHandling": "JPA EntityTransaction (managed by container/context)",
    "protocol": "JDBC (via JPA provider)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_share_product_market_price\")\npublic class ShareProductMarketPrice extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.domain.ShareProduct",
    "mechanism": "JPA",
    "name": "m_share_product",
    "description": "The class is a JPA Entity mapped to the 'm_share_product' table. It uses standard Jakarta Persistence annotations to define column mappings, relationships (OneToMany for market prices, ManyToMany for charges), and constraints.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_share_product",
      "m_share_product_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings",
    "transactionHandling": "JPA EntityTransaction",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_share_product\")\npublic class ShareProduct extends AbstractAuditableCustom {\n    @Column(name = \"name\", nullable = false, unique = true)\n    private String name;\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.handler",
    "mechanism": "JPA",
    "name": "ShareProductWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation, implying that the underlying service method `deleteShareProductDividend` performs database write operations (likely via JPA or JDBC) that need to be atomic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n        return this.shareProductWritePlatformService.deleteShareProductDividend(jsonCommand.entityId());\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.domain.TaxComponent",
    "mechanism": "JPA",
    "name": "TaxComponent Entity",
    "description": "The class is a JPA Entity mapped to the 'm_tax_component' table. It uses Jakarta Persistence annotations to define the schema mapping, including columns for name, percentage, and account IDs. It manages relationships with 'TaxComponentHistory' (One-to-Many) and 'GLAccount' (Many-to-One).",
    "databaseName": "m_tax_component",
    "tablesAccessed": [
      "m_tax_component",
      "m_tax_component_history",
      "acc_gl_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings with relationship traversal",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_tax_component\")\npublic class TaxComponent extends AbstractAuditableCustom {\n    @Column(name = \"percentage\", scale = 6, precision = 19, nullable = false)\n    private BigDecimal percentage;\n    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER)\n    @JoinColumn(name = \"tax_component_id\", referencedColumnName = \"id\", nullable = false)\n    private Set<TaxComponentHistory> taxComponentHistories = new HashSet<>();\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.domain.TaxComponentHistory",
    "mechanism": "JPA",
    "name": "TaxComponentHistory",
    "description": "This class is a JPA entity mapped to the 'm_tax_component_history' table. It defines columns for percentage, start_date, and end_date.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_tax_component_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_tax_component_history\")\npublic class TaxComponentHistory extends AbstractAuditableCustom {"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.domain.TaxGroup",
    "mechanism": "JPA",
    "name": "TaxGroup",
    "description": "The class is a JPA Entity annotated with @Entity and @Table, mapping it to the 'm_tax_group' table. It manages a relationship with the 'm_tax_group_mappings' table (implied by the OneToMany relationship) via the TaxGroupMappings entity.",
    "databaseName": "m_tax_group",
    "tablesAccessed": [
      "m_tax_group",
      "m_tax_group_mappings"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA entity traversal and state management.",
    "transactionHandling": "JPA EntityTransaction (likely managed by Spring container in service layer)",
    "protocol": "JPA / JDBC",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_tax_group\")\npublic class TaxGroup extends AbstractAuditableCustom {\n    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.EAGER, mappedBy = \"taxGroup\")\n    private Set<TaxGroupMappings> taxGroupMappings = new HashSet<>();"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.domain.TaxGroupMappings",
    "mechanism": "JPA",
    "name": "TaxGroupMappings",
    "description": "The class is a JPA entity mapped to the 'm_tax_group_mappings' table. It uses Jakarta Persistence annotations to define the table mapping and relationships.",
    "databaseName": "m_tax_group_mappings",
    "tablesAccessed": [
      "m_tax_group_mappings"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_tax_group_mappings\")\npublic class TaxGroupMappings extends AbstractAuditableCustom {"
  },
  {
    "path": "org.apache.fineract.spm.domain",
    "mechanism": "JPA",
    "name": "Component",
    "description": "The class is a JPA Entity mapped to the 'm_survey_components' table. It uses annotations to define column mappings and relationships.",
    "databaseName": "m_survey_components",
    "tablesAccessed": [
      "m_survey_components"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for standard CRUD operations.",
    "transactionHandling": "JPA EntityTransaction (managed by container)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_survey_components\")\npublic class Component extends AbstractPersistableCustom {\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"survey_id\")\n    private Survey survey;"
  },
  {
    "path": "org.apache.fineract.spm.domain.LookupTable",
    "mechanism": "JPA",
    "name": "LookupTable",
    "description": "The class is a JPA Entity mapped to the 'm_survey_lookup_tables' table. It uses standard Jakarta Persistence annotations to define the table mapping, column constraints (length, precision, scale), and relationships (ManyToOne with Survey).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_survey_lookup_tables"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Entity\n@Table(name = \"m_survey_lookup_tables\")\npublic class LookupTable extends AbstractPersistableCustom {\n    @Column(name = \"score\", precision = 5, scale = 2)\n    private Double score;\n}"
  },
  {
    "path": "org.apache.fineract.spm.domain.Question",
    "mechanism": "JPA",
    "name": "Question",
    "description": "The class is a JPA entity mapped to the 'm_survey_questions' table. It defines columns for component key, key, text, description, and sequence number. It also manages foreign key relationships to the Survey entity and a collection of Response entities.",
    "databaseName": "m_survey_questions",
    "tablesAccessed": [
      "m_survey_questions"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA (Jakarta Persistence)",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_survey_questions\")\npublic class Question extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.spm.domain.Response",
    "mechanism": "JPA",
    "name": "Response",
    "description": "The class is a JPA entity mapped to the 'm_survey_responses' table. It uses Jakarta Persistence annotations to define the table mapping, column definitions (including length and precision), and the Many-to-One relationship with the Question entity.",
    "databaseName": "m_survey_responses",
    "tablesAccessed": [
      "m_survey_responses"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_survey_responses\")\npublic class Response extends AbstractPersistableCustom {\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"question_id\")\n    private Question question;"
  },
  {
    "path": "org.apache.fineract.spm.domain.Scorecard",
    "mechanism": "JPA",
    "name": "Scorecard",
    "description": "The class is a JPA Entity mapped to the 'm_survey_scorecards' table. It defines the schema for storing survey scores, including foreign keys to Survey, Question, Response, AppUser, and Client tables.",
    "databaseName": "m_survey_scorecards",
    "tablesAccessed": [
      "m_survey_scorecards"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA/Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_survey_scorecards\")\npublic class Scorecard extends AbstractPersistableCustom {\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = \"survey_id\")\n    private Survey survey;\n    // ..."
  },
  {
    "path": "org.apache.fineract.spm.domain.Survey",
    "mechanism": "JPA",
    "name": "Survey",
    "description": "The class is a JPA entity mapped to the 'm_surveys' table. It defines the schema for storing survey data and manages relationships with 'Component' and 'Question' entities via OneToMany mappings.",
    "databaseName": "m_surveys",
    "tablesAccessed": [
      "m_surveys"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_surveys\")\npublic class Survey extends AbstractPersistableCustom { ... }"
  },
  {
    "path": "org.apache.fineract.template.domain",
    "mechanism": "JPA",
    "name": "TemplateMapper",
    "description": "The class is a JPA Entity mapped to the 'm_templatemappers' database table using Jakarta Persistence annotations. It maps class fields to specific database columns.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_templatemappers"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard ORM entity mapping without explicit queries in this file.",
    "transactionHandling": "Implicitly handled by the JPA provider/container context.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_templatemappers\")\npublic class TemplateMapper extends AbstractPersistableCustom {\n    @Column(name = \"mapperorder\")\n    private int mapperorder;"
  },
  {
    "path": "org.apache.fineract.template.domain.Template",
    "mechanism": "JPA",
    "name": "Template",
    "description": "The class is a JPA entity mapped to the 'm_template' table. It uses standard JPA annotations to define column mappings, unique constraints, and relationships. Specifically, it defines a One-to-Many relationship with 'TemplateMapper' using a join table 'm_template_m_templatemappers'.",
    "databaseName": "m_template",
    "tablesAccessed": [
      "m_template",
      "m_template_m_templatemappers"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM mappings for CRUD operations",
    "transactionHandling": "JPA EntityTransaction (managed by container/context)",
    "protocol": "JPA 2.x / Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_template\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"unq_name\") })\npublic class Template extends AbstractPersistableCustom {\n    @Column(name = \"name\", nullable = false, unique = true)\n    private String name;\n    @OneToMany(targetEntity = TemplateMapper.class, cascade = CascadeType.ALL, fetch = FetchType.EAGER)\n    @JoinTable(name = \"m_template_m_templatemappers\"...)\n    private List<TemplateMapper> mappers;\n}"
  },
  {
    "path": "org.apache.fineract.template.service",
    "mechanism": "JPA",
    "name": "TemplateRepository",
    "description": "This interface defines service-level operations that delegate to a persistence layer (likely JPA/Hibernate based on the domain entities) to perform CRUD operations on Template data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Template"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and filtering by entity/type.",
    "transactionHandling": "Likely handled by Spring @Transactional in the implementation class.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "n/a"
  },
  {
    "path": "org.apache.fineract.useradministration.domain",
    "mechanism": "JPA",
    "name": "PasswordValidationPolicy",
    "description": "The class is a JPA Entity mapped to the 'm_password_validation_policy' table. It uses annotations to define the table name and column constraints (nullability).",
    "databaseName": "m_password_validation_policy",
    "tablesAccessed": [
      "m_password_validation_policy"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_password_validation_policy\")\npublic class PasswordValidationPolicy extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.useradministration.domain.AppUser",
    "mechanism": "JPA",
    "name": "AppUser Entity",
    "description": "The class is a JPA Entity mapped to the 'm_appuser' table. It uses standard Jakarta Persistence annotations to define columns, constraints, and relationships (ManyToOne with Office/Staff, ManyToMany with Role, OneToMany with AppUserClientMapping).",
    "databaseName": "m_appuser",
    "tablesAccessed": [
      "m_appuser",
      "m_appuser_role",
      "m_office",
      "m_staff",
      "m_appuser_client_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM-based CRUD operations managed by the persistence context.",
    "transactionHandling": "Implicitly handled by the service layer invoking this entity (likely Spring @Transactional).",
    "protocol": "JPA 3.0 / Hibernate",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_appuser\", uniqueConstraints = @UniqueConstraint(columnNames = { \"username\" }, name = \"username_org\"))\npublic class AppUser extends AbstractPersistableCustom implements PlatformUser { ... }"
  },
  {
    "path": "org.apache.fineract.useradministration.domain.AppUserClientMapping",
    "mechanism": "JPA",
    "name": "AppUserClientMapping",
    "description": "The class is a JPA Entity that maps directly to a relational database table. It uses annotations to define the table name and column relationships (foreign keys) to other entities.",
    "databaseName": "m_selfservice_user_client_mapping",
    "tablesAccessed": [
      "m_selfservice_user_client_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Entity\n@Table(name = \"m_selfservice_user_client_mapping\")\npublic class AppUserClientMapping extends AbstractPersistableCustom {\n    @ManyToOne(optional = false, cascade = CascadeType.ALL)\n    @JoinColumn(name = \"appuser_id\", nullable = false)\n    private AppUser appUser;"
  },
  {
    "path": "org.apache.fineract.useradministration.domain.AppUserPreviousPassword",
    "mechanism": "JPA",
    "name": "AppUserPreviousPassword",
    "description": "This class is a JPA Entity that maps directly to a relational database table. It uses Jakarta Persistence annotations to define the table name and column mappings.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_appuser_previous_password"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_appuser_previous_password\")\npublic class AppUserPreviousPassword extends AbstractPersistableCustom {"
  },
  {
    "path": "org.apache.fineract.useradministration.domain.Permission",
    "mechanism": "JPA",
    "name": "Permission",
    "description": "The class is a JPA Entity mapped to the 'm_permission' table. It uses Jakarta Persistence annotations to define the table mapping and column constraints.",
    "databaseName": "m_permission",
    "tablesAccessed": [
      "m_permission"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "JPA ENTITYTRANSACTION",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_permission\")\npublic class Permission extends AbstractPersistableCustom implements Serializable {"
  },
  {
    "path": "org.apache.fineract.useradministration.domain.Role",
    "mechanism": "JPA",
    "name": "Role Entity",
    "description": "The class is a JPA entity annotated with @Entity and @Table. It maps to the 'm_role' table in the database. It uses a Many-To-Many relationship with the Permission entity, managed via a join table named 'm_role_permission'.",
    "databaseName": "m_role",
    "tablesAccessed": [
      "m_role",
      "m_role_permission"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA ORM mapping with Eager fetching for permissions.",
    "transactionHandling": "Implicitly handled by the persistence context/container (likely Spring @Transactional in service layer).",
    "protocol": "JDBC/JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Entity\n@Table(name = \"m_role\", uniqueConstraints = { @UniqueConstraint(columnNames = { \"name\" }, name = \"unq_name\") })\npublic class Role extends AbstractPersistableCustom implements Serializable {\n    @ManyToMany(fetch = FetchType.EAGER)\n    @JoinTable(name = \"m_role_permission\", joinColumns = @JoinColumn(name = \"role_id\"), inverseJoinColumns = @JoinColumn(name = \"permission_id\"))\n    private Set<Permission> permissions = new HashSet<>();\n}"
  },
  {
    "path": "fineract-db/server_collation.cnf",
    "mechanism": "OTHER",
    "name": "MySQL Server Configuration",
    "description": "This file is a direct configuration for the MySQL database server itself, rather than application code that integrates with a database. It establishes the character set and collation rules for the server instance and client connections.",
    "databaseName": "Global Server Instance",
    "tablesAccessed": [],
    "operationType": [
      "ADMIN"
    ],
    "queryPatterns": "Configuration directives",
    "transactionHandling": "n/a",
    "protocol": "MySQL",
    "connectionInfo": "n/a",
    "codeExample": "[mysqld]\ncollation-server=utf8mb4_unicode_ci\ninit-connect='SET NAMES utf8mb4'"
  },
  {
    "path": "kubernetes/fineractmysql-deployment.yml",
    "mechanism": "OTHER",
    "name": "fineractmysql",
    "description": "This file does not connect to a database via an application layer but rather deploys the MariaDB database server itself within a Kubernetes cluster. It configures the container image, ports, storage volumes, and initialization scripts required to run the database service.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "ADMIN",
      "OTHER"
    ],
    "queryPatterns": "Infrastructure deployment, no application queries performed directly in this file.",
    "transactionHandling": "n/a",
    "protocol": "MariaDB 10.9",
    "connectionInfo": "Service: fineractmysql, Port: 3306",
    "codeExample": "containers:\n  - image: mariadb:10.9\n    name: mysql\n    ports:\n      - containerPort: 3306\n        name: fineractmysql"
  },
  {
    "path": "org.apache.fineract.accounting.accrual.handler.ExecutePeriodicAccrualCommandHandler",
    "mechanism": "OTHER",
    "name": "AccrualAccountingWritePlatformService",
    "description": "The class defines a transactional boundary using Spring's @Transactional annotation, implying interaction with a database via the injected service, although no direct SQL or repository calls are made in this file.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.executeLoansPeriodicAccrual(command);\n}"
  },
  {
    "path": "org.apache.fineract.accounting.closure.handler.CreateGLClosureCommandHandler",
    "mechanism": "OTHER",
    "name": "GLClosureWritePlatformService",
    "description": "This class defines the transaction boundary for database operations using Spring's `@Transactional` annotation, although the direct data access logic is delegated to the injected `GLClosureWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.createGLClosure(command);\n}"
  },
  {
    "path": "org.apache.fineract.accounting.closure.handler.UpdateGLClosureCommandHandler",
    "mechanism": "OTHER",
    "name": "Transaction Management",
    "description": "The class defines a transactional boundary using Spring's @Transactional annotation, ensuring that the GL closure update operation performed by the injected service is atomic. While it does not execute SQL directly, it manages the database transaction context.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.updateGLClosure(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.accounting.financialactivityaccount.handler.DeleteFinancialActivityAccountCommandHandler",
    "mechanism": "OTHER",
    "name": "FinancialActivityAccountWritePlatformService",
    "description": "This class orchestrates a database write operation (deletion) by defining a transaction boundary using Spring's `@Transactional` annotation and delegating the persistence logic to a service component.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.deleteGLAccountActivityMapping(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.handler",
    "mechanism": "OTHER",
    "name": "GLAccountWritePlatformService",
    "description": "The class manages database transactions via Spring's `@Transactional` annotation, although the direct database interaction (SQL/ORM) is delegated to the `GLAccountWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on the processCommand method",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.createGLAccount(command);\n}"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.handler",
    "mechanism": "OTHER",
    "name": "GLAccountWritePlatformService",
    "description": "The class manages the transaction boundary for a database write operation using Spring's `@Transactional` annotation, delegating the actual persistence logic to the `GLAccountWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GLACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.deleteGLAccount(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.accounting.provisioning.handler",
    "mechanism": "OTHER",
    "name": "ProvisioningEntriesWritePlatformService",
    "description": "The class uses Spring's @Transactional annotation to manage database transactions for the command processing, delegating the actual persistence logic to the ProvisioningEntriesWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand jsonCommand) {"
  },
  {
    "path": "org.apache.fineract.accounting.rule.handler",
    "mechanism": "OTHER",
    "name": "Transaction Management",
    "description": "The class uses Spring's `@Transactional` annotation to define transaction boundaries for the command processing, ensuring that the underlying service operations are executed within a database transaction.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {"
  },
  {
    "path": "org.apache.fineract.accounting.rule.handler.UpdateAccountingRuleCommandHandler",
    "mechanism": "OTHER",
    "name": "AccountingRuleWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's @Transactional annotation, ensuring that the database operations performed by the delegated service (AccountingRuleWritePlatformService) are executed within a transaction context.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.updateAccountingRule(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.adhocquery.handler.DeleteAdHocCommandHandler",
    "mechanism": "OTHER",
    "name": "AdHocWritePlatformService",
    "description": "The class manages the transaction boundary for a database write operation via Spring's @Transactional annotation, delegating the actual persistence logic to the AdHocWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.deleteAdHocQuery(command.entityId());\n    }"
  },
  {
    "path": "org.apache.fineract.cob.service",
    "mechanism": "OTHER",
    "name": "ConfigJobParameterService",
    "description": "The class uses Spring's `@Transactional` annotation to define a transaction boundary for the database update operation. While the direct SQL/ORM calls are likely inside the injected `ConfigJobParameterService`, this handler explicitly manages the transaction lifecycle for the 'UPDATE' action.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_BUSINESS_STEP"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Override\n@Transactional\npublic CommandProcessingResult processCommand(JsonCommand command) ..."
  },
  {
    "path": "org.apache.fineract.infrastructure.accountnumberformat.handler",
    "mechanism": "OTHER",
    "name": "AccountNumberFormatWritePlatformService",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation, although the direct database manipulation (SQL/ORM) is delegated to the injected service layer.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Override\n@Transactional\npublic CommandProcessingResult processCommand(JsonCommand command) {\n    return this.accountNumberFormatWritePlatformService.deleteAccountNumberFormat(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.handler",
    "mechanism": "OTHER",
    "name": "EmailCampaignWritePlatformService",
    "description": "The class manages the transaction boundary for database operations using Spring's @Transactional annotation, while delegating the actual data access logic to the EmailCampaignWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EMAIL_CAMPAIGN"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegated to service layer",
    "transactionHandling": "Spring @Transactional annotation on the processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.emailCampaignWritePlatformService.update(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.handler",
    "mechanism": "OTHER",
    "name": "EmailConfigurationWritePlatformService",
    "description": "The class manages database transactions using Spring's @Transactional annotation while delegating the actual persistence logic to a service layer. The @CommandType annotation indicates interaction with the 'EMAIL_CONFIGURATION' entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EMAIL_CONFIGURATION"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Service delegation within transaction",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.update(command);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.handler",
    "mechanism": "OTHER",
    "name": "EmailWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions, although the direct database access logic (SQL/JPA) is delegated to the `EmailWritePlatformService`. It ensures that the operation performed by the service is atomic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.create(command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.handler.CreateEmailCampaignCommandHandler",
    "mechanism": "OTHER",
    "name": "EmailCampaignWritePlatformService",
    "description": "The class integrates with the database indirectly by managing the transaction boundary for the write operation. It uses Spring's `@Transactional` annotation to ensure that the changes made by the `EmailCampaignWritePlatformService` are committed or rolled back atomically.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.emailCampaignWritePlatformService.create(command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.sms.handler",
    "mechanism": "OTHER",
    "name": "SmsCampaignWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation. While it does not contain direct SQL or JPA calls, it defines the transactional boundary for the `delete` operation which is delegated to the `SmsCampaignWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SMSCAMPAIGN"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.smsCampaignWritePlatformService.delete(command.entityId());\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.sms.handler",
    "mechanism": "OTHER",
    "name": "SmsCampaignWritePlatformService",
    "description": "This class manages the transaction boundary for database operations using Spring's `@Transactional` annotation, although the direct data access logic is delegated to the `SmsCampaignWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SMSCAMPAIGN"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.smsCampaignWritePlatformService.reactivateSmsCampaign(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.sms.handler",
    "mechanism": "OTHER",
    "name": "SmsCampaignWritePlatformService",
    "description": "The class orchestrates database updates by delegating to a service layer within a Spring `@Transactional` boundary. While it does not contain direct SQL or repository calls, it defines the transaction scope for the database write operation performed by the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.smsCampaignWritePlatformService.update(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.sms.handler.ActivateSmsCampaignCommandHandler",
    "mechanism": "OTHER",
    "name": "SmsCampaignWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions, ensuring that the activation operation performed by the `SmsCampaignWritePlatformService` is atomic. While it does not contain direct SQL or ORM calls, it defines the transaction boundary for database writes.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.smsCampaignWritePlatformService.activateSmsCampaign(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.handler.CreateCodeCommandHandler",
    "mechanism": "OTHER",
    "name": "CodeWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation. While it does not contain direct SQL or Repository calls, it defines the transaction boundary for the database write operation performed by the delegated `CodeWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.createCode(command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.handler.CreateCodeValueCommandHandler",
    "mechanism": "OTHER",
    "name": "CodeValueWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's @Transactional annotation, delegating the actual database write operation to the CodeValueWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CODEVALUE"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.createCodeValue(command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.handler.DeleteCodeValueCommandHandler",
    "mechanism": "OTHER",
    "name": "CodeValueWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation, although the specific database operations (SQL/JPA) are delegated to the injected `CodeValueWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.deleteCodeValue(command.entityId(), command.subentityId());\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.migration",
    "mechanism": "OTHER",
    "name": "Liquibase Migration Filter",
    "description": "This class is a utility for the Liquibase database migration framework. While it does not execute SQL or connect to a database directly, it controls which migration files (changelogs) are applied to the database schema.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "Liquibase",
    "connectionInfo": "n/a",
    "codeExample": "public boolean include(String changeLogPath) {\n    return changeLogPath.endsWith(\"module-changelog-master.xml\");\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.handler",
    "mechanism": "OTHER",
    "name": "OrganisationCreditBureauWritePlatflormService",
    "description": "The class manages the transaction boundary for database operations using Spring's @Transactional annotation, although the direct data access logic is delegated to the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.updateCreditBureau(command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.handler",
    "mechanism": "OTHER",
    "name": "ReadWriteNonCoreDataService",
    "description": "The class manages database transactions via the Spring `@Transactional` annotation. While it does not contain direct SQL or ORM calls, it defines the transaction boundary for the `updateDatatableEntryOneToMany` operation performed by the injected `ReadWriteNonCoreDataService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for update operations",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.updateDatatableEntryOneToMany(...);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.handler",
    "mechanism": "OTHER",
    "name": "ReadWriteNonCoreDataService",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation, but delegates the actual data access logic to the `ReadWriteNonCoreDataService`. It does not contain direct SQL or ORM calls itself.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.deleteDatatableEntry(command.entityName(), command.entityId(), command.subentityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.handler",
    "mechanism": "OTHER",
    "name": "ReadWriteNonCoreDataService",
    "description": "The class defines a database transaction boundary using Spring's @Transactional annotation, although the direct database manipulation is delegated to the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return writePlatformService.createDatatable(command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.handler",
    "mechanism": "OTHER",
    "name": "ReadWriteNonCoreDataService",
    "description": "The class manages a database transaction using Spring's `@Transactional` annotation while delegating the actual data persistence logic to the `ReadWriteNonCoreDataService`. It does not contain direct SQL or ORM calls but defines the transaction boundary for database operations.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    // ...\n    this.writePlatformService.updateDatatable(datatableName, command);\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.handler",
    "mechanism": "OTHER",
    "name": "ReadWriteNonCoreDataService",
    "description": "The class orchestrates database operations by delegating to the ReadWriteNonCoreDataService within a Spring-managed transaction. While the specific persistence mechanism (likely JDBC or DDL execution given the context of 'Datatables') is hidden in the service, this handler explicitly manages the transaction boundary for the write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    this.writePlatformService.registerDatatable(command);\n    return new CommandProcessingResultBuilder()...\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.handler",
    "mechanism": "OTHER",
    "name": "ReadWriteNonCoreDataService",
    "description": "The class manages database transactions via Spring's `@Transactional` annotation while delegating the actual data modification to the `ReadWriteNonCoreDataService`. While it does not contain direct SQL or ORM calls, it defines the transaction boundary for database write operations.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.deleteDatatableEntries(command.entityName(), command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.handler.CreateDatatableEntryCommandHandler",
    "mechanism": "OTHER",
    "name": "ReadWriteNonCoreDataService",
    "description": "The class manages database transactions via Spring's `@Transactional` annotation and delegates the actual data persistence logic to the `ReadWriteNonCoreDataService`. While it does not contain direct SQL or ORM calls, it defines the transaction boundary for a database write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return writePlatformService.createNewDatatableEntry(command.entityName(), command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.handler.UpdateOneToOneDatatableEntryCommandHandler",
    "mechanism": "OTHER",
    "name": "ReadWriteNonCoreDataService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation and delegates the actual database write operation to the `ReadWriteNonCoreDataService`. While it does not contain direct SQL or repository calls, it controls the transaction for the data modification.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    final CommandProcessingResult commandProcessingResult = this.writePlatformService.updateDatatableEntryOneToOne(command.entityName(),\n            command.entityId(), command);\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.handler.UpdateEntityToEntityMappingCommandHandler",
    "mechanism": "OTHER",
    "name": "FineractEntityAccessWriteService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation. It delegates the actual database write operation to the `FineractEntityAccessWriteService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(JsonCommand command) {\n    return this.fineractEntityAccessWriteService.updateEntityToEntityMapping(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.handler.ExternalEventConfigurationUpdateHandler",
    "mechanism": "OTHER",
    "name": "ExternalEventConfigurationWritePlatformService",
    "description": "This class manages the transaction boundary for database operations using Spring's `@Transactional` annotation, delegating the actual persistence logic to the `ExternalEventConfigurationWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on the processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(@NotNull final JsonCommand command) {\n    return writePlatformService.updateConfigurations(command);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.jobs.PurgeExternalEventsConfig",
    "mechanism": "OTHER",
    "name": "JobRepository",
    "description": "The class configures a Spring Batch Job which interacts with the database via the Spring Batch `JobRepository`. This repository is responsible for persisting job execution metadata, such as job instances, execution contexts, and step execution statuses. While this class does not contain direct SQL, it wires up the infrastructure that performs database operations for batch management.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_JOB_INSTANCE",
      "BATCH_JOB_EXECUTION",
      "BATCH_STEP_EXECUTION"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Batch internal repository operations (CRUD on batch metadata tables)",
    "transactionHandling": "Spring PlatformTransactionManager used in Step configuration",
    "protocol": "unknown",
    "connectionInfo": "configured via JobRepository and TransactionManager beans",
    "codeExample": "new JobBuilder(JobName.PURGE_EXTERNAL_EVENTS.name(), jobRepository)"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.handler",
    "mechanism": "OTHER",
    "name": "HookWritePlatformService",
    "description": "The class manages a database transaction via the Spring @Transactional annotation, wrapping a delete operation performed by the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.deleteHook(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.handler.CreateHookCommandHandler",
    "mechanism": "OTHER",
    "name": "HookWritePlatformService",
    "description": "The class defines the transaction boundary for database write operations using Spring's transaction management, although the direct database access logic resides in the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.createHook(command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.handler.UpdateHookCommandHandler",
    "mechanism": "OTHER",
    "name": "HookWritePlatformService",
    "description": "This class defines the transaction boundary for database operations using Spring's @Transactional annotation, although the direct database access is delegated to the injected HookWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.updateHook(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.filter",
    "mechanism": "OTHER",
    "name": "LoanCOBFilterHelper / PlatformTransactionManager",
    "description": "The class manages transaction boundaries using Spring's PlatformTransactionManager to suspend the current transaction. It delegates actual database read (calculating loan IDs) and write (executing inline COB) operations to the injected LoanCOBFilterHelper.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates complex logic to helper; likely involves selecting loan status and updating loan records.",
    "transactionHandling": "Spring TransactionTemplate with PROPAGATION_NOT_SUPPORTED to suspend existing transactions during the check.",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "TransactionTemplate tr = new TransactionTemplate(transactionManager);\ntr.setPropagationBehavior(TransactionDefinition.PROPAGATION_NOT_SUPPORTED);\nreturn tr.execute(status -> {\n    // ...\n    List<Long> result = helper.calculateRelevantLoanIds(relativeUrl);\n    if (!result.isEmpty() && helper.isLoanBehind(result)) {\n        helper.executeInlineCob(result);\n    }\n    // ...\n});"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service",
    "mechanism": "OTHER",
    "name": "SchedularWritePlatformService",
    "description": "This class manages a database transaction boundary using Spring's `@Transactional` annotation with `READ_COMMITTED` isolation. While it does not execute SQL directly, it delegates to `schedularService` which likely performs database writes or checks to manage job state.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegated to service layer",
    "transactionHandling": "Spring @Transactional(isolation = Isolation.READ_COMMITTED)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional(isolation = Isolation.READ_COMMITTED)\npublic boolean veto(Trigger trigger, JobExecutionContext context) { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service.increasedateby1day.increasebusinessdateby1day",
    "mechanism": "OTHER",
    "name": "JobRepository",
    "description": "The class configures a Spring Batch Job which relies on the injected JobRepository. The JobRepository is responsible for persisting job execution metadata (job instances, executions, steps, and contexts) to the underlying database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Batch internal repository operations",
    "transactionHandling": "Spring PlatformTransactionManager",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "new StepBuilder(JobName.INCREASE_BUSINESS_DATE_BY_1_DAY.name(), jobRepository)"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.handler",
    "mechanism": "OTHER",
    "name": "ReportMailingJobWritePlatformService",
    "description": "The class defines the transaction boundary for a database update operation using Spring's @Transactional annotation. While it does not execute SQL or JPA queries directly, it orchestrates the transaction for the underlying service which interacts with the database.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Override\n@Transactional\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n    return this.reportMailingJobWritePlatformService.updateReportMailingJob(jsonCommand.entityId(), jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.handler",
    "mechanism": "OTHER",
    "name": "ReportMailingJobWritePlatformService",
    "description": "The class manages database transactions via Spring's `@Transactional` annotation, although the direct database manipulation is delegated to the injected `ReportMailingJobWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegated to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Override\n@Transactional\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n    return this.reportMailingJobWritePlatformService.deleteReportMailingJob(jsonCommand.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.sms.handler",
    "mechanism": "OTHER",
    "name": "SmsWritePlatformService",
    "description": "The class manages the transaction boundary for database operations using Spring's @Transactional annotation, delegating the actual persistence logic to the SmsWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SMS"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates update logic to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.update(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.infrastructure.survey.handler.UpdateLikelihoodCommandHandler",
    "mechanism": "OTHER",
    "name": "WriteLikelihoodService",
    "description": "The class manages database transactions using Spring's @Transactional annotation, defining a transaction boundary for the update operation. The actual database interaction logic is delegated to the injected WriteLikelihoodService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LIKELIHOOD"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.update(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.interoperation.handler",
    "mechanism": "OTHER",
    "name": "InteropService",
    "description": "The class manages database transactions via the Spring @Transactional annotation, ensuring that the operations performed by the delegated InteropService are atomic. While it does not contain direct SQL or Repository calls, it defines the transaction boundary for the database write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    // ... parsing logic ...\n    return this.interopService.registerAccountIdentifier(idType, idValue, subIdOrType, command);\n}"
  },
  {
    "path": "org.apache.fineract.interoperation.handler",
    "mechanism": "OTHER",
    "name": "InteropService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL or JPA queries directly, it orchestrates a database write operation ('CREATE') by delegating to the `InteropService` within a transaction.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.interopService.createQuote(command);\n    }"
  },
  {
    "path": "org.apache.fineract.interoperation.handler.CreateInteropRequestHandler",
    "mechanism": "OTHER",
    "name": "InteropService",
    "description": "This class defines a transactional boundary using Spring's @Transactional annotation. While it does not execute SQL or JPA queries directly, it orchestrates database operations performed by the injected InteropService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.interopService.createTransactionRequest(command);\n}"
  },
  {
    "path": "org.apache.fineract.mix.handler",
    "mechanism": "OTHER",
    "name": "MixTaxonomyMappingWritePlatformService",
    "description": "The class manages database transactions via Spring's @Transactional annotation, although the direct database manipulation is delegated to the injected service. It acts as a transactional boundary for the 'XBRLMAPPING' update operation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "XBRLMAPPING"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writeTaxonomyService.updateMapping(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.organisation.holiday.handler",
    "mechanism": "OTHER",
    "name": "HolidayWritePlatformService",
    "description": "This class manages the transaction boundary for database operations using Spring's @Transactional annotation, but delegates the actual data access and modification logic to the HolidayWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on the processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.holidayWritePlatformService.updateHoliday(command);\n}"
  },
  {
    "path": "org.apache.fineract.organisation.monetary.handler.UpdateCurrencyCommandHandler",
    "mechanism": "OTHER",
    "name": "CurrencyWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to define a transaction boundary. While it does not execute SQL or call a repository directly, it delegates to `CurrencyWritePlatformService` which performs the actual database persistence operations for currency updates.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.updateAllowedCurrencies(command);\n}"
  },
  {
    "path": "org.apache.fineract.organisation.office.handler.CreateOfficeCommandHandler",
    "mechanism": "OTHER",
    "name": "OfficeWritePlatformService",
    "description": "The class manages database transaction boundaries using Spring's `@Transactional` annotation. While it does not execute SQL or JPA queries directly, it wraps the execution of the `OfficeWritePlatformService` in a transaction, implying that the service performs database write operations.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.createOffice(command);\n    }"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.handler",
    "mechanism": "OTHER",
    "name": "ProvisioningCriteriaWritePlatformService",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL or JPA queries directly, it orchestrates the write operation which is performed by the injected `ProvisioningCriteriaWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n    return this.provisioningCriteriaWritePlatformService.createProvisioningCriteria(jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.handler",
    "mechanism": "OTHER",
    "name": "ProvisioningCriteriaWritePlatformService",
    "description": "The class manages database transaction boundaries using Spring's @Transactional annotation, ensuring that the delegated service operations are executed within a transaction context, although it does not perform direct SQL or repository calls itself.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.handler",
    "mechanism": "OTHER",
    "name": "ProvisioningCriteriaWritePlatformService",
    "description": "The class manages database transactions using Spring's @Transactional annotation, ensuring the delete operation performed by the delegate service is atomic. While it does not contain direct SQL or Repository calls, it defines the transaction boundary for database writes.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PROVISIONCRITERIA"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n        return this.provisioningCriteriaWritePlatformService.deleteProvisioningCriteria(jsonCommand.entityId());\n    }"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.handler",
    "mechanism": "OTHER",
    "name": "ProvisioningCategoryWritePlatformService",
    "description": "The class manages database transactions using Spring's @Transactional annotation, delegating the actual data persistence logic to the ProvisioningCategoryWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n        return this.provisioningCategoryWritePlatformService.createProvisioningCateogry(jsonCommand);\n    }"
  },
  {
    "path": "org.apache.fineract.organisation.staff.handler.CreateStaffCommandHandler",
    "mechanism": "OTHER",
    "name": "StaffWritePlatformService",
    "description": "The class orchestrates database interactions by defining a transaction boundary using Spring's `@Transactional` annotation, but delegates the specific data access logic to the `StaffWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.createStaff(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.account.handler.CreateAccountTransferCommandHandler",
    "mechanism": "OTHER",
    "name": "AccountTransfersWritePlatformService",
    "description": "This class defines a transaction boundary using Spring's `@Transactional` annotation, but delegates the actual database interaction to the `AccountTransfersWritePlatformService`. While it does not contain direct SQL or ORM calls, it controls the transaction context for the database write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.create(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.handler.CreateCalendarCommandHandler",
    "mechanism": "OTHER",
    "name": "CalendarWritePlatformService",
    "description": "The class manages database transactions via the Spring `@Transactional` annotation but delegates the actual data access and persistence logic to the `CalendarWritePlatformService`. It does not contain direct SQL or ORM calls itself.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.createCalendar(command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.client.handler",
    "mechanism": "OTHER",
    "name": "ClientWritePlatformService",
    "description": "This class defines the transaction boundary using Spring's @Transactional annotation, but delegates the actual database operations to the ClientWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.clientWritePlatformService.undoRejection(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.client.handler",
    "mechanism": "OTHER",
    "name": "ClientChargeWritePlatformService",
    "description": "This class defines a transactional boundary using Spring's `@Transactional` annotation. While it does not execute SQL directly, it orchestrates the write operation by delegating to `ClientChargeWritePlatformService`, which performs the actual database persistence.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.addCharge(command.getClientId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.client.handler",
    "mechanism": "OTHER",
    "name": "ClientChargeWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL directly, it delegates to `ClientChargeWritePlatformService` which performs the database write operation to waive the charge.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client_charge"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.waiveCharge(command.getClientId(), command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.client.handler.DeleteClientChargeCommandHandler",
    "mechanism": "OTHER",
    "name": "ClientChargeWritePlatformService",
    "description": "The class manages database transactions via Spring's `@Transactional` annotation, delegating the actual persistence logic to the injected `ClientChargeWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.deleteCharge(command.getClientId(), command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.client.handler.UpdateClientCommandHandler",
    "mechanism": "OTHER",
    "name": "ClientWritePlatformService",
    "description": "The class manages database transactions via the Spring `@Transactional` annotation, although the direct database access logic is delegated to the `ClientWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CLIENT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.clientWritePlatformService.updateClient(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.collateral.handler",
    "mechanism": "OTHER",
    "name": "CollateralWritePlatformService",
    "description": "The class manages database transactions via Spring's `@Transactional` annotation but delegates the actual database modification logic to the `CollateralWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "COLLATERAL"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.collateralWritePlatformService.deleteCollateral(...);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.collectionsheet.handler.UpdateCollectionSheetCommandHandler",
    "mechanism": "OTHER",
    "name": "CollectionSheetWritePlatformService",
    "description": "The class orchestrates database interactions by defining a transaction boundary using Spring's `@Transactional` annotation. While it does not contain direct SQL or JPA calls, it delegates to `CollectionSheetWritePlatformService` which performs the actual data persistence operations.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.collectionSheetWritePlatformService.updateCollectionSheet(command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.handler",
    "mechanism": "OTHER",
    "name": "DelinquencyWritePlatformService",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation, although the direct database manipulation is delegated to the `DelinquencyWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegated to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.updateDelinquencyRange(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.handler.CreateDelinquencyBucketCommandHandler",
    "mechanism": "OTHER",
    "name": "DelinquencyWritePlatformService",
    "description": "This class orchestrates database interactions by defining a transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL or call a repository directly, it delegates to `DelinquencyWritePlatformService` which performs the persistence operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DELINQUENCY_BUCKET"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.createDelinquencyBucket(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.handler.DeleteDelinquencyRangeCommandHandler",
    "mechanism": "OTHER",
    "name": "DelinquencyWritePlatformService",
    "description": "The class manages the transaction boundary for a database write operation using Spring's `@Transactional` annotation, although the actual data access logic resides in the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.deleteDelinquencyRange(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.floatingrates.handler.UpdateFloatingRateCommandHandler",
    "mechanism": "OTHER",
    "name": "FloatingRateWritePlatformService",
    "description": "The class manages database transactions via Spring's @Transactional annotation, delegating the actual data persistence to the FloatingRateWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FLOATINGRATE (inferred from entity name)"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.updateFloatingRate(command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.group.handler",
    "mechanism": "OTHER",
    "name": "GroupingTypesWritePlatformService",
    "description": "The class manages database transactions via Spring's @Transactional annotation, although the direct database operations are delegated to the GroupingTypesWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    final Long centerId = command.longValueOfParameterNamed(\"centerId\");\n    return this.groupWritePlatformService.createGroup(centerId, command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.group.handler",
    "mechanism": "OTHER",
    "name": "GroupRolesWritePlatformService",
    "description": "This class defines a transactional boundary using Spring's @Transactional annotation. While it does not execute SQL directly, it orchestrates a database write operation by delegating to the GroupRolesWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Override\n@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.groupRolesWritePlatformService.updateRole(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.group.handler",
    "mechanism": "OTHER",
    "name": "GroupingTypesWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation and delegates data modification logic to the `GroupingTypesWritePlatformService`. While it does not contain direct SQL or ORM calls, it orchestrates a database write operation via the service layer.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand command) {\n    return this.writePlatformService.disassociateGroupsToCenter(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.group.handler",
    "mechanism": "OTHER",
    "name": "GroupingTypesWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation, delegating the actual database write operation (delete) to the injected `GroupingTypesWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.groupWritePlatformService.deleteGroup(command.entityId());\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.group.handler.UpdateGroupCommandHandler",
    "mechanism": "OTHER",
    "name": "GroupingTypesWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's @Transactional annotation, orchestrating database writes via the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.groupWritePlatformService.updateGroup(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanApplicationWritePlatformService",
    "description": "The class defines a database transaction boundary using Spring's @Transactional annotation. While it does not execute SQL directly, it manages the transaction for the underlying service layer which interacts with the database.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.undoApplicationApproval(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanApplicationWritePlatformService",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL directly, it orchestrates a write operation (loan approval) via the injected service layer within a transaction context.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.approveApplication(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanApplicationWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation, but delegates the actual database interaction to the injected `LoanApplicationWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.submitApplication(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanApplicationWritePlatformService",
    "description": "The class orchestrates a database transaction using Spring's `@Transactional` annotation, although the direct data access logic is delegated to the `LoanApplicationWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.applicantWithdrawsFromApplication(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanWritePlatformService",
    "description": "This class defines a transaction boundary using Spring's `@Transactional` annotation, but delegates the actual data access and persistence logic to the `LoanWritePlatformService`. While it does not contain direct SQL or Repository calls, it controls the transaction for a database write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.waiveInterestOnLoan(command.getLoanId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanApplicationWritePlatformService",
    "description": "This class manages database transactions using Spring's `@Transactional` annotation, although the direct database access logic (SQL/JPA) is delegated to the injected `LoanApplicationWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.approveGLIMLoanAppication(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanChargeWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation and delegates the actual database write operation (deletion) to the `LoanChargeWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_charge"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for deletion logic",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.deleteLoanCharge(command.getLoanId(), command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanChargeWritePlatformService",
    "description": "The class defines a transactional boundary using Spring's @Transactional annotation and delegates the actual database write operation to the LoanChargeWritePlatformService. While it does not contain direct SQL or JPA calls, it orchestrates the persistence flow for the Loan Charge entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LOANCHARGE"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on the processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.updateLoanCharge(command.getLoanId(), command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanChargeWritePlatformService",
    "description": "This class does not perform direct database operations (SQL/JPA) itself but defines a transaction boundary using Spring's `@Transactional` annotation. It delegates the actual data persistence logic to the `LoanChargeWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return writePlatformService.adjustmentForLoanCharge(...);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanChargeWritePlatformService",
    "description": "This class participates in database integration by defining the transaction boundary using Spring's `@Transactional` annotation, although the direct database operations are delegated to the `LoanChargeWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.payLoanCharge(command.getLoanId(), ...);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler",
    "mechanism": "OTHER",
    "name": "LoanWritePlatformService",
    "description": "This class defines a transaction boundary using Spring's `@Transactional` annotation, implying interaction with the database occurs within the called service method. While it does not contain direct SQL or Repository calls, it orchestrates a write operation (Disbursement) that persists state changes to the database via the injected `LoanWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.disburseGLIMLoan(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.AddAndDeleteLoanDisburseDetailsCommandHandler",
    "mechanism": "OTHER",
    "name": "LoanWritePlatformService",
    "description": "This class defines a transactional boundary using Spring's @Transactional annotation. It delegates the actual database operations to the LoanWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.addAndDeleteLoanDisburseDetails(command.getLoanId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.GLIMApplicationRejectionCommandHandler",
    "mechanism": "OTHER",
    "name": "LoanApplicationWritePlatformService",
    "description": "This class manages the transaction boundary for database operations using Spring's `@Transactional` annotation. While it does not execute SQL or access repositories directly, it orchestrates the transaction for the `LoanApplicationWritePlatformService` which performs the actual database writes.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.rejectGLIMApplicationApproval(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.LoanApplicationModificationCommandHandler",
    "mechanism": "OTHER",
    "name": "LoanApplicationWritePlatformService",
    "description": "This class defines a transactional boundary using Spring's `@Transactional` annotation, orchestrating database writes by delegating to the `LoanApplicationWritePlatformService`. While it does not execute SQL directly, it controls the transaction for the database update operation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on the processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.modifyApplication(command.getLoanId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.RemoveLoanOfficerCommandHandler",
    "mechanism": "OTHER",
    "name": "LoanWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation, implying database interactions occur within the called service method. It delegates the actual data persistence logic to `LoanWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.removeLoanOfficer(command.getLoanId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.UndoChargeOffLoanCommandHandler",
    "mechanism": "OTHER",
    "name": "LoanWritePlatformService",
    "description": "This class defines a database transaction boundary using Spring's @Transactional annotation, ensuring that the delegated service operation is executed within a transaction context, although it does not perform direct SQL or ORM operations itself.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return writePlatformService.undoChargeOff(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.UndoGLIMLoanApplicationApproval",
    "mechanism": "OTHER",
    "name": "LoanApplicationWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to define a transaction boundary for the operation. While it does not execute SQL or JPA calls directly, it delegates to `LoanApplicationWritePlatformService` which performs the actual database writes.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.undoGLIMLoanApplicationApproval(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.UndoGLIMLoanDisbursalCommandHandler",
    "mechanism": "OTHER",
    "name": "LoanWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions, although the direct data access logic is delegated to the `LoanWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.undoGLIMLoanDisbursal(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.handler.UpdateLoanDisburseDateCommandHandler",
    "mechanism": "OTHER",
    "name": "LoanWritePlatformService",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL directly, it delegates to `LoanWritePlatformService` which performs the actual database write operations.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.updateDisbursementDateAndAmountForTranche(command.getLoanId(), command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.jobs.updateloanarrearsageing",
    "mechanism": "OTHER",
    "name": "Spring Batch Repository",
    "description": "The class configures Spring Batch components which implicitly interact with the database to persist job execution metadata (JobInstance, JobExecution, StepExecution) via the injected JobRepository. It also configures a PlatformTransactionManager to handle transactions during the batch step execution.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_JOB_INSTANCE",
      "BATCH_JOB_EXECUTION",
      "BATCH_STEP_EXECUTION"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Batch internal metadata management (CRUD on batch tables)",
    "transactionHandling": "Spring @Transactional via PlatformTransactionManager",
    "protocol": "JDBC (implied by Spring Batch)",
    "connectionInfo": "unknown",
    "codeExample": "new StepBuilder(JobName.UPDATE_LOAN_ARREARS_AGEING.name(), jobRepository)\n        .tasklet(updateLoanArrearsAgeingTasklet(), transactionManager)"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.rescheduleloan.handler",
    "mechanism": "OTHER",
    "name": "LoanRescheduleRequestWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation, wrapping the operations performed by the `LoanRescheduleRequestWritePlatformService`. While it does not execute SQL directly, it defines the transaction boundary for the database interactions.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n        return this.loanRescheduleRequestWritePlatformService.create(jsonCommand);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.productmix.handler",
    "mechanism": "OTHER",
    "name": "ProductMixWritePlatformService",
    "description": "This class manages the transaction boundary for database operations using Spring's @Transactional annotation, while the actual data access and modification are delegated to the ProductMixWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PRODUCTMIX"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegated to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.productMixWritePlatformService.updateProductMix(command.getProductId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.handler",
    "mechanism": "OTHER",
    "name": "MeetingWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation, ensuring that the delegated service operation runs within a transaction context. The actual data access logic is performed by the injected `MeetingWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.deleteMeeting(command.entityId());\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.handler.UpdateMeetingAttendanceCommandHandler",
    "mechanism": "OTHER",
    "name": "MeetingWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation. While it does not contain direct SQL or ORM calls, it orchestrates database write operations by delegating to `MeetingWritePlatformService` within a transactional context.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.saveOrUpdateAttendance(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.note.handler",
    "mechanism": "OTHER",
    "name": "NoteWritePlatformService",
    "description": "This class defines the transaction boundary for database write operations but delegates the actual data access to the NoteWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.createNote(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.note.handler.UpdateNoteCommandHandler",
    "mechanism": "OTHER",
    "name": "NoteWritePlatformService",
    "description": "This class manages the transaction boundary for database operations using Spring's `@Transactional` annotation, though the direct database access logic is delegated to the injected `NoteWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.updateNote(command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.repaymentwithpostdatedchecks.handler",
    "mechanism": "OTHER",
    "name": "RepaymentWithPostDatedChecksWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation, ensuring that the update operation performed by the underlying service is atomic. While it does not execute SQL directly, it controls the transaction boundary for the database interaction.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.repaymentWithPostDatedChecksWritePlatformService.updatePostDatedChecks(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositAccountWritePlatformService",
    "description": "The class manages database transactions via the Spring `@Transactional` annotation, delegating the actual data persistence and modification logic to the injected `DepositAccountWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FIXEDDEPOSITACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.depositAccountWritePlatformService.activateFDAccount(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "SavingsApplicationProcessWritePlatformService",
    "description": "This class manages the transaction boundary for database writes using Spring's @Transactional annotation, but delegates the actual data access and persistence logic to the SavingsApplicationProcessWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.savingAccountWritePlatformService.rejectGSIMApplication(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositApplicationProcessWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions, delegating the actual persistence operations to the `DepositApplicationProcessWritePlatformService`. While it does not contain direct SQL or ORM calls, it defines the transactional boundary for the database write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.depositAccountWritePlatformService.rejectApplication(command.entityId(), command, DepositAccountType.FIXED_DEPOSIT);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "TransactionManagement",
    "description": "This class does not execute SQL directly but defines a transaction boundary using Spring's `@Transactional` annotation. This ensures that the database operations performed by the injected `SavingsAccountWritePlatformService` are committed or rolled back atomically.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.withdrawal(command.getSavingsId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "SavingsApplicationProcessWritePlatformService",
    "description": "This class defines a transaction boundary using Spring's @Transactional annotation, but delegates the actual database interaction to the injected SavingsApplicationProcessWritePlatformService. While it does not contain direct SQL or Repository calls, it controls the transaction context for the database write operation (deletion).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.savingAccountWritePlatformService.deleteApplication(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositAccountWritePlatformService",
    "description": "The class defines a transactional boundary using Spring's \"@Transactional\" annotation, ensuring that the withdrawal operation performed by the delegated service is atomic. While it does not execute SQL directly, it controls the transaction context for the database operations executed by the \"DepositAccountWritePlatformService\".",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RECURRINGDEPOSITACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotation on the processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.depositAccountWritePlatformService.withdrawal(command.entityId(), command, DepositAccountType.RECURRING_DEPOSIT);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "Transaction Management",
    "description": "The class does not perform direct database queries but manages database transaction boundaries using Spring's `@Transactional` annotation before delegating to the service layer.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositAccountWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation while delegating the actual data persistence logic to the `DepositAccountWritePlatformService`. It does not execute SQL directly but controls the transaction boundary for the operation.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    final Long transactionId = Long.valueOf(command.getTransactionId());\n    return this.depositAccountWritePlatformService.undoFDTransaction(command.entityId(), transactionId, false);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositAccountWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation, ensuring that the delegated service operation runs within a transaction context. While it does not execute SQL directly, it orchestrates the transactional boundary for the database write operation performed by the service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RECURRINGDEPOSITACCOUNT"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        final Long transactionId = Long.valueOf(command.getTransactionId());\n        return this.depositAccountWritePlatformService.adjustRDTransaction(command.entityId(), transactionId, command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "Spring Transaction Management",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation. While it does not contain direct SQL or ORM calls itself, it orchestrates a service method (`depositAccountWritePlatformService.calculateInterest`) that performs database write operations (calculating and persisting interest data).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to service layer for business logic and persistence",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.depositAccountWritePlatformService.calculateInterest(command.entityId(), DepositAccountType.RECURRING_DEPOSIT);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositApplicationProcessWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation while delegating the actual data modification to the `DepositApplicationProcessWritePlatformService`. While it does not contain direct SQL or Repository calls, it defines the transactional boundary for a database write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RECURRING_DEPOSIT_ACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.depositAccountWritePlatformService.deleteApplication(command.entityId(), DepositAccountType.RECURRING_DEPOSIT);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositAccountWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions, although the actual data access logic is delegated to the `DepositAccountWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.depositAccountWritePlatformService.closeRDAccount(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositAccountWritePlatformService",
    "description": "The class orchestrates database writes by defining a transaction boundary using Spring's @Transactional annotation and delegating to a service layer component that performs the actual persistence operations.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.depositAccountWritePlatformService.updateDepositAmountForRDAccount(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositAccountWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation, ensuring that the downstream database operations performed by the `DepositAccountWritePlatformService` are atomic. While it does not contain direct SQL or ORM calls, it defines the transaction boundary for database writes.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.depositAccountWritePlatformService.closeFDAccount(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "SavingsApplicationProcessWritePlatformService",
    "description": "The class manages database transactions via Spring's @Transactional annotation, although the direct database operations are delegated to the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n\n        return this.writePlatformService.undoApplicationApproval(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "SavingsApplicationProcessWritePlatformService",
    "description": "The class defines a transactional boundary using Spring's `@Transactional` annotation. It delegates the actual database persistence and business logic to the `SavingsApplicationProcessWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.applicantWithdrawsFromApplication(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "SavingsApplicationProcessWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL or JPA queries directly, it orchestrates a unit of work that modifies database state via the injected `SavingsApplicationProcessWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GSIMACCOUNT (implied by CommandType)"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.savingAccountWritePlatformService.modifyGSIMApplication(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "SavingsApplicationProcessWritePlatformService",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL or JPA queries directly, it orchestrates a write operation by delegating to a service layer that interacts with the database.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.savingAccountWritePlatformService.modifyApplication(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "SavingsApplicationProcessWritePlatformService",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL directly, it orchestrates a write operation (creation of a savings account) by delegating to a service layer that interacts with the database.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.savingAccountWritePlatformService.submitApplication(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "SavingsAccountWritePlatformService",
    "description": "The class orchestrates database interactions by defining a transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL directly, it delegates to the `SavingsAccountWritePlatformService` which performs the actual database write operations to block the account.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.writePlatformService.blockAccount(command.getSavingsId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "SavingsAccountWritePlatformService",
    "description": "The class does not execute SQL or access repositories directly, but it manages database transactions via the Spring `@Transactional` annotation. It delegates the actual persistence operations to the `SavingsAccountWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand command) {\n    return this.writePlatformService.inactivateCharge(command.getSavingsId(), command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "SavingsAccountWritePlatformService",
    "description": "The class defines a database transaction boundary using Spring's `@Transactional` annotation, ensuring the savings account closure operation is atomic. While it does not execute SQL directly, it orchestrates the write operation via the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SAVINGSACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.close(command.getSavingsId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositAccountWritePlatformService",
    "description": "The class defines a database transaction boundary using the Spring @Transactional annotation. While it does not execute SQL directly, it orchestrates the transaction for the underlying service layer which interacts with the database.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.depositAccountWritePlatformService.depositToFDAccount(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositApplicationProcessWritePlatformService",
    "description": "This class defines a transaction boundary using Spring's @Transactional annotation but delegates the actual database persistence operations to the injected DepositApplicationProcessWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_savings_account_transaction"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.depositAccountWritePlatformService.approveApplication(...);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "OTHER",
    "name": "DepositApplicationProcessWritePlatformService",
    "description": "This class participates in database integration by defining a transaction boundary using Spring's `@Transactional` annotation. While it does not execute SQL or call repositories directly, it delegates to a service that performs write operations on the database.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.depositAccountWritePlatformService.rejectApplication(command.entityId(), command, DepositAccountType.RECURRING_DEPOSIT);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler.CloseGSIMCommandHandler",
    "mechanism": "OTHER",
    "name": "SavingsAccountWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation. While it does not contain direct SQL or Repository calls, it defines the transaction boundary for the `bulkGSIMClose` operation performed by the injected service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GSIMACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for update operations",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.bulkGSIMClose(command.getSavingsId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler.RecurringDepositAccountApplicationSubmittalCommandHandler",
    "mechanism": "OTHER",
    "name": "TransactionManagement",
    "description": "The class uses Spring's declarative transaction management to define transaction boundaries for the command processing, although it does not execute direct SQL queries itself.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler.UnblockSavingsAccountCommandHandler",
    "mechanism": "OTHER",
    "name": "SavingsAccountWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to define a transaction boundary for the operation. While it does not contain direct JDBC or JPA calls itself, it orchestrates the transaction for the underlying `SavingsAccountWritePlatformService` which performs the actual database writes.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.writePlatformService.unblockAccount(command.getSavingsId());\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.self.pockets.handler",
    "mechanism": "OTHER",
    "name": "PocketWritePlatformService",
    "description": "The class orchestrates a database transaction using Spring's `@Transactional` annotation, although the direct database manipulation logic is delegated to the `PocketWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.pocketWritePlatformService.delinkAccounts(command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.handler",
    "mechanism": "OTHER",
    "name": "ShareAccountWritePlatformService",
    "description": "The class defines a transactional boundary using Spring's `@Transactional` annotation, implying interaction with the database through the delegated service. While this specific file does not contain SQL or Repository calls, it manages the transaction context for the database operations performed by the `ShareAccountWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n        return this.shareAccountWritePlatformService.rejectAdditionalShares(jsonCommand.entityId(), jsonCommand);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.handler",
    "mechanism": "OTHER",
    "name": "ShareAccountWritePlatformService",
    "description": "This class manages the transaction boundary for database operations using Spring's `@Transactional` annotation. While it does not execute SQL or JPA queries directly, it delegates to `ShareAccountWritePlatformService` which performs the actual database write operations for the 'SHAREACCOUNT' entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SHAREACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n    return this.shareAccountWritePlatformService.updateShareAccount(jsonCommand.entityId(), jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.handler",
    "mechanism": "OTHER",
    "name": "ShareAccountWritePlatformService",
    "description": "This class does not perform direct database operations (SQL/JPA) itself but manages the transaction boundary for database interactions. It uses Spring's `@Transactional` annotation to ensure that the operations performed by the called service (`ShareAccountWritePlatformService`) occur within a transaction context.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n        return this.shareAccountWritePlatformService.approveShareAccount(jsonCommand.entityId(), jsonCommand);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.handler",
    "mechanism": "OTHER",
    "name": "ShareAccountWritePlatformService",
    "description": "This class acts as a transactional wrapper around the business service. While it does not execute SQL directly, it defines the transaction boundary using Spring's `@Transactional` annotation, delegating the actual database persistence operations to the `ShareAccountWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n        return this.shareAccountWritePlatformService.undoApproveShareAccount(jsonCommand.entityId(), jsonCommand);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.handler.ApproveAddtionalSharesCommandHandler",
    "mechanism": "OTHER",
    "name": "ShareAccountWritePlatformService",
    "description": "This class defines the transaction boundary for database operations using Spring's @Transactional annotation, although the direct database access logic resides in the injected ShareAccountWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n    return this.shareAccountWritePlatformService.approveAdditionalShares(jsonCommand.entityId(), jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.handler.CreateShareAccountCommandHandler",
    "mechanism": "OTHER",
    "name": "ShareAccountWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's @Transactional annotation, ensuring that the database operations performed by the called service are atomic. While it does not execute SQL directly, it controls the transaction context for the database write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n        return this.shareAccountWritePlatformService.createShareAccount(jsonCommand);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.handler.RejectShareAccountCommandHandler",
    "mechanism": "OTHER",
    "name": "ShareAccountWritePlatformService",
    "description": "The class manages database transactions using Spring's `@Transactional` annotation. It does not perform direct database queries itself but delegates the persistence operations to the `ShareAccountWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n    return this.shareAccountWritePlatformService.rejectShareAccount(jsonCommand.entityId(), jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.handler.CreateShareProductCommandHandler",
    "mechanism": "OTHER",
    "name": "ShareProductWritePlatformService",
    "description": "The class manages database transactions using Spring's @Transactional annotation, wrapping the database operations performed by the injected ShareProductWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SHAREPRODUCT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n    return this.shareProductWritePlatformService.createShareProduct(jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.transfer.handler",
    "mechanism": "OTHER",
    "name": "TransferWritePlatformService",
    "description": "The class manages database transactions via Spring's @Transactional annotation, although the direct database operations are delegated to the injected TransferWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegated to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.proposeAndAcceptClientTransfer(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.transfer.handler",
    "mechanism": "OTHER",
    "name": "TransferWritePlatformService",
    "description": "The class manages database transactions via the Spring `@Transactional` annotation but delegates the actual data access and modification to the `TransferWritePlatformService`. It does not contain direct SQL or Repository calls itself, but acts as the transactional boundary for the write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.writePlatformService.rejectClientTransfer(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.useradministration.handler",
    "mechanism": "OTHER",
    "name": "PasswordPreferencesWritePlatformService",
    "description": "The class defines a transaction boundary using Spring's `@Transactional` annotation, implying interaction with a transactional resource (database) via the delegated service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PASSWORD_PREFERENCES"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.updatePreferences(command);\n}"
  },
  {
    "path": "org.apache.fineract.useradministration.handler",
    "mechanism": "OTHER",
    "name": "AppUserWritePlatformService",
    "description": "The class defines a transactional boundary for the user creation operation using Spring's @Transactional annotation, ensuring that the database operations performed by the delegated service are atomic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "USER"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates creation logic to service layer",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {"
  },
  {
    "path": "org.apache.fineract.useradministration.handler",
    "mechanism": "OTHER",
    "name": "RoleWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to manage database transactions. It delegates the actual database write operation to the `RoleWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.updateRolePermissions(command.entityId(), command);\n}"
  },
  {
    "path": "fineract-loan/dependencies.gradle",
    "mechanism": "SPRING-DATA",
    "name": "Spring Data JPA / EclipseLink",
    "description": "The build script configures the application to use Spring Data JPA for database access. It specifically overrides the default Hibernate provider to use EclipseLink by excluding the Hibernate group from the starter dependency and explicitly adding the EclipseLink library.",
    "databaseName": "not identifiable from code",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "n/a (Dependency configuration only)",
    "transactionHandling": "n/a (Dependency configuration only)",
    "protocol": "JPA (EclipseLink)",
    "connectionInfo": "n/a",
    "codeExample": "implementation ('org.springframework.boot:spring-boot-starter-data-jpa') {\n    exclude group: 'org.hibernate'\n}\nimplementation('org.eclipse.persistence:org.eclipse.persistence.jpa') {\n    exclude group: 'org.eclipse.persistence', module: 'jakarta.persistence'\n}"
  },
  {
    "path": "org.apache.fineract.accounting.closure.domain.GLClosureRepository",
    "mechanism": "SPRING-DATA",
    "name": "GLClosureRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends `JpaRepository` to provide standard data access methods and defines a custom JPQL query for specific business logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GLClosure"
    ],
    "operationType": [
      "READ_WRITE",
      "READ"
    ],
    "queryPatterns": "JPQL query containing a subquery and aggregation (MAX) to filter by date and foreign key.",
    "transactionHandling": "Spring @Transactional (implicitly handled by Spring Data JPA implementation)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select closure from GLClosure closure where closure.closingDate = (select max(closure1.closingDate) from GLClosure closure1 where closure1.office.id=:officeId)  and closure.office.id= :officeId\")\nGLClosure getLatestGLClosureByBranch(@Param(\"officeId\") Long officeId);"
  },
  {
    "path": "org.apache.fineract.accounting.closure.service",
    "mechanism": "SPRING-DATA",
    "name": "GLClosureRepository",
    "description": "The class uses Spring Data JPA repositories (GLClosureRepository and OfficeRepositoryWrapper) to interact with the database. It performs CRUD operations on GLClosure entities and read operations on Office entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GLClosure",
      "Office"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, findById, delete) and a custom query method (getLatestGLClosureByBranch).",
    "transactionHandling": "Spring @Transactional annotations are used on all public service methods to manage transaction boundaries.",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "this.glClosureRepository.saveAndFlush(glClosure);"
  },
  {
    "path": "org.apache.fineract.accounting.financialactivityaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "FinancialActivityAccountRepository",
    "description": "The class wraps a Spring Data repository interface to perform database operations on FinancialActivityAccount entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FinancialActivityAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations delegated to Spring Data JPA repository.",
    "transactionHandling": "Implicitly handled by the underlying Spring Data repository implementation.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return this.repository.findById(id).orElseThrow(() -> new FinancialActivityAccountNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.accounting.financialactivityaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "FinancialActivityAccountRepository",
    "description": "The file uses Spring Data JPA repositories to interact with the database. It extends JpaRepository to provide standard data access methods and defines a custom JPQL query for specific retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FinancialActivityAccount"
    ],
    "operationType": [
      "READ_WRITE",
      "READ"
    ],
    "queryPatterns": "JPQL queries defined via annotations",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data Repositories)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select faa from FinancialActivityAccount faa where faa.financialActivityType = :financialActivityType\")"
  },
  {
    "path": "org.apache.fineract.accounting.financialactivityaccount.service",
    "mechanism": "SPRING-DATA",
    "name": "FinancialActivityAccountRepositoryWrapper",
    "description": "The class uses repository wrappers (likely wrapping Spring Data JPA repositories) to perform CRUD operations on `FinancialActivityAccount` and `GLAccount` entities. It handles persistence exceptions and performs explicit `saveAndFlush` operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FinancialActivityAccount",
      "GLAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via repository methods (findOne, save, delete).",
    "transactionHandling": "Likely handled by Spring's @Transactional at the interface level or default repository behavior, though not explicitly annotated in this class file.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.financialActivityAccountRepository.saveAndFlush(financialActivityAccount);"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "TrialBalanceRepository",
    "description": "The class interacts with the database through the injected `TrialBalanceRepository`, which is likely a Spring Data interface. It performs read operations filtered by office and account, and batch write operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TrialBalance"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (find by criteria and save all)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.repository.findNewByOfficeAndAccount(officeId, accountId);"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "GLAccountRepository",
    "description": "The class interacts with the database through the injected `GLAccountRepository`, which is a Spring Data repository interface. It performs read operations to fetch GLAccount entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GLAccount"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD lookups by Primary Key and Unique Key (GL Code)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.findById(id).orElseThrow(() -> new GLAccountNotFoundException(id))"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.domain.GLAccountRepository",
    "mechanism": "SPRING-DATA",
    "name": "GLAccountRepository",
    "description": "The file uses Spring Data JPA to abstract database interactions. It extends JpaRepository to provide standard CRUD operations and JpaSpecificationExecutor for complex criteria queries without writing explicit SQL.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GLAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data derived query methods and standard CRUD operations.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "Optional<GLAccount> findOneByGlCode(String glCode);"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.domain.TrialBalanceRepository",
    "mechanism": "SPRING-DATA",
    "name": "TrialBalanceRepository",
    "description": "The file uses Spring Data JPA repositories to interact with the database. It extends JpaRepository for standard CRUD operations and defines a custom native SQL query for specific retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_trial_balance"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Uses standard Spring Data abstractions for most operations, but includes one explicit native SQL query for filtering null closing balances.",
    "transactionHandling": "Spring @Transactional",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(value = \"select * from m_trial_balance where office_id=:officeId ...\", nativeQuery = true)"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.jobs.updatetrialbalancedetails.UpdateTrialBalanceDetailsConfig",
    "mechanism": "SPRING-DATA",
    "name": "TrialBalanceRepositoryWrapper",
    "description": "The configuration class injects a repository wrapper (TrialBalanceRepositoryWrapper) and a data source factory (RoutingDataSourceServiceFactory) and passes them to the Tasklet. This indicates that the job's execution involves reading from and writing to the database using these components, likely via JPA/Spring Data and potentially direct JDBC via the data source factory.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Batch processing logic likely involving bulk updates or calculations based on trial balance data.",
    "transactionHandling": "Spring Batch Step configuration uses the PlatformTransactionManager.",
    "protocol": "unknown",
    "connectionInfo": "Managed by RoutingDataSourceServiceFactory",
    "codeExample": "return new UpdateTrialBalanceDetailsTasklet(dataSourceServiceFactory, trialBalanceRepositoryWrapper);"
  },
  {
    "path": "org.apache.fineract.accounting.glaccount.service",
    "mechanism": "SPRING-DATA",
    "name": "GLAccountRepository, JournalEntryRepository, JdbcTemplate",
    "description": "The class primarily uses Spring Data JPA repositories (GLAccountRepository, JournalEntryRepository) for CRUD operations and existence checks on entities. It also utilizes Spring's JdbcTemplate to execute a raw SQL query for checking product mappings in the 'acc_product_mapping' table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_gl_account",
      "acc_gl_journal_entry",
      "acc_product_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, findById, delete, exists) and one inline SQL count query.",
    "transactionHandling": "Spring @Transactional annotations on public methods.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "String sql = \"select count(*) from acc_product_mapping acc where acc.gl_account_id = ?\";\nint count = this.jdbcTemplate.queryForObject(sql, Integer.class, glAccountId);"
  },
  {
    "path": "org.apache.fineract.accounting.journalentry.domain",
    "mechanism": "SPRING-DATA",
    "name": "JournalEntryRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, which provides standard CRUD methods, and by defining custom JPQL queries via the @Query annotation to perform specific filtering on the JournalEntry table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "JournalEntry"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "JPQL queries with subqueries (NOT IN), DISTINCT clauses, and multiple filtering criteria (transactionId, reversed status, entityType).",
    "transactionHandling": "Spring Data repositories typically participate in the caller's transaction context (Spring @Transactional).",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select journalEntry from JournalEntry journalEntry where journalEntry.transactionId= :transactionId and journalEntry.reversed=false and journalEntry.manualEntry=true\")"
  },
  {
    "path": "org.apache.fineract.accounting.journalentry.service.AccountingProcessorHelper",
    "mechanism": "SPRING-DATA",
    "name": "JournalEntryRepository, ProductToGLAccountMappingRepository, etc.",
    "description": "The class uses multiple Spring Data repositories to interact with the database. It reads configuration data (GL Accounts, Mappings, Closures) and writes transaction data (Journal Entries).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "acc_gl_journal_entry",
      "acc_product_mapping",
      "acc_gl_closure",
      "acc_gl_account",
      "m_office",
      "m_loan_transaction",
      "m_client_transaction",
      "m_savings_account_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, getReferenceById, findBy...) and some custom finders for mappings.",
    "transactionHandling": "Implicitly handled by Spring Data repository calls, though the service itself is annotated with @Service and likely participates in transactions initiated by callers.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "JournalEntry savedJournalEntry = this.glJournalEntryRepository.saveAndFlush(journalEntry);"
  },
  {
    "path": "org.apache.fineract.accounting.journalentry.service.JournalEntryWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "JournalEntryRepository, GLAccountRepository, GLClosureRepository",
    "description": "The class uses multiple Spring Data JPA repositories to interact with the database. It performs CRUD operations on JournalEntry, GLAccount, and GLClosure entities. It uses @Transactional to ensure data consistency across multiple repository calls.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "JournalEntry",
      "GLAccount",
      "GLClosure",
      "Office",
      "AccountingRule",
      "PaymentDetail",
      "FinancialActivityAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findById, save) and some custom finders (findUnReversedManualJournalEntriesByTransactionId).",
    "transactionHandling": "Spring @Transactional",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final List<JournalEntry> journalEntries = this.glJournalEntryRepository.findUnReversedManualJournalEntriesByTransactionId(command.getTransactionId());"
  },
  {
    "path": "org.apache.fineract.accounting.producttoaccountmapping.domain",
    "mechanism": "SPRING-DATA",
    "name": "ProductToGLAccountMappingRepository",
    "description": "The interface extends JpaRepository to provide database access for ProductToGLAccountMapping entities. It uses JPQL annotations to define complex selection logic involving null checks and specific constant values for account types.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProductToGLAccountMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with specific filtering criteria including NULL checks and hardcoded integer constants for account types.",
    "transactionHandling": "Spring @Transactional (default for JpaRepository)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select mapping from ProductToGLAccountMapping mapping where mapping.productId =:productId ... and mapping.paymentType is NULL\")"
  },
  {
    "path": "org.apache.fineract.accounting.producttoaccountmapping.service",
    "mechanism": "SPRING-DATA",
    "name": "GLAccountRepository, ProductToGLAccountMappingRepository",
    "description": "The class injects Spring Data repositories via its constructor and passes them to its superclass. It delegates persistence operations (save, update, delete) to the superclass methods, which utilize these repositories to manage the lifecycle of product-to-account mappings in the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProductToGLAccountMapping",
      "GLAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM-based CRUD operations managed by Spring Data JPA repositories in the superclass.",
    "transactionHandling": "Likely handled by Spring @Transactional at the service layer invoking this helper.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public void deleteSharesProductToGLAccountMapping(final Long sharesProductId) {\n    deleteProductToGLAccountMapping(sharesProductId, PortfolioProductType.SHARES);\n}"
  },
  {
    "path": "org.apache.fineract.accounting.producttoaccountmapping.service",
    "mechanism": "SPRING-DATA",
    "name": "GLAccountRepository, ProductToGLAccountMappingRepository",
    "description": "The class interacts with the database through Spring Data repositories injected into its constructor (and passed to the superclass). It performs CRUD operations on GL Account mappings.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GLAccount",
      "ProductToGLAccountMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via repository methods.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public void deleteSavingsProductToGLAccountMapping(final Long savingsProductId) {\n    deleteProductToGLAccountMapping(savingsProductId, PortfolioProductType.SAVING);\n}"
  },
  {
    "path": "org.apache.fineract.accounting.producttoaccountmapping.service.LoanProductToGLAccountMappingHelper",
    "mechanism": "SPRING-DATA",
    "name": "GLAccountRepository, ProductToGLAccountMappingRepository",
    "description": "The class interacts with the database through Spring Data repositories injected into the constructor (and passed to the superclass). It performs operations to save, update, and delete mappings between products and GL accounts.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "gl_account",
      "acc_product_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "CRUD operations via Spring Data JPA repositories.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "saveProductToAccountMapping(element, paramName, productId, placeHolderTypeId, GLAccountType.ASSET, PortfolioProductType.LOAN);"
  },
  {
    "path": "org.apache.fineract.accounting.producttoaccountmapping.service.ProductToGLAccountMappingHelper",
    "mechanism": "SPRING-DATA",
    "name": "ProductToGLAccountMappingRepository, GLAccountRepository",
    "description": "The class uses Spring Data repositories to interact with the database. It performs CRUD operations on `ProductToGLAccountMapping` and `GLAccount` entities. It uses `saveAndFlush` for immediate persistence and `deleteAllInBatch` for bulk deletions.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProductToGLAccountMapping",
      "GLAccount",
      "Charge",
      "PaymentType"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via repository methods, including find by ID, find by product ID, and batch delete.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "this.accountMappingRepository.saveAndFlush(accountMapping);"
  },
  {
    "path": "org.apache.fineract.accounting.provisioning.domain",
    "mechanism": "SPRING-DATA",
    "name": "ProvisioningEntryRepository",
    "description": "The interface extends JpaRepository to provide database access for ProvisioningEntry entities. It uses JPQL annotations for custom retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProvisioningEntry"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries using simple selection and subqueries for aggregation (max date).",
    "transactionHandling": "Spring Data JPA repositories typically participate in Spring managed transactions.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select entry1 from ProvisioningEntry entry1 where entry1.createdDate = :createdDate\")"
  },
  {
    "path": "org.apache.fineract.accounting.provisioning.service.ProvisioningEntriesWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "ProvisioningEntryRepository, LoanProductRepository, GLAccountRepository",
    "description": "The class uses multiple Spring Data JPA repositories to interact with the database. It performs read and write operations on ProvisioningEntry, LoanProduct, GLAccount, and related entities. It uses saveAndFlush for immediate persistence.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProvisioningEntry",
      "LoanProduct",
      "GLAccount",
      "Office",
      "ProvisioningCategory",
      "LoanProductProvisioningEntry"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findById, saveAndFlush) and custom find methods (findByProvisioningEntryDate).",
    "transactionHandling": "Implicitly handled by Spring Data repositories or service layer transaction management (though @Transactional is not explicitly present on this class, it is standard in this architecture).",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.provisioningEntryRepository.saveAndFlush(requestedEntry);"
  },
  {
    "path": "org.apache.fineract.accounting.rule.domain",
    "mechanism": "SPRING-DATA",
    "name": "AccountingRuleRepository",
    "description": "The class interacts with the database through the AccountingRuleRepository, which is a Spring Data repository interface. It performs read operations to fetch AccountingRule entities by their primary key.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountingRule"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD (Find by ID)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return this.repository.findById(id).orElseThrow(() -> new AccountingRuleNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.accounting.rule.domain.AccountingRuleRepository",
    "mechanism": "SPRING-DATA",
    "name": "AccountingRuleRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access capabilities and defines a custom JPQL query for specific retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountingRule"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "JPQL query with conditional logic (OR clause) checking for null or specific ID match.",
    "transactionHandling": "Spring @Transactional (Implicit in Spring Data repositories)",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select accountingRule from AccountingRule accountingRule where accountingRule.office is null or accountingRule.office.id =:officeId\")"
  },
  {
    "path": "org.apache.fineract.accounting.rule.service.AccountingRuleWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "AccountingRuleRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It injects `AccountingRuleRepository`, `GLAccountRepositoryWrapper`, `OfficeRepositoryWrapper`, and `CodeValueRepository` to perform CRUD operations. Transaction management is handled via the `@Transactional` annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountingRule",
      "GLAccount",
      "Office",
      "CodeValue",
      "AccountingTagRule"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, delete, findById) and wrapper methods for entity retrieval.",
    "transactionHandling": "Spring @Transactional annotations on the class and methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.accountingRuleRepository.saveAndFlush(accountingRule);"
  },
  {
    "path": "org.apache.fineract.adhocquery.domain.AdHocRepository",
    "mechanism": "SPRING-DATA",
    "name": "AdHocRepository",
    "description": "Database integration is achieved through Spring Data JPA, which automatically generates the implementation for the repository interface at runtime. It manages the persistence lifecycle of the AdHoc entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AdHoc"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and dynamic criteria-based queries provided by JpaSpecificationExecutor.",
    "transactionHandling": "Spring Data JPA repositories are transactional by default (read-only for read methods, read-write for others).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface AdHocRepository extends JpaRepository<AdHoc, Long>, JpaSpecificationExecutor<AdHoc> {\n    // no added behaviour\n}"
  },
  {
    "path": "org.apache.fineract.adhocquery.service.AdHocWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "AdHocRepository",
    "description": "The class uses a Spring Data JPA repository (AdHocRepository) to interact with the database. It performs standard CRUD operations such as save, findById, and delete on the AdHoc entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AdHoc"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations using Spring Data JPA methods (saveAndFlush, findById, delete).",
    "transactionHandling": "Spring @Transactional annotations on the class and methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.adHocRepository.saveAndFlush(entity);"
  },
  {
    "path": "org.apache.fineract.cob",
    "mechanism": "SPRING-DATA",
    "name": "BatchBusinessStepRepository",
    "description": "The class uses a Spring Data JPA repository (`BatchBusinessStepRepository`) to access batch business step configurations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BatchBusinessStep"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple read operation to find all steps by job name.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "List<BatchBusinessStep> cobStepConfigs = batchBusinessStepRepository.findAllByJobName(cobJobName);"
  },
  {
    "path": "org.apache.fineract.cob.api.InternalLoanAccountLockApiResource",
    "mechanism": "SPRING-DATA",
    "name": "LoanAccountLockRepository",
    "description": "The class interacts with the database using a Spring Data repository interface `LoanAccountLockRepository`. It persists `LoanAccountLock` entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanAccountLock"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "loanAccountLockRepository.save(loanAccountLock);"
  },
  {
    "path": "org.apache.fineract.cob.common",
    "mechanism": "SPRING-DATA",
    "name": "AppUserRepositoryWrapper",
    "description": "The class interacts with the database to retrieve the system user details required for authentication. This is done through the `AppUserRepositoryWrapper`, which likely wraps a Spring Data repository.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AppUser"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity retrieval by system property",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "AppUser user = userRepository.fetchSystemUser();"
  },
  {
    "path": "org.apache.fineract.cob.common",
    "mechanism": "SPRING-DATA",
    "name": "CustomJobParameterRepository",
    "description": "The class uses a Spring Data repository (`CustomJobParameterRepository`) to fetch `CustomJobParameter` entities by their primary key ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CustomJobParameter"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple primary key lookup (findById)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return customJobParameterRepository.findById(customJobParameterId).map(CustomJobParameter::getParameterJson)"
  },
  {
    "path": "org.apache.fineract.cob.data",
    "mechanism": "SPRING-DATA",
    "name": "Loan Projection",
    "description": "This interface functions as a Spring Data JPA Projection. By defining getter methods that match properties of the underlying Loan entity, it enables the persistence framework to generate a query that selects only the 'id', 'externalId', and 'accountNo' columns from the database, rather than retrieving the entire row.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan (inferred)"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Projection interface for selecting specific fields",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface LoanIdAndExternalIdAndAccountNo {\n    Long getId();\n    ExternalId getExternalId();\n    String getAccountNo();\n}"
  },
  {
    "path": "org.apache.fineract.cob.data.LoanIdAndLastClosedBusinessDate",
    "mechanism": "SPRING-DATA",
    "name": "Loan Projection",
    "description": "This interface functions as a Spring Data Projection. It defines a subset of data to be retrieved from the database, specifically targeting the Loan entity's ID and last closed business date. This allows the persistence layer to generate an optimized SQL SELECT query fetching only these specific columns.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Projection query fetching specific columns",
    "transactionHandling": "Managed by the calling repository method",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "public interface LoanIdAndLastClosedBusinessDate {\n    Long getId();\n    LocalDate getLastClosedBusinessDate();\n}"
  },
  {
    "path": "org.apache.fineract.cob.domain",
    "mechanism": "SPRING-DATA",
    "name": "BatchBusinessStepRepository",
    "description": "The interface extends JpaRepository to provide data access for the BatchBusinessStep entity. It uses Spring Data's method derivation and JPQL annotations to interact with the underlying relational database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BatchBusinessStep"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD, derived find/delete methods, and one custom JPQL projection query.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"SELECT DISTINCT bbs.jobName FROM BatchBusinessStep bbs\")"
  },
  {
    "path": "org.apache.fineract.cob.domain",
    "mechanism": "SPRING-DATA",
    "name": "LoanAccountLockRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository and defining method signatures that Spring translates into SQL queries. It also uses the @Query annotation for custom JPQL operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanAccountLock"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations, batch deletes via IN clauses, and one custom JPQL delete query for cleanup.",
    "transactionHandling": "Spring Data repositories typically participate in the caller's transaction context. The @Modifying annotation on removeLockByOwner suggests it performs a DML operation within a transaction.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"\"\"\n        delete from LoanAccountLock lck where lck.lockPlacedOnCobBusinessDate is not null and lck.error is not null and\n        lck.lockOwner in (org.apache.fineract.cob.domain.LockOwner.LOAN_COB_CHUNK_PROCESSING,org.apache.fineract.cob.domain.LockOwner.LOAN_INLINE_COB_PROCESSING)\n        \"\"\")\n@Modifying(flushAutomatically = true)\nvoid removeLockByOwner();"
  },
  {
    "path": "org.apache.fineract.cob.domain.CustomLoanAccountLockRepository",
    "mechanism": "SPRING-DATA",
    "name": "CustomLoanAccountLockRepository",
    "description": "This interface represents a custom extension to a Spring Data repository, defining a specific data manipulation operation. It implies the execution of a database update command to synchronize loan data with account lock data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan (inferred)",
      "AccountLock (inferred)"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "batch operations",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "void updateLoanFromAccountLocks();"
  },
  {
    "path": "org.apache.fineract.cob.listener",
    "mechanism": "SPRING-DATA",
    "name": "LoanLockingService",
    "description": "The class interacts with the database to update 'LoanAccountLock' entities when errors occur. It uses a 'TransactionTemplate' to execute these updates in a separate transaction (REQUIRES_NEW), ensuring error logs are persisted even if the main batch transaction fails. It delegates the actual entity retrieval to 'LoanLockingService'.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanAccountLock"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Retrieves entity by ID and LockOwner, then updates fields on the entity.",
    "transactionHandling": "Programmatic transaction management using TransactionTemplate with PROPAGATION_REQUIRES_NEW.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "transactionTemplate.setPropagationBehavior(PROPAGATION_REQUIRES_NEW);\ntransactionTemplate.execute(new TransactionCallbackWithoutResult() {\n    @Override\n    protected void doInTransactionWithoutResult(@NotNull TransactionStatus status) {\n        for (Long loanId : loanIds) {\n            LoanAccountLock loanAccountLock = loanLockingService.findByLoanIdAndLockOwner(loanId, getLockOwner());\n            if (loanAccountLock != null) {\n                loanAccountLock.setError(String.format(msg, loanId), ThrowableSerialization.serialize(e));\n            }\n        }\n    }\n});"
  },
  {
    "path": "org.apache.fineract.cob.loan",
    "mechanism": "SPRING-DATA",
    "name": "LoanLockingService Configuration",
    "description": "This class configures database access by injecting and passing the JdbcTemplate and LoanAccountLockRepository to the service layer. While this specific file does not execute queries, it wires the components (JDBC and Spring Data Repository) that perform database operations for loan locking.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "Configuration and wiring of data access components.",
    "transactionHandling": "None (Configuration level)",
    "protocol": "JDBC / Spring Data",
    "connectionInfo": "Configured via Spring Context (DataSource)",
    "codeExample": "return new LoanLockingServiceImpl(jdbcTemplate, fineractProperties, loanAccountLockRepository);"
  },
  {
    "path": "org.apache.fineract.cob.loan",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository",
    "description": "The class injects a `LoanRepository` via its constructor and passes it to its superclass `AbstractLoanItemReader`. While this specific file primarily reads IDs from the `ExecutionContext` (memory), it is part of a data access component hierarchy that relies on Spring Data JPA repositories for loan data retrieval.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The specific code here does not execute queries, but initializes a queue for the parent class which likely performs READ operations.",
    "transactionHandling": "Spring Batch transaction management",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "public InlineCOBLoanItemReader(LoanRepository loanRepository) {\n    super(loanRepository);\n}"
  },
  {
    "path": "org.apache.fineract.cob.loan",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository",
    "description": "The class uses a Spring Data repository (`LoanRepository`) to retrieve `Loan` entities by their primary key ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD read by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return loanRepository.findById(loanId).orElseThrow(() -> new LoanNotFoundException(loanId));"
  },
  {
    "path": "org.apache.fineract.cob.loan",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository",
    "description": "The configuration sets up Spring Batch components (Reader and Writer) that interact with the database via the LoanRepository. The LoanItemReader reads loan data, and the LoanItemWriter persists changes to Loan entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Batch processing with chunk-oriented reads and writes",
    "transactionHandling": "Spring Batch managed transactions via PlatformTransactionManager and TransactionTemplate",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "LoanItemWriter repositoryItemWriter = new LoanItemWriter(loanLockingService);\nrepositoryItemWriter.setRepository(loanRepository);"
  },
  {
    "path": "org.apache.fineract.cob.loan.AbstractLoanItemWriter",
    "mechanism": "SPRING-DATA",
    "name": "LoanLockingService",
    "description": "The class interacts with the database in two ways: implicitly through the `RepositoryItemWriter` superclass which persists `Loan` entities, and explicitly through the `LoanLockingService` to delete lock records.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan",
      "LoanLock"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Batch write of entities followed by a bulk delete operation by ID list.",
    "transactionHandling": "Likely participates in a Spring Batch step transaction.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "super.write(items);\nList<Long> loanIds = items.getItems().stream().map(AbstractPersistableCustom::getId).toList();\nloanLockingService.deleteByLoanIdInAndLockOwner(loanIds, getLockOwner());"
  },
  {
    "path": "org.apache.fineract.cob.loan.ApplyLoanLockTasklet",
    "mechanism": "SPRING-DATA",
    "name": "LoanLockingService / RetrieveLoanIdService",
    "description": "The class interacts with the database indirectly through injected services (`LoanLockingService` and `RetrieveLoanIdService`) to read loan data and manage lock entities. It explicitly controls transaction boundaries using `TransactionTemplate` to ensure locks are committed in a new transaction.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanAccountLock",
      "Loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code performs bulk reads (finding existing locks by ID list) and writes (applying locks). It uses partitioning to handle large lists of IDs in 'IN' clauses.",
    "transactionHandling": "Uses Spring's `TransactionTemplate` with `PROPAGATION_REQUIRES_NEW` to isolate the locking operation from the main batch transaction.",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "transactionTemplate.setPropagationBehavior(PROPAGATION_REQUIRES_NEW);\ntransactionTemplate.execute(new TransactionCallbackWithoutResult() {\n    @Override\n    protected void doInTransactionWithoutResult(@NotNull TransactionStatus status) {\n        loanLockingService.applyLock(toBeProcessedLoanIds, LockOwner.LOAN_COB_CHUNK_PROCESSING);\n    }\n});"
  },
  {
    "path": "org.apache.fineract.cob.loan.InlineLoanCOBBuildExecutionContextTasklet",
    "mechanism": "SPRING-DATA",
    "name": "CustomJobParameterRepository",
    "description": "The class uses a Spring Data repository (CustomJobParameterRepository) to retrieve custom job parameters stored in the database. These parameters contain JSON payloads defining the inputs for the batch job.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CustomJobParameter"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD (findById)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "CustomJobParameter customJobParameter = customJobParameterRepository.findById(customJobParameterId)\n        .orElseThrow(() -> new LoanNotFoundException(customJobParameterId));"
  },
  {
    "path": "org.apache.fineract.cob.loan.LoanInlineCOBConfig",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository",
    "description": "The configuration sets up a Spring Batch job that interacts with the database via Spring Data Repositories. The 'InlineCOBLoanItemReader' uses 'LoanRepository' to fetch Loan entities, and the 'InlineCOBLoanItemWriter' uses the same repository to persist updates. Transaction management is handled via the PlatformTransactionManager.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Batch processing with chunk-based reads and writes.",
    "transactionHandling": "Spring @Transactional via PlatformTransactionManager and TransactionTemplate",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Bean\npublic InlineCOBLoanItemReader inlineCobWorkerItemReader() {\n    return new InlineCOBLoanItemReader(loanRepository);\n}"
  },
  {
    "path": "org.apache.fineract.cob.loan.LoanItemReader",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository / LoanLockingService",
    "description": "The class interacts with the database indirectly through injected services (`RetrieveLoanIdService`, `LoanLockingService`) and the `LoanRepository` passed to the superclass. These services likely use Spring Data JPA repositories to query loan data and lock tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_loan_account_lock"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code performs read operations to fetch loan IDs based on criteria (min/max ID, business date) and to fetch lock status for specific loan IDs.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "accountLocks.addAll(loanLockingService.findAllByLoanIdInAndLockOwner(loanIds, LockOwner.LOAN_COB_CHUNK_PROCESSING));"
  },
  {
    "path": "org.apache.fineract.cob.loan.LoanLockingService",
    "mechanism": "SPRING-DATA",
    "name": "LoanLockingService",
    "description": "Although this is an interface, the method naming conventions (e.g., 'deleteBy...', 'findAllBy...') strongly suggest it is implemented using Spring Data JPA or acts as a service wrapper around a Spring Data repository for the 'LoanAccountLock' entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanAccountLock"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations including batch finds, batch deletes, and single entity lookups.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "n/a"
  },
  {
    "path": "org.apache.fineract.cob.loan.RetrieveLoanIdConfiguration",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository",
    "description": "The configuration class injects and utilizes a Spring Data 'LoanRepository' and a Spring JDBC 'NamedParameterJdbcTemplate'. While this specific file does not execute queries, it wires these database access components into the 'RetrieveLoanIdService', enabling downstream database interactions.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Autowired\nprivate LoanRepository loanRepository;\n\n@Autowired\nprivate NamedParameterJdbcTemplate namedParameterJdbcTemplate;"
  },
  {
    "path": "org.apache.fineract.cob.loan.RetrieveLoanIdService",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository",
    "description": "The interface defines data access contracts for retrieving loan information. The presence of the @Param annotation on 'findAllStayedLockedByCobBusinessDate' indicates that this interface is likely used as a Spring Data Repository or implemented by a class that utilizes Spring Data JPA features to bind method parameters to database queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The methods imply complex selection criteria based on dates, status (closed/non-closed), and ID ranges, likely involving WHERE clauses with multiple conditions.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "List<LoanIdAndExternalIdAndAccountNo> findAllStayedLockedByCobBusinessDate(@Param(\"cobBusinessDate\") LocalDate cobBusinessDate);"
  },
  {
    "path": "org.apache.fineract.cob.service",
    "mechanism": "SPRING-DATA",
    "name": "LoanAccountLockRepository, CustomJobParameterRepository",
    "description": "The class interacts with the database primarily through Spring Data JPA repositories to manage loan account locks and custom job parameters. It also utilizes a TransactionTemplate to enforce specific transaction propagation behaviors (REQUIRES_NEW) when locking loan accounts to ensure locks are committed independently of the main flow.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanAccountLock",
      "CustomJobParameter"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via JPA repositories.",
    "transactionHandling": "Spring @Transactional annotations and manual TransactionTemplate usage with PROPAGATION_REQUIRES_NEW.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "loanAccountLockRepository.saveAndFlush(loanAccountLock);"
  },
  {
    "path": "org.apache.fineract.cob.service",
    "mechanism": "SPRING-DATA",
    "name": "ScheduledJobDetailRepository",
    "description": "The class uses Spring Data repositories to access job configuration details. Specifically, it uses ScheduledJobDetailRepository to find job details by name. It also relies on RetrieveLoanIdService which likely performs database queries to fetch loan dates.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ScheduledJobDetail"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple repository find method",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "ScheduledJobDetail scheduledJobDetail = scheduledJobDetailRepository.findByJobName(LoanCOBConstant.JOB_HUMAN_READABLE_NAME);"
  },
  {
    "path": "org.apache.fineract.cob.service",
    "mechanism": "SPRING-DATA",
    "name": "JobExecutionRepository",
    "description": "The class interacts with the database primarily through the `JobExecutionRepository` (likely a Spring Data JPA repository) to query job execution history and status. It also indirectly accesses data via `RetrieveLoanIdService`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BATCH_JOB_EXECUTION",
      "BATCH_JOB_EXECUTION_PARAMS"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code performs specific lookups for job execution data based on parameter values.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "LocalDate runningCatchUpBusinessDate = jobExecutionRepository.getBusinessDateOfRunningJobByExecutionParameter(\n        LoanCOBConstant.JOB_NAME, LoanCOBConstant.LOAN_COB_CUSTOM_JOB_PARAMETER_KEY, LoanCOBConstant.IS_CATCH_UP_PARAMETER_NAME,\n        \"true\", LoanCOBConstant.BUSINESS_DATE_PARAMETER_NAME);"
  },
  {
    "path": "org.apache.fineract.cob.service.ConfigJobParameterServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "BatchBusinessStepRepository",
    "description": "The class uses a Spring Data JPA repository (BatchBusinessStepRepository) to perform CRUD operations on the BatchBusinessStep entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BatchBusinessStep"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard Spring Data JPA repository methods (findAllByJobName, deleteAllByJobName, save, findConfiguredJobNames).",
    "transactionHandling": "Spring @Transactional (implied by Service/Repository usage, though not explicitly annotated on this class)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "batchBusinessStepRepository.deleteAllByJobName(jobName);"
  },
  {
    "path": "org.apache.fineract.cob.service.LoanAccountLockServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "LoanAccountLockRepository",
    "description": "The class interacts with the database through the LoanAccountLockRepository, which is a Spring Data repository interface. It performs standard CRUD operations (findAll) as well as custom queries (existsByLoanIdAndLockOwner, updateLoanFromAccountLocks, removeLockByOwner).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanAccountLock"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Includes pagination (findAll), existence checks with criteria (existsByLoanIdAndLockOwner), and likely custom update/delete queries defined in the repository.",
    "transactionHandling": "Uses Spring's @Transactional annotation with Propagation.REQUIRES_NEW for the updateCobAndRemoveLocks method.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Page<LoanAccountLock> loanAccountLocks = loanAccountLockRepository.findAll(loanAccountLockPage);"
  },
  {
    "path": "org.apache.fineract.commands.domain.CommandSourceRepository",
    "mechanism": "SPRING-DATA",
    "name": "CommandSourceRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access methods and defines custom JPQL queries for specific business requirements.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CommandSource"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The repository uses a derived query method for simple lookups and a custom JPQL query for batch deletion.",
    "transactionHandling": "Spring @Transactional (implied by @Modifying annotation usage)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"delete from CommandSource c where c.status = :status and c.madeOnDate is not null and c.madeOnDate <= :dateForPurgeCriteria\")"
  },
  {
    "path": "org.apache.fineract.commands.jobs",
    "mechanism": "SPRING-DATA",
    "name": "CommandSourceRepository",
    "description": "The class interacts with the database through the CommandSourceRepository interface, which is likely a Spring Data JPA repository. It performs a bulk delete operation based on status and date criteria.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_command_source"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "The code performs a delete operation based on a specific status (PROCESSED) and a timestamp comparison (older than a calculated date).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "repository.deleteOlderEventsWithStatus(CommandProcessingResultType.PROCESSED.getValue(), dateForPurgeCriteria);"
  },
  {
    "path": "org.apache.fineract.commands.service",
    "mechanism": "SPRING-DATA",
    "name": "CommandSourceRepository",
    "description": "The class uses a Spring Data repository (CommandSourceRepository) to perform CRUD operations on CommandSource entities. It retrieves entities by ID, saves updates (for rejections), and deletes entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CommandSource"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findById, save, deleteById)",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.commandSourceRepository.deleteById(makerCheckerId);"
  },
  {
    "path": "org.apache.fineract.commands.service.CommandSourceService",
    "mechanism": "SPRING-DATA",
    "name": "CommandSourceRepository",
    "description": "The class uses a Spring Data JPA repository (`CommandSourceRepository`) to perform CRUD operations on the `CommandSource` entity. It utilizes standard methods like `saveAndFlush` and `findById`, as well as a custom finder method for idempotency checks.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CommandSource"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and a specific lookup by composite business keys (action, entity, idempotency key).",
    "transactionHandling": "Spring @Transactional annotations are used extensively with specific propagation (REQUIRES_NEW, REQUIRED) and isolation (REPEATABLE_READ) settings.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return commandSourceRepository.saveAndFlush(initialCommandSource);"
  },
  {
    "path": "org.apache.fineract.commands.service.SynchronousCommandProcessingService",
    "mechanism": "SPRING-DATA",
    "name": "CommandSourceService",
    "description": "The class interacts with the database primarily through the `CommandSourceService` to persist and update `CommandSource` entities. It uses Spring's `@Transactional` annotation to manage transaction boundaries, ensuring that command state updates (initial, success, error) are committed atomically. It also interacts with `ConfigurationDomainService` to read configuration settings from the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_command_source",
      "m_appuser"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Transactional CRUD operations on CommandSource entities; lookup of configuration settings.",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "commandSource = sameTransaction ? commandSourceService.saveInitialSameTransaction(wrapper, command, user, idempotencyKey)\n                    : commandSourceService.saveInitialNewTransaction(wrapper, command, user, idempotencyKey);"
  },
  {
    "path": "org.apache.fineract.infrastructure.accountnumberformat.domain",
    "mechanism": "SPRING-DATA",
    "name": "AccountNumberFormatRepository",
    "description": "The file is a Spring Data JPA repository interface that manages persistence for the AccountNumberFormat entity. It inherits standard database operations from JpaRepository and defines a custom read operation using JPQL.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountNumberFormat"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Uses standard Spring Data CRUD operations and a custom JPQL query for filtering by account type.",
    "transactionHandling": "Spring Data JPA repositories typically participate in existing transactions or create read-only transactions for query methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(FIND_ACCOUNT_NUMBER_FORMAT_FOR_ENTITY)\nAccountNumberFormat findOneByAccountTypeEnum(@Param(\"accountTypeEnum\") Integer accountTypeEnum);"
  },
  {
    "path": "org.apache.fineract.infrastructure.accountnumberformat.domain",
    "mechanism": "SPRING-DATA",
    "name": "AccountNumberFormatRepository",
    "description": "The class wraps a Spring Data repository (`AccountNumberFormatRepository`) to perform database operations. It relies on Spring Data JPA's abstraction to generate SQL for standard CRUD operations and custom finders.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountNumberFormat"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and a specific lookup by account type enum value.",
    "transactionHandling": "Likely relies on Spring's @Transactional at the service layer or default repository transaction settings.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public AccountNumberFormat findOneWithNotFoundDetection(final Long id) {\n    return this.repository.findById(id).orElseThrow(() -> new AccountNumberFormatNotFoundException(id));\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.accountnumberformat.service",
    "mechanism": "SPRING-DATA",
    "name": "AccountNumberFormatRepositoryWrapper",
    "description": "The class uses a repository wrapper (likely wrapping a Spring Data JpaRepository) to interact with the database. It performs CRUD operations on the AccountNumberFormat entity. Transactions are managed using Spring's @Transactional annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountNumberFormat"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via repository methods (saveAndFlush, findOneWithNotFoundDetection, delete).",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.accountNumberFormatRepository.saveAndFlush(accountNumberFormat);"
  },
  {
    "path": "org.apache.fineract.infrastructure.bulkimport.domain",
    "mechanism": "SPRING-DATA",
    "name": "ImportDocumentRepository",
    "description": "The interface is a Spring Data JPA repository. It automatically generates SQL queries at runtime to interact with the database table mapped to the ImportDocument entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ImportDocument"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (save, delete, findById) and dynamic specification-based queries.",
    "transactionHandling": "Transactions are handled by the Spring Data JPA framework, which typically applies @Transactional to repository methods by default.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ImportDocumentRepository extends JpaRepository<ImportDocument, Long>, JpaSpecificationExecutor<ImportDocument> {\n    // no added behaviour\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.bulkimport.importhandler.chartofaccounts.ChartOfAccountsImportHandler",
    "mechanism": "SPRING-DATA",
    "name": "GLAccountRepositoryWrapper",
    "description": "The class uses a repository wrapper to query existing GL Accounts from the database. This is primarily used during the processing of opening balances to verify that the GL Account referenced in the Excel file exists and to retrieve its ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_gl_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookup by GL Code",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "GLAccount glAccount = this.glAccountRepository.findOneByGlCodeWithNotFoundDetection(glCode);"
  },
  {
    "path": "org.apache.fineract.infrastructure.bulkimport.service.BulkImportEventListener",
    "mechanism": "SPRING-DATA",
    "name": "ImportDocumentRepository",
    "description": "The class uses a Spring Data repository to retrieve and update `ImportDocument` entities. It fetches the document metadata before processing and updates it with success/error counts after processing.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ImportDocument"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via Spring Data JPA (findById, saveAndFlush).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final ImportDocument importDocument = this.importRepository.findById(event.getImportId()).orElse(null);\n// ... processing ...\nthis.importRepository.saveAndFlush(importDocument);"
  },
  {
    "path": "org.apache.fineract.infrastructure.bulkimport.service.BulkImportWorkbookServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "ImportDocumentRepository & JdbcTemplate",
    "description": "The class uses a hybrid approach: it uses Spring Data JPA (ImportDocumentRepository) for saving new import records and Spring JDBC (JdbcTemplate) for querying import history and document locations with raw SQL.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_import_document",
      "m_document"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The write operations use JPA saveAndFlush. The read operations use inline SQL queries with joins between the import document table and the document table.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final String sql = \"select \" + rm.schema() + \" order by i.id desc\";\nreturn this.jdbcTemplate.query(sql, rm, new Object[] { type.getValue() });"
  },
  {
    "path": "org.apache.fineract.infrastructure.businessdate.domain.BusinessDateRepository",
    "mechanism": "SPRING-DATA",
    "name": "BusinessDateRepository",
    "description": "The interface extends JpaRepository to provide automatic database interaction for the BusinessDate entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BusinessDate"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD and derived query methods",
    "transactionHandling": "Spring @Transactional (default for JpaRepository)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Optional<BusinessDate> findByType(BusinessDateType type);"
  },
  {
    "path": "org.apache.fineract.infrastructure.businessdate.service",
    "mechanism": "SPRING-DATA",
    "name": "BusinessDateRepository",
    "description": "The class uses a Spring Data repository interface (BusinessDateRepository) to interact with the underlying database for retrieving BusinessDate entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BusinessDate"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD operations (findAll, findByType)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "List<BusinessDate> businessDateList = repository.findAll();"
  },
  {
    "path": "org.apache.fineract.infrastructure.businessdate.service.BusinessDateWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "BusinessDateRepository",
    "description": "The class uses a Spring Data JPA repository (`BusinessDateRepository`) to interact with the database. It performs lookups by business date type and saves new or updated `BusinessDate` entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BusinessDate"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findByType, save)",
    "transactionHandling": "unknown",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Optional<BusinessDate> businessDate = repository.findByType(businessDateType);\nif (businessDate.isEmpty()) {\n    repository.save(newBusinessDate);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.cache.command.UpdateCacheCommandHandler",
    "mechanism": "SPRING-DATA",
    "name": "CacheWritePlatformService",
    "description": "The class uses Spring's @Transactional annotation to manage database transactions for the cache update operation. While the direct database access logic resides in the injected CacheWritePlatformService, this handler defines the transaction boundary.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {"
  },
  {
    "path": "org.apache.fineract.infrastructure.cache.domain.PlatformCacheRepository",
    "mechanism": "SPRING-DATA",
    "name": "PlatformCacheRepository",
    "description": "The file uses Spring Data JPA to manage persistence for the PlatformCache entity. By extending JpaRepository, it inherits standard CRUD operations, pagination, and sorting capabilities. By extending JpaSpecificationExecutor, it allows for dynamic query construction using the Criteria API.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PlatformCache"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specifications provided by Spring Data JPA.",
    "transactionHandling": "Spring Data Repositories are transactional by default (read-only for read methods, read-write for others).",
    "protocol": "JPA",
    "connectionInfo": "configured in application.properties/yml",
    "codeExample": "public interface PlatformCacheRepository extends JpaRepository<PlatformCache, Long>, JpaSpecificationExecutor<PlatformCache> {\n    //\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.domain",
    "mechanism": "SPRING-DATA",
    "name": "EmailMessageRepository, GroupRepositoryWrapper, ClientRepositoryWrapper, StaffRepositoryWrapper",
    "description": "The class interacts with the database to retrieve existing entities (Group, Client, Staff, EmailMessage) using repository patterns. It uses both direct Spring Data repositories and wrapper classes that likely encapsulate JPA `EntityManager` or Spring Data calls with additional error handling (like 'Not Found' detection).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailMessage",
      "Group",
      "Client",
      "Staff"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookups by ID (CRUD READ operations).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "group = this.groupRepository.findOneWithNotFoundDetection(groupId);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.domain.EmailCampaignRepository",
    "mechanism": "SPRING-DATA",
    "name": "EmailCampaignRepository",
    "description": "The file uses Spring Data JPA repositories to interact with the database. It extends `JpaRepository` to inherit standard methods and defines a custom JPQL query for specific filtering logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailCampaign"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with dynamic criteria and standard CRUD operations",
    "transactionHandling": "Spring @Transactional annotations (implicit in Spring Data)",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Query(\"SELECT campaign FROM EmailCampaign campaign WHERE campaign.paramValue LIKE :reportPattern...\")"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.domain.EmailConfigurationRepository",
    "mechanism": "SPRING-DATA",
    "name": "EmailConfigurationRepository",
    "description": "The interface utilizes Spring Data JPA to manage database interactions for the EmailConfiguration entity. It abstracts the JDBC and JPA boilerplate code, providing a high-level API for data persistence.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and a simple property-based lookup (findByName).",
    "transactionHandling": "Spring @Transactional (implicitly handled by Spring Data JPA implementation)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface EmailConfigurationRepository extends JpaRepository<EmailConfiguration, Long> { EmailConfiguration findByName(String name); }"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.domain.EmailMessageRepository",
    "mechanism": "SPRING-DATA",
    "name": "EmailMessageRepository",
    "description": "The interface extends JpaRepository and JpaSpecificationExecutor, indicating it is a Spring Data JPA repository used for database persistence.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailMessage"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Derived query methods and standard CRUD operations provided by JpaRepository.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository implementation)",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "public interface EmailMessageRepository extends JpaRepository<EmailMessage, Long>, JpaSpecificationExecutor<EmailMessage> {\n    List<EmailMessage> findByStatusType(Integer emailMessageStatus);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.service",
    "mechanism": "SPRING-DATA",
    "name": "EmailMessageRepository",
    "description": "The service uses an injected EmailMessageRepository (likely extending JpaRepository) to perform CRUD operations on EmailMessage entities. It uses @Transactional to ensure atomicity of database operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailMessage"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save, delete, find)",
    "transactionHandling": "Spring @Transactional annotations on service methods",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.saveAndFlush(message);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.service",
    "mechanism": "SPRING-DATA",
    "name": "EmailCampaignRepository",
    "description": "The service interacts with the database to retrieve active email campaigns using a Spring Data repository. It executes a query to find campaigns matching a specific parameter value (trigger type) and status.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailCampaign"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Repository finder method with wildcard search parameters",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "emailCampaignRepository.findActiveEmailCampaigns(\"%\" + paramValue + \"%\",\n                SmsCampaignTriggerType.TRIGGERED.getValue());"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.service",
    "mechanism": "SPRING-DATA",
    "name": "EmailConfigurationRepository",
    "description": "The service uses a Spring Data repository to interact with the database. It retrieves all configuration entities and updates them individually.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations: findAll to retrieve all records and saveAndFlush for updates.",
    "transactionHandling": "Implicitly handled by Spring Data repository methods or service layer transaction management (though @Transactional is not explicitly present on this class).",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Collection<EmailConfiguration> configurations = this.repository.findAll();\n// ...\nthis.repository.saveAndFlush(config);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.email.service.EmailCampaignWritePlatformCommandHandlerImpl",
    "mechanism": "SPRING-DATA",
    "name": "EmailCampaignRepository, EmailMessageRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs CRUD operations on EmailCampaign and EmailMessage entities. It also interacts with the ReportRepository to fetch business rules.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailCampaign",
      "EmailMessage",
      "Report",
      "Client",
      "Loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, findById, save) combined with some complex reporting queries executed via a separate service.",
    "transactionHandling": "Spring @Transactional annotations on public methods",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.emailCampaignRepository.saveAndFlush(emailCampaign);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.executeemail",
    "mechanism": "SPRING-DATA",
    "name": "Fineract Repositories",
    "description": "The class injects multiple Spring Data repositories (EmailMessageRepository, EmailCampaignRepository, LoanRepository, SavingsAccountRepository) and passes them to the tasklet. While this configuration class does not execute queries directly, it wires the components that perform database operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailMessage",
      "EmailCampaign",
      "Loan",
      "SavingsAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The repositories likely perform CRUD operations required for processing email campaigns.",
    "transactionHandling": "Spring Batch Step transaction management via PlatformTransactionManager",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Autowired\nprivate EmailMessageRepository emailMessageRepository;\n// ...\n@Bean\npublic ExecuteEmailTasklet executeEmailTasklet() {\n    return new ExecuteEmailTasklet(emailMessageRepository, ...);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.executeemail.ExecuteEmailTasklet",
    "mechanism": "SPRING-DATA",
    "name": "EmailMessageRepository, EmailCampaignRepository, LoanRepository, SavingsAccountRepository",
    "description": "The class uses Spring Data JPA repositories to fetch pending email messages, retrieve campaign details, and look up related business entities (Loans, SavingsAccounts) for report generation. It also updates the status of EmailMessage entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailMessage",
      "EmailCampaign",
      "Loan",
      "SavingsAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository finders (findByStatusType, findById, findLoanByClientId, findSavingAccountByClientId) and save operations.",
    "transactionHandling": "Implicitly handled by Spring Batch step transaction management, though not explicitly annotated in this class.",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "final List<EmailMessage> emailMessages = emailMessageRepository.findByStatusType(EmailMessageStatusType.PENDING.getValue());"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.executereportmailingjobs.ExecuteReportMailingJobsConfig",
    "mechanism": "SPRING-DATA",
    "name": "ReportMailingJobRepository",
    "description": "The class injects Spring Data repositories (`ReportMailingJobRepository` and `ReportMailingJobRunHistoryRepository`) and passes them to the tasklet. While this configuration class does not execute queries directly, it wires the components that perform database operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_report_mailing_job",
      "m_report_mailing_job_run_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Repository methods used for CRUD operations on report mailing jobs and history.",
    "transactionHandling": "Spring Batch manages transactions at the Step level via the PlatformTransactionManager.",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Autowired\nprivate ReportMailingJobRepository reportMailingJobRepository;\n@Autowired\nprivate ReportMailingJobRunHistoryRepository reportMailingJobRunHistoryRepository;"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.executereportmailingjobs.ExecuteReportMailingJobsTasklet",
    "mechanism": "SPRING-DATA",
    "name": "ReportMailingJobRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It retrieves job configurations and saves execution history and updates job schedules.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ReportMailingJob",
      "ReportMailingJobRunHistory"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository find methods and save operations.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Collection<ReportMailingJob> reportMailingJobCollection = reportMailingJobRepository.findByIsActiveTrueAndIsDeletedFalse();\n// ...\nreportMailingJobRepository.save(reportMailingJob);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.getdeliveryreportsfromsmsgateway",
    "mechanism": "SPRING-DATA",
    "name": "SmsMessageRepository",
    "description": "The code uses a Spring Data repository (`SmsMessageRepository`) to interact with the database. It retrieves `SmsMessage` entities by ID and saves them after updating their status and external ID. It also uses a service (`SmsReadPlatformService`) which likely executes a read-only query to find messages waiting for reports.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsMessage"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findById, save) combined with a service-level query for retrieving pending items.",
    "transactionHandling": "Implicitly handled by Spring Data repository methods or the surrounding Spring Batch transaction management.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "SmsMessage smsMessage = smsMessageRepository.findById(smsMessageDeliveryReportData.getId()).orElse(null);\n// ... status mapping logic ...\nsmsMessage.setStatusType(statusType);\nsmsMessageRepository.save(smsMessage);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.getdeliveryreportsfromsmsgateway",
    "mechanism": "SPRING-DATA",
    "name": "SmsMessageRepository",
    "description": "The class injects a Spring Data repository interface (SmsMessageRepository) and passes it to the tasklet bean. This indicates that the resulting job will perform database operations (likely reading and updating SMS message records) via this repository.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsMessage"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Repository method calls within the tasklet",
    "transactionHandling": "Spring Batch Step transaction management via PlatformTransactionManager",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Autowired\nprivate SmsMessageRepository smsMessageRepository;\n...\nreturn new GetDeliveryReportsFromSmsGatewayTasklet(..., smsMessageRepository);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.sendmessagetosmsgateway.SendMessageToSmsGatewayConfig",
    "mechanism": "SPRING-DATA",
    "name": "SmsMessageRepository",
    "description": "The class injects a Spring Data repository (`SmsMessageRepository`) and passes it to the batch tasklet. This repository is used to interact with the database table storing SMS messages.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsMessage"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard Spring Data repository patterns (likely finding pending messages and updating their status).",
    "transactionHandling": "Spring Batch Step transaction management via PlatformTransactionManager",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Autowired\nprivate SmsMessageRepository smsMessageRepository;\n...\nreturn new SendMessageToSmsGatewayTasklet(smsMessageRepository, ...);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.sendmessagetosmsgateway.SendMessageToSmsGatewayTasklet",
    "mechanism": "SPRING-DATA",
    "name": "SmsMessageRepository",
    "description": "The class uses a Spring Data repository interface to interact with the database for retrieving and updating SMS message entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsMessage"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations with pagination (findByStatusType, saveAll).",
    "transactionHandling": "Likely handled by Spring Batch transaction management at the step level.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "org.springframework.data.domain.Page<SmsMessage> pendingMessages = smsMessageRepository\n        .findByStatusType(SmsMessageStatusType.PENDING.getValue(), pageRequest);\n// ... processing ...\nsmsMessageRepository.saveAll(toSaveMessages);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.updateemailoutboundwithcampaignmessage",
    "mechanism": "SPRING-DATA",
    "name": "EmailCampaignRepository, EmailMessageRepository",
    "description": "The class injects Spring Data repositories and passes them to the batch tasklet. While this configuration file does not execute queries directly, it wires the components that perform database operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The repositories likely perform CRUD operations required to update email campaigns.",
    "transactionHandling": "Spring Batch Step transaction management via PlatformTransactionManager",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Autowired\nprivate EmailCampaignRepository emailCampaignRepository;\n// ...\nreturn new UpdateEmailOutboundWithCampaignMessageTasklet(..., emailCampaignRepository, ...);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.updateemailoutboundwithcampaignmessage",
    "mechanism": "SPRING-DATA",
    "name": "EmailCampaignRepository, EmailMessageRepository",
    "description": "The class interacts with the database using Spring Data JPA repositories to manage campaign and message entities. It reads campaign configurations, fetches client details via a wrapper, and persists generated email messages to an outbound table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EmailCampaign",
      "EmailMessage",
      "Client"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository findById and save operations, plus report execution via service.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "EmailMessage emailMessage = EmailMessage.pendingEmail(null, client, null, emailCampaign, emailSubject, message, emailAddress, campaignName);\nemailMessageRepository.save(emailMessage);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.updatesmsoutboundwithcampaignmessage",
    "mechanism": "SPRING-DATA",
    "name": "SmsCampaignRepository",
    "description": "The configuration class injects a Spring Data repository (SmsCampaignRepository) and passes it to the Tasklet bean. While this class does not execute queries directly, it wires the component that performs database operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Repository usage delegated to Tasklet",
    "transactionHandling": "Spring Batch manages transactions via PlatformTransactionManager",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Autowired\nprivate SmsCampaignRepository smsCampaignRepository;\n// ...\nreturn new UpdateSmsOutboundWithCampaignMessageTasklet(smsCampaignRepository, smsCampaignWritePlatformService);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.jobs.updatesmsoutboundwithcampaignmessage.UpdateSmsOutboundWithCampaignMessageTasklet",
    "mechanism": "SPRING-DATA",
    "name": "SmsCampaignRepository",
    "description": "The class interacts with the database using a Spring Data JPA repository (`SmsCampaignRepository`) to fetch and update `SmsCampaign` entities. It also uses a service (`SmsCampaignWritePlatformService`) which implies further database interactions for inserting outbound messages.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsCampaign",
      "sms_outbound_messages"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository find methods and save operations.",
    "transactionHandling": "Likely handled by the Spring Batch framework or the service layer methods invoked.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Collection<SmsCampaign> smsCampaignDataCollection = smsCampaignRepository\n        .findByTriggerTypeAndStatus(SmsCampaignTriggerType.SCHEDULE.getValue(), SmsCampaignStatus.ACTIVE.getValue());\n// ...\nthis.smsCampaignRepository.saveAndFlush(smsCampaign);"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.sms.domain",
    "mechanism": "SPRING-DATA",
    "name": "SmsCampaignRepository",
    "description": "The file is a Spring Data JPA repository interface that manages persistence for the `SmsCampaign` entity. It provides database interaction without boilerplate code by extending `JpaRepository`. It uses method naming conventions to generate SQL queries automatically and includes a custom JPQL query for more complex filtering logic involving pattern matching and hardcoded status checks.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsCampaign"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The repository uses Spring Data's derived query methods for simple equality checks (e.g., `findByCampaignType`) and a custom JPQL query with a `LIKE` clause for pattern matching.",
    "transactionHandling": "Spring @Transactional (implicitly handled by the Spring Data JPA implementation proxy)",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"SELECT campaign FROM SmsCampaign campaign WHERE campaign.paramValue LIKE :reportPattern AND campaign.triggerType=:triggerType AND campaign.status=300\")"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.sms.serialization.SmsCampaignValidator",
    "mechanism": "SPRING-DATA",
    "name": "DeviceRegistrationRepositoryWrapper",
    "description": "The class uses a repository wrapper to query the database for device registrations. This is used to validate if a client is eligible to receive push notifications.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DeviceRegistration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookup by Client ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "DeviceRegistration deviceRegistration = this.deviceRegistrationRepository.findDeviceRegistrationByClientId(client.getId());"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.sms.service.SmsCampaignDomainServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "SmsCampaignRepository, SmsMessageRepository, OfficeRepository, GroupRepository",
    "description": "The service uses Spring Data JPA repositories to interact with the database. It retrieves SMS campaign configurations, office hierarchy information, and group details. It also persists generated SMS messages.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_sms_campaign",
      "m_sms_message",
      "m_office",
      "m_group"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code performs lookups for active campaigns using LIKE queries, finds entities by ID, and saves new message entities.",
    "transactionHandling": "unknown",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "List<SmsCampaign> smsCampaigns = smsCampaignRepository.findActiveSmsCampaigns(\"%\" + paramValue + \"%\",\n        SmsCampaignTriggerType.TRIGGERED.getValue());"
  },
  {
    "path": "org.apache.fineract.infrastructure.campaigns.sms.service.SmsCampaignWritePlatformServiceJpaImpl",
    "mechanism": "SPRING-DATA",
    "name": "SmsCampaignRepository, SmsMessageRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs CRUD operations on SmsCampaign and SmsMessage entities, and also interacts with Report, Client, and Group entities via their respective repositories.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsCampaign",
      "SmsMessage",
      "Report",
      "Client",
      "Group",
      "SavingsAccount",
      "Loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findById, saveAndFlush, save) combined with some dynamic report execution via ReadReportingService.",
    "transactionHandling": "Spring @Transactional annotations on write methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.smsCampaignRepository.saveAndFlush(smsCampaign);"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.domain",
    "mechanism": "SPRING-DATA",
    "name": "CodeValueRepository",
    "description": "The class interacts with the database through the CodeValueRepository interface, which is likely a Spring Data JPA repository. It performs read operations to fetch CodeValue entities by ID, or by combinations of code name, ID, and label.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CodeValue"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD lookups using ID and field combinations.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return this.repository.findById(id).orElseThrow(() -> new CodeValueNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.domain.CodeRepository",
    "mechanism": "SPRING-DATA",
    "name": "CodeRepository",
    "description": "The file uses Spring Data JPA repositories to interact with the database. By extending JpaRepository, it gains automatic implementation of standard data access operations for the 'Code' entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Code"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and a specific property-based lookup (findOneByName).",
    "transactionHandling": "Spring Data repositories are transactional by default (read-only for read methods, read-write for others).",
    "protocol": "JPA/JDBC",
    "connectionInfo": "unknown",
    "codeExample": "public interface CodeRepository extends JpaRepository<Code, Long>, JpaSpecificationExecutor<Code> {\n    Code findOneByName(String name);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.domain.CodeValueRepository",
    "mechanism": "SPRING-DATA",
    "name": "CodeValueRepository",
    "description": "The file is a Spring Data JPA repository interface. It provides database access for the 'CodeValue' entity by extending JpaRepository, which offers standard CRUD and paging operations, and JpaSpecificationExecutor for dynamic criteria-based queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CodeValue"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data derived queries (findBy...) and standard CRUD operations inherited from JpaRepository.",
    "transactionHandling": "Spring @Transactional (default behavior for JpaRepository methods)",
    "protocol": "JDBC (via Hibernate/JPA)",
    "connectionInfo": "unknown",
    "codeExample": "public interface CodeValueRepository extends JpaRepository<CodeValue, Long>, JpaSpecificationExecutor<CodeValue> { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.handler.DeleteCodeCommandHandler",
    "mechanism": "SPRING-DATA",
    "name": "CodeWritePlatformService",
    "description": "The class manages database transactions via the Spring `@Transactional` annotation, delegating the actual persistence operations to the `CodeWritePlatformService`. While it does not contain direct SQL or repository calls, it orchestrates the transactional write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.deleteCode(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.service",
    "mechanism": "SPRING-DATA",
    "name": "CodeValueRepository",
    "description": "The class uses Spring Data JPA repositories (CodeRepository and CodeValueRepository) to interact with the database. It performs CRUD operations on Code and CodeValue entities within transactional boundaries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Code",
      "CodeValue"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findById, saveAndFlush) without complex custom queries.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.codeValueRepository.saveAndFlush(codeValue);"
  },
  {
    "path": "org.apache.fineract.infrastructure.codes.service.CodeWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "CodeRepository",
    "description": "The class uses a Spring Data JPA repository (CodeRepository) to interact with the database. It performs CRUD operations on the 'Code' entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Code"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save, findById, delete) delegated to the JPA repository.",
    "transactionHandling": "Spring @Transactional annotations on public methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.codeRepository.saveAndFlush(code);"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.domain",
    "mechanism": "SPRING-DATA",
    "name": "GlobalConfigurationRepository",
    "description": "The class interacts with the database through the injected GlobalConfigurationRepository, which is likely a Spring Data JPA repository interface. It performs standard CRUD operations (find, save, delete) on GlobalConfigurationProperty entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GlobalConfigurationProperty"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via Repository interface",
    "transactionHandling": "Likely handled by the underlying Spring Data Repository or service layer transaction boundaries (not explicitly defined in this file)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.repository.findOneByName(propertyName);"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.domain",
    "mechanism": "SPRING-DATA",
    "name": "ExternalServicesPropertiesRepository",
    "description": "The file uses Spring Data JPA to interact with the database, mapping the ExternalServicesProperties entity to a relational table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalServicesProperties"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations and standard CRUD operations.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data Repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"SELECT ep from ExternalServicesProperties ep where ep.externalServicePropertiesPK.name=:name...\")"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.domain.ConfigurationDomainServiceJpa",
    "mechanism": "SPRING-DATA",
    "name": "GlobalConfigurationRepositoryWrapper, PermissionRepository, PlatformCacheRepository",
    "description": "The class uses injected repository interfaces (likely extending Spring Data JpaRepository) to interact with the database. It retrieves global configuration settings, permissions, and cache settings. The 'GlobalConfigurationRepositoryWrapper' is a custom wrapper around the standard repository to handle caching and exception handling.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "c_configuration",
      "m_permission",
      "c_cache"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and find-by-name queries.",
    "transactionHandling": "Spring @Transactional annotations are used on the class and specific methods (e.g., updateCache).",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.cacheTypeRepository.findById(1L).ifPresent(cache -> {\n    cache.setCacheType(cacheType.getValue());\n    this.cacheTypeRepository.save(cache);\n});"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.domain.ExternalServicesPropertiesRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "ExternalServicesPropertiesRepository",
    "description": "The class interacts with the database through a Spring Data repository interface. It performs read operations to fetch configuration properties based on a composite primary key.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalServicesProperties"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD lookup by composite key",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final ExternalServicesProperties externalServicesProperties = this.repository.findOneByExternalServicePropertiesPK(name, id);"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.domain.GlobalConfigurationRepository",
    "mechanism": "SPRING-DATA",
    "name": "GlobalConfigurationRepository",
    "description": "The interface uses Spring Data JPA to interact with the database. It inherits standard CRUD operations (save, findAll, delete) from JpaRepository and defines a custom finder method.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GlobalConfigurationProperty"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and a specific property lookup by name.",
    "transactionHandling": "Spring @Transactional (default for JpaRepository methods)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface GlobalConfigurationRepository\n        extends JpaRepository<GlobalConfigurationProperty, Long>..."
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.service",
    "mechanism": "SPRING-DATA",
    "name": "ExternalServicesPropertiesRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It injects ExternalServicesPropertiesRepository and a wrapper to perform read and write operations on ExternalServicesProperties entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalServicesProperties"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findOneByIdAndName, saveAndFlush).",
    "transactionHandling": "Spring @Transactional annotation on the class and method level.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.saveAndFlush(externalServicesProperties);"
  },
  {
    "path": "org.apache.fineract.infrastructure.configuration.service",
    "mechanism": "SPRING-DATA",
    "name": "GlobalConfigurationRepositoryWrapper",
    "description": "The class interacts with the database through a repository wrapper (GlobalConfigurationRepositoryWrapper) which likely delegates to a Spring Data JPA repository. It performs read and write operations on GlobalConfigurationProperty entities within a transactional context.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GlobalConfigurationProperty"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (find by ID, save)",
    "transactionHandling": "Spring @Transactional annotations on methods",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.save(configItemForUpdate);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.auditing.CustomAuditingHandler",
    "mechanism": "SPRING-DATA",
    "name": "Spring Data Auditing",
    "description": "This class is a core component of the Spring Data JPA auditing infrastructure. While it does not execute SQL directly, it intercepts entity persistence operations (save/update) to automatically populate auditing fields (createdDate, lastModifiedDate, etc.) on entities before they are written to the database.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "n/a",
    "transactionHandling": "Spring @Transactional (implicit in repository operations)",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "setDateTimeProvider(fetchDateTimeProvider(source));\nreturn super.markCreated(source);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.filters",
    "mechanism": "SPRING-DATA",
    "name": "CommandSourceRepository",
    "description": "The class uses a Spring Data repository (`CommandSourceRepository`) to find entities by ID and a service (`CommandSourceService`) to save updates to the database. It handles transaction boundaries explicitly for these updates.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CommandSource"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findById) and entity updates via service methods.",
    "transactionHandling": "Delegates to service methods `saveResultSameTransaction` or `saveResultNewTransaction` based on context.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "commandSourceRepository.findById(commandId).ifPresent(commandSource -> { ... commandSourceService.saveResultNewTransaction(commandSource); });"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain",
    "mechanism": "SPRING-DATA",
    "name": "CreditBureauRepository",
    "description": "Database integration is achieved through Spring Data JPA repositories. The interface defines the contract for data access, and Spring generates the implementation to interact with the underlying relational database using Hibernate/JPA.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditBureau"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by the framework.",
    "transactionHandling": "Transactions are managed by the Spring container, typically applying @Transactional behavior to repository methods by default.",
    "protocol": "JDBC/JPA",
    "connectionInfo": "configured externally",
    "codeExample": "public interface CreditBureauRepository extends JpaRepository<CreditBureau, Long>, JpaSpecificationExecutor<CreditBureau> {"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain",
    "mechanism": "SPRING-DATA",
    "name": "TokenRepository",
    "description": "The class interacts with the database through a Spring Data repository interface named TokenRepository. It performs standard CRUD operations (save, delete, read) on the CreditBureauToken entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditBureauToken"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations delegated to a repository interface.",
    "transactionHandling": "Likely handled by the underlying Spring Data repository or higher-level services.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.repository.save(token);"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain",
    "mechanism": "SPRING-DATA",
    "name": "TokenRepository",
    "description": "The file is a Spring Data JPA repository interface that manages persistence for the CreditBureauToken entity. It inherits standard database operations from JpaRepository and defines custom JPQL queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditBureauToken"
    ],
    "operationType": [
      "READ_WRITE",
      "READ"
    ],
    "queryPatterns": "JPQL queries via @Query annotation and standard Spring Data CRUD operations.",
    "transactionHandling": "Spring @Transactional (default for Spring Data repositories)",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select creditbureautoken from CreditBureauToken creditbureautoken\")\nCreditBureauToken getToken();"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain",
    "mechanism": "SPRING-DATA",
    "name": "CreditBureauConfigurationRepository",
    "description": "The class interacts with the database through a Spring Data repository interface. It delegates read operations to the repository, which likely maps to a database table storing credit bureau configurations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditBureauConfiguration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookup by ID and parameter name",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return this.creditBureauConfigurationRepository.getCreditBureauConfigData(creditBureauID, parameterName);"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain",
    "mechanism": "SPRING-DATA",
    "name": "CreditBureauConfigurationRepository",
    "description": "The interface uses Spring Data JPA to interact with the database. It defines custom JPQL queries to select data from the 'CreditBureauConfiguration' entity/table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditBureauConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL SELECT queries with WHERE clauses filtering by ID and string keys.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "JDBC (via JPA)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"SELECT creditBureauConfig from CreditBureauConfiguration creditBureauConfig where creditBureauConfig.organisationCreditbureau.id = :creditBureauID\")"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain.CreditBureauLoanProductMappingRepository",
    "mechanism": "SPRING-DATA",
    "name": "CreditBureauLoanProductMappingRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends `JpaRepository` to provide standard data access capabilities without boilerplate code.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditBureauLoanProductMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data derived query methods (findBy...) and standard CRUD operations inherited from JpaRepository.",
    "transactionHandling": "Spring @Transactional (implicitly handled by the JpaRepository implementation)",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "CreditBureauLoanProductMapping findOneByLoanProduct(LoanProduct loanProduct);"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain.CreditReportRepository",
    "mechanism": "SPRING-DATA",
    "name": "CreditReportRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard CRUD operations and JpaSpecificationExecutor for dynamic queries. It also defines a custom JPQL query for specific data retrieval.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditReport"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM queries using JPQL and standard CRUD operations.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"SELECT creditBureauReport from CreditReport creditBureauReport where creditBureauReport.nationalId = :nationalId and creditBureauReport.creditBureauId = :creditBureauId \")"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.domain.OrganisationCreditBureauRepository",
    "mechanism": "SPRING-DATA",
    "name": "OrganisationCreditBureauRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to inherit standard CRUD operations and JpaSpecificationExecutor for dynamic queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "OrganisationCreditBureau"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data.",
    "transactionHandling": "Spring @Transactional (implicitly handled by Spring Data repository proxies)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface OrganisationCreditBureauRepository\n        extends JpaRepository<OrganisationCreditBureau, Long>, JpaSpecificationExecutor<OrganisationCreditBureau> {\n\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.handler",
    "mechanism": "SPRING-DATA",
    "name": "CreditBureauConfigurationWritePlatformService",
    "description": "The class participates in database integration by defining a transactional boundary using Spring's `@Transactional` annotation. It delegates the actual persistence logic to the `CreditBureauConfigurationWritePlatformService`, which performs the write operation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CREDITBUREAU_CONFIGURATION"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for creation logic",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.addCreditBureauConfiguration(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.service",
    "mechanism": "SPRING-DATA",
    "name": "OrganisationCreditBureauRepository",
    "description": "The class uses Spring Data JPA repositories (OrganisationCreditBureauRepository and CreditBureauRepository) to interact with the database. It performs operations to retrieve entity references by ID and to save/flush entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "OrganisationCreditBureau",
      "CreditBureau"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations using repository methods like getReferenceById and saveAndFlush.",
    "transactionHandling": "Spring @Transactional annotation is used on the update method.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.organisationCreditBureauRepository.saveAndFlush(organisationCreditBureau);"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.service",
    "mechanism": "SPRING-DATA",
    "name": "CreditBureauLoanProductMappingRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs retrieval (`getReferenceById`) and persistence (`saveAndFlush`) operations on domain entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditBureauLoanProductMapping",
      "OrganisationCreditBureau",
      "LoanProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via JPA Repository methods (getReferenceById, saveAndFlush).",
    "transactionHandling": "Spring @Transactional annotations on the class and methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.creditBureauLoanProductMappingRepository.saveAndFlush(cb_lp);"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.service",
    "mechanism": "SPRING-DATA",
    "name": "CreditBureauConfigurationRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It injects CreditBureauConfigurationRepository and OrganisationCreditBureauRepository to perform CRUD operations. It uses @Transactional to manage transaction boundaries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditBureauConfiguration",
      "OrganisationCreditBureau"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, saveAndFlush, findById, getReferenceById).",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.creditBureauConfigurationRepository.saveAndFlush(cb_config);"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.service.CreditReportWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "CreditReportRepository, CreditBureauRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It injects `CreditBureauRepository` to look up bureau details and `CreditReportRepository` to perform CRUD operations (save, delete, find) on credit reports. Transactions are managed via the `@Transactional` annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditBureau",
      "CreditReport"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations using Spring Data repository methods (findById, saveAndFlush, delete) and a custom finder method (getThitsaWorksCreditReport).",
    "transactionHandling": "Spring @Transactional annotations on service methods",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "creditReport = CreditReport.instance(creditBureauId, nationalId, creditReportArray);\nthis.creditReportRepository.saveAndFlush(creditReport);"
  },
  {
    "path": "org.apache.fineract.infrastructure.creditbureau.service.ThitsaWorksCreditBureauIntegrationWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "CreditBureauRepositories",
    "description": "The class uses repository wrappers (TokenRepositoryWrapper, CreditBureauConfigurationRepositoryWrapper) which likely wrap Spring Data JPA repositories to interact with the database. It performs CRUD operations on tokens and reads configuration data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CreditBureauToken",
      "CreditBureauConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via repository wrappers.",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.tokenRepositoryWrapper.save(generatedtoken);"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain",
    "mechanism": "SPRING-DATA",
    "name": "EntityDatatableChecksRepository",
    "description": "The file is a Spring Data JPA repository interface. It provides database interaction capabilities without boilerplate code by extending 'JpaRepository'. It defines custom JPQL queries to perform specific lookups on the 'EntityDatatableChecks' table and joins with 'RegisteredDatatable'.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EntityDatatableChecks",
      "RegisteredDatatable"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with inner joins, parameter binding, and null checks.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select t from EntityDatatableChecks t WHERE t.status =:status and t.entity=:entity and t.productId = :productId \")\nList<EntityDatatableChecks> findByEntityStatusAndProduct(@Param(\"entity\") String entity, ...);"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain.RegisteredDatatableRepository",
    "mechanism": "SPRING-DATA",
    "name": "RegisteredDatatableRepository",
    "description": "The interface utilizes Spring Data JPA to manage database interactions for the RegisteredDatatable entity. It inherits standard data access methods without requiring explicit SQL or JPQL implementation in the file.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RegisteredDatatable"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data infrastructure.",
    "transactionHandling": "Spring Data repositories typically participate in Spring @Transactional contexts defined at the service layer, or use default transaction settings for repository methods.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface RegisteredDatatableRepository\n        extends JpaRepository<RegisteredDatatable, Long>, JpaSpecificationExecutor<RegisteredDatatable> {\n\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain.ReportParameterRepository",
    "mechanism": "SPRING-DATA",
    "name": "ReportParameterRepository",
    "description": "Database integration is achieved through Spring Data JPA, which automatically generates the implementation for the repository interface to interact with the underlying database tables mapped to the ReportParameter entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ReportParameter"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic queries via JPA Specifications.",
    "transactionHandling": "Transactions are handled implicitly by the Spring Data JPA repository implementation (default @Transactional behavior).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ReportParameterRepository extends JpaRepository<ReportParameter, Long>, JpaSpecificationExecutor<ReportParameter> {\n    // no added behaviour\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain.ReportParameterUsageRepository",
    "mechanism": "SPRING-DATA",
    "name": "ReportParameterUsageRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access operations without boilerplate code.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ReportParameterUsage"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and a specific finder method (findByReport) which likely translates to a simple SELECT with a WHERE clause.",
    "transactionHandling": "Spring @Transactional",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface ReportParameterUsageRepository\n        extends JpaRepository<ReportParameterUsage, Long>..."
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain.ReportRepository",
    "mechanism": "SPRING-DATA",
    "name": "ReportRepository",
    "description": "The file uses Spring Data JPA to manage database interactions for the Report entity. By extending JpaRepository, it automatically gains methods for saving, deleting, and finding entities. By extending JpaSpecificationExecutor, it supports complex, dynamic filtering.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Report"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and dynamic criteria-based queries provided by JpaSpecificationExecutor.",
    "transactionHandling": "Spring @Transactional (default behavior for Spring Data Repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ReportRepository extends JpaRepository<Report, Long>, JpaSpecificationExecutor<Report> {\n    // no added behaviour\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.domain.ReportRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "ReportRepository",
    "description": "The class interacts with the database through a Spring Data repository interface (`ReportRepository`). It performs read operations to fetch entities by their primary key.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Report"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD retrieval by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return this.reportRepository.findById(id).orElseThrow(() -> new ReportNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.service",
    "mechanism": "SPRING-DATA",
    "name": "ReportRepository, PermissionRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs CRUD operations on Report and Permission entities, including saving, flushing, and deleting records. Transaction management is handled via the @Transactional annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Report",
      "ReportParameter",
      "ReportParameterUsage",
      "Permission"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, delete, findById, findOneByCode) with some entity relationship management.",
    "transactionHandling": "Spring @Transactional annotations on class and methods",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.reportRepository.saveAndFlush(report);"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.service.EntityDatatableChecksWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "EntityDatatableChecksRepository",
    "description": "The class uses a Spring Data JPA repository (`EntityDatatableChecksRepository`) to manage the `EntityDatatableChecks` entity. It also interacts with a `ReadWriteNonCoreDataService` to perform dynamic SQL operations on variable datatables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "EntityDatatableChecks",
      "x_registered_table_name"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA CRUD operations for configuration; Dynamic queries for checking datatable entries.",
    "transactionHandling": "Spring @Transactional annotations on methods",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.entityDatatableChecksRepository.saveAndFlush(check);"
  },
  {
    "path": "org.apache.fineract.infrastructure.documentmanagement.domain",
    "mechanism": "SPRING-DATA",
    "name": "DocumentRepository",
    "description": "This interface is a Spring Data JPA repository that manages the persistence of Document entities. It automatically generates SQL queries based on the inherited methods for saving, deleting, and finding entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Document"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specifications provided by Spring Data JPA.",
    "transactionHandling": "Transactions are managed by the Spring container, typically with default @Transactional behavior on inherited methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface DocumentRepository extends JpaRepository<Document, Long>, JpaSpecificationExecutor<Document> {\n    // no added behaviour\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.documentmanagement.domain.ImageRepository",
    "mechanism": "SPRING-DATA",
    "name": "ImageRepository",
    "description": "The file uses Spring Data JPA to manage database interactions. It extends JpaRepository to inherit standard CRUD operations for the Image entity and JpaSpecificationExecutor to support dynamic queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Image",
      "Client"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and dynamic criteria-based queries via JpaSpecificationExecutor.",
    "transactionHandling": "Spring @Transactional (implicitly handled by Spring Data JPA repositories)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface ImageRepository extends JpaRepository<Image, Long>, JpaSpecificationExecutor<Client> {}"
  },
  {
    "path": "org.apache.fineract.infrastructure.documentmanagement.service",
    "mechanism": "SPRING-DATA",
    "name": "ImageRepository, ClientRepositoryWrapper, StaffRepositoryWrapper",
    "description": "The class interacts with the database using Spring Data repositories (likely wrapped by custom wrappers). It performs CRUD operations on Client, Staff, and Image entities within a transactional context.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Image",
      "Client",
      "Staff"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (save, delete, findOne) via repository abstractions.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.imageRepository.delete(image);"
  },
  {
    "path": "org.apache.fineract.infrastructure.documentmanagement.service",
    "mechanism": "SPRING-DATA",
    "name": "DocumentRepository",
    "description": "The class uses a Spring Data JPA repository (DocumentRepository) to perform CRUD operations on Document entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Document"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, findById, delete) are used for simple CRUD operations.",
    "transactionHandling": "Spring @Transactional annotations are used on service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.documentRepository.saveAndFlush(document);"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.data.FineractEntityDataValidator",
    "mechanism": "SPRING-DATA",
    "name": "Entity Repositories",
    "description": "The class uses Spring Data repositories and wrapper services to verify the existence of entities referenced in the API requests. It performs read-only operations to ensure referential integrity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_office",
      "m_product_loan",
      "m_savings_product",
      "m_charge",
      "m_role"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple primary key lookups (findById) to check for existence.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public void checkForLoanProducts(final Long id) {\n    this.loanProductRepository.findById(id).orElseThrow(() -> new LoanProductNotFoundException(id));\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.domain",
    "mechanism": "SPRING-DATA",
    "name": "FineractEntityToEntityMappingRepository",
    "description": "The class interacts with the database through a Spring Data repository interface (FineractEntityToEntityMappingRepository). It performs read operations by ID and delete operations on the FineractEntityToEntityMapping entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FineractEntityToEntityMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findById, delete) delegated to Spring Data JPA.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.fineractEntityToEntityMappingRepository.findById(id).orElseThrow(...)"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.domain",
    "mechanism": "SPRING-DATA",
    "name": "FineractEntityRelationRepository",
    "description": "The class interacts with the database through a Spring Data JPA repository interface. It performs read-only operations to fetch entity relation data based on ID or code name.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FineractEntityRelation"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD lookups by ID and unique field (codeName).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.fineractEntityRelationRepository.findById(id).orElseThrow(...)"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.domain",
    "mechanism": "SPRING-DATA",
    "name": "FineractEntityToEntityMappingRepository",
    "description": "The file uses Spring Data JPA repositories to interact with the database. It extends JpaRepository to provide standard CRUD operations and defines a custom JPQL query for specific retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FineractEntityToEntityMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via @Query annotations",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "JPA/JDBC",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select feem from FineractEntityToEntityMapping feem where feem.fromId= :fromId and feem.toId= :toId and feem.relationId= :relId\")"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.domain.FineractEntityAccessRepository",
    "mechanism": "SPRING-DATA",
    "name": "FineractEntityAccessRepository",
    "description": "The interface uses Spring Data JPA to interact with the database, abstracting SQL operations for the FineractEntityAccess entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FineractEntityAccess"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data Repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface FineractEntityAccessRepository\n        extends JpaRepository<FineractEntityAccess, Long>, JpaSpecificationExecutor<FineractEntityAccess> {\n    // no added behaviour\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.domain.FineractEntityAccessRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "FineractEntityAccessRepository",
    "description": "The class wraps a Spring Data repository interface to perform CRUD operations on the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FineractEntityAccess"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations delegated to a Spring Data repository.",
    "transactionHandling": "Relies on the underlying repository's transaction management or the caller's context.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.repository.findById(id).orElseThrow(() -> new FineractEntityAccessNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.domain.FineractEntityRelationRepository",
    "mechanism": "SPRING-DATA",
    "name": "FineractEntityRelationRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access methods and defines a custom JPQL query for specific retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FineractEntityRelation"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations",
    "transactionHandling": "Spring @Transactional (implied by Spring Data JPA default implementation)",
    "protocol": "JDBC (underlying)",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select fea from FineractEntityRelation fea where fea.codeName= :codeName\")"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.service",
    "mechanism": "SPRING-DATA",
    "name": "FineractEntityAccessRepository, FineractEntityToEntityMappingRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It injects repository interfaces and wrapper classes to perform CRUD operations on `FineractEntityAccess` and `FineractEntityToEntityMapping` entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FineractEntityAccess",
      "FineractEntityToEntityMapping",
      "FineractEntityRelation"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via JPA repositories (save, saveAndFlush, delete, findOne).",
    "transactionHandling": "Spring @Transactional annotations on methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.fineractEntityToEntityMappingRepository.saveAndFlush(newMap);"
  },
  {
    "path": "org.apache.fineract.infrastructure.entityaccess.service.FineractEntityAccessUtil",
    "mechanism": "SPRING-DATA",
    "name": "FineractEntityToEntityMappingRepository",
    "description": "The class uses Spring Data repositories (via wrappers) to read global configurations and entity relations, and to persist new entity-to-entity mappings.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_entity_to_entity_mapping",
      "m_entity_relation",
      "c_configuration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via repository methods (save, findOne).",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.fineractEntityToEntityMappingRepository.save(newMap);"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.business.service",
    "mechanism": "SPRING-DATA",
    "name": "ExternalEventConfigurationRepository",
    "description": "The class uses a Spring Data repository to query configuration settings for external events. It checks if specific event types are enabled for external broadcasting.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookup by event type",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "eventConfigurationRepository.findExternalEventConfigurationByTypeWithNotFoundDetection(eventType).isEnabled()"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.jobs.PurgeExternalEventsTasklet",
    "mechanism": "SPRING-DATA",
    "name": "ExternalEventRepository",
    "description": "The class uses a Spring Data repository (ExternalEventRepository) to perform bulk deletion of records based on status and date criteria.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalEvent"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Batch deletion based on criteria (status and date)",
    "transactionHandling": "Likely handled by the Spring Batch framework or the repository implementation",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "repository.deleteOlderEventsWithSentStatus(ExternalEventStatus.SENT, dateForPurgeCriteria);"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.jobs.SendAsynchronousEventsTasklet",
    "mechanism": "SPRING-DATA",
    "name": "ExternalEventRepository",
    "description": "The class uses `ExternalEventRepository` to interact with the database. It reads events with a specific status and updates them after processing.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "external_event"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD for retrieval and batch updates for status changes.",
    "transactionHandling": "Spring @Transactional (implied by Spring Batch context)",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "repository.findByStatusOrderById(ExternalEventStatus.TO_BE_SENT, batchSize)"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.jobs.SendAsynchronousEventsTaskletTest",
    "mechanism": "SPRING-DATA",
    "name": "ExternalEventRepository",
    "description": "The code under test interacts with a Spring Data repository (ExternalEventRepository) to fetch pending events and update their status. The test mocks this interaction.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalEvent"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code performs a read operation with pagination (findByStatusOrderById) and a write operation to update status (markEventsSent).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "when(repository.findByStatusOrderById(Mockito.any(), Mockito.any())).thenReturn(events);\nverify(repository).markEventsSent(Mockito.eq(events.stream().map(ExternalEventView::getId).toList()), Mockito.any());"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.repository",
    "mechanism": "SPRING-DATA",
    "name": "ExternalEventRepository",
    "description": "The interface extends JpaRepository to provide standard CRUD operations and defines custom JPQL queries for specific business requirements. It interacts with the 'ExternalEvent' table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalEvent"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries including SELECT with pagination, bulk DELETE based on criteria, and bulk UPDATE by ID list.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories, explicit @Modifying usage)",
    "protocol": "JPA/JDBC",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"UPDATE ExternalEvent e SET e.status = ... WHERE e.id IN :ids\")\nvoid markEventsSent(@Param(\"ids\") List<Long> ids, ...);"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.repository.CustomExternalEventConfigurationRepository",
    "mechanism": "SPRING-DATA",
    "name": "CustomExternalEventConfigurationRepository",
    "description": "This interface represents a Data Access Object (DAO) or Repository component, likely part of a Spring Data JPA setup. It defines a read operation to fetch configuration data from the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalEventConfiguration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "ExternalEventConfiguration findExternalEventConfigurationByTypeWithNotFoundDetection(String externalEventType);"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.repository.ExternalEventConfigurationRepository",
    "mechanism": "SPRING-DATA",
    "name": "ExternalEventConfigurationRepository",
    "description": "The file is a Spring Data JPA repository interface. It provides database access for the ExternalEventConfiguration entity by extending JpaRepository, which automatically provides CRUD operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalEventConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by Spring Data JPA, plus potentially complex queries defined in the custom parent interface.",
    "transactionHandling": "Spring @Transactional (implicitly handled by Spring Data JPA implementation)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ExternalEventConfigurationRepository\n        extends JpaRepository<ExternalEventConfiguration, String>, CustomExternalEventConfigurationRepository {}"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.repository.domain",
    "mechanism": "SPRING-DATA",
    "name": "ExternalEventView",
    "description": "This interface functions as a Spring Data JPA Projection (Closed Projection). It allows the application to retrieve a read-only view of the 'ExternalEvent' entity (or underlying table) containing only the fields defined by the getter methods. This mechanism optimizes database performance by fetching only necessary columns rather than the entire entity graph.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalEvent"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple projection queries generated by Spring Data",
    "transactionHandling": "Managed by the calling repository method (usually read-only)",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "public interface ExternalEventView {\n    Long getId();\n    String getType();\n    // ... other getters map to columns\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.service",
    "mechanism": "SPRING-DATA",
    "name": "ExternalEventConfigurationRepository",
    "description": "The class interacts with the database through the ExternalEventConfigurationRepository, which is likely a Spring Data JPA repository interface. It performs a read operation to fetch all records of the ExternalEventConfiguration entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalEventConfiguration"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "List<ExternalEventConfiguration> eventConfigurations = repository.findAll();"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.service",
    "mechanism": "SPRING-DATA",
    "name": "ExternalEventConfigurationRepository",
    "description": "The class uses a Spring Data repository interface (`ExternalEventConfigurationRepository`) to perform CRUD operations on `ExternalEventConfiguration` entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalEventConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code performs a lookup by event type (likely a SELECT) inside a loop, followed by a batch save operation (INSERT/UPDATE).",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final ExternalEventConfiguration configuration = repository\n        .findExternalEventConfigurationByTypeWithNotFoundDetection(eventType);\n// ... modification logic ...\nthis.repository.saveAll(modifiedConfigurations);"
  },
  {
    "path": "org.apache.fineract.infrastructure.event.external.service.serialization.serializer.loan",
    "mechanism": "SPRING-DATA",
    "name": "LoanTransactionRepository",
    "description": "The class uses `LoanTransactionRepository` to retrieve data related to unpaid charges for a specific loan during the serialization process.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_transaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple retrieval of aggregated or list data (unpaid charges) associated with a loan entity.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "List<UnpaidChargeData> unpaidChargeDataList = loanTransactionRepository.fetchTotalUnpaidChargesForLoan(event.get().getLoan());"
  },
  {
    "path": "org.apache.fineract.infrastructure.gcm.domain",
    "mechanism": "SPRING-DATA",
    "name": "DeviceRegistrationRepository",
    "description": "The class interacts with the database through a Spring Data repository interface (DeviceRegistrationRepository). It performs standard CRUD operations and custom lookups without writing explicit SQL.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DeviceRegistration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and a lookup by Client ID.",
    "transactionHandling": "Implicitly handled by the Spring Data repository implementation.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.repository.findById(deviceRegistrationId)\n        .orElseThrow(() -> new DeviceRegistrationNotFoundException(deviceRegistrationId));"
  },
  {
    "path": "org.apache.fineract.infrastructure.gcm.domain",
    "mechanism": "SPRING-DATA",
    "name": "DeviceRegistrationRepository",
    "description": "The code uses Spring Data JPA repositories to interact with the database. It extends JpaRepository to inherit standard CRUD operations and defines a custom JPQL query to filter data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DeviceRegistration"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "JPQL queries via @Query annotation and standard Spring Data CRUD",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(FIND_DEVICE_REGISTRATION_BY_CLIENT)\nDeviceRegistration findDeviceRegistrationByClientId(@Param(\"clientId\") Long clientId);"
  },
  {
    "path": "org.apache.fineract.infrastructure.gcm.service",
    "mechanism": "SPRING-DATA",
    "name": "DeviceRegistrationRepositoryWrapper",
    "description": "The class uses repository wrappers (likely wrapping Spring Data JPA repositories) to perform CRUD operations on DeviceRegistration and Client entities. It relies on JPA annotations on the domain objects for mapping.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DeviceRegistration",
      "Client"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save, findOne, delete) via repository abstraction.",
    "transactionHandling": "Spring @Transactional annotations on the class/methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.deviceRegistrationRepository.save(deviceRegistration);"
  },
  {
    "path": "org.apache.fineract.infrastructure.gcm.service",
    "mechanism": "SPRING-DATA",
    "name": "SmsMessageRepository",
    "description": "The service uses Spring Data repositories to interact with the database. It reads device registration information via `DeviceRegistrationRepositoryWrapper` (which likely wraps a repository) and persists the status of SMS messages using `SmsMessageRepository`.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsMessage",
      "DeviceRegistration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations: finding an entity by ID (DeviceRegistration) and batch saving entities (SmsMessage).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "smsMessageRepository.saveAll(smsList);"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.domain",
    "mechanism": "SPRING-DATA",
    "name": "HookRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends `JpaRepository` to provide standard data access methods and defines custom JPQL queries for specific business requirements.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Hook",
      "Hook.events"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with inner joins and parameter binding",
    "transactionHandling": "Spring Data JPA default transaction management",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select hook from Hook hook inner join hook.events event where event.entityName = :entityName...\")"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.domain",
    "mechanism": "SPRING-DATA",
    "name": "HookTemplateRepository",
    "description": "The code uses Spring Data JPA repositories to interact with the database. It extends JpaRepository to provide standard data access capabilities and defines custom JPQL queries via annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "HookTemplate"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined in @Query annotations and standard CRUD operations.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select template from HookTemplate template where template.name = :name\")\nHookTemplate findOne(@Param(\"name\") String name);"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.domain",
    "mechanism": "SPRING-DATA",
    "name": "HookConfigurationRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access for the HookConfiguration entity and defines a custom JPQL query.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "HookConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select config.fieldValue from HookConfiguration config where config.hook.id = :hookId and config.fieldName = :fieldName\")"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.processor.MessageGatewayHookProcessor",
    "mechanism": "SPRING-DATA",
    "name": "SmsMessageRepository, ClientRepositoryWrapper, TemplateRepository",
    "description": "The class uses Spring Data repositories (and wrappers) to interact with the database. It reads templates and client information and writes new SMS message records.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_template",
      "m_client",
      "sms_messages"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via repository methods (findByTemplateMapper, findOne, save).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "SmsMessage smsMessage = SmsMessage.pendingSms(null, null, client, null, smsText, client.mobileNo(), null, false);\nthis.smsMessageRepository.save(smsMessage);"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.processor.TwilioHookProcessor",
    "mechanism": "SPRING-DATA",
    "name": "HookConfigurationRepository, ClientRepositoryWrapper",
    "description": "The class interacts with the database to retrieve and store hook configurations (specifically API keys) and to look up client information (mobile numbers) for template processing.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "HookConfiguration",
      "Client"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations to find configuration by ID and field name, save new configurations, and find client entities by ID.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "String apiKey = this.hookConfigurationRepository.findOneByHookIdAndFieldName(hook.getId(), apiKeyName);\n...\nthis.hookConfigurationRepository.save(apiKeyEntry);\n...\nfinal Client client = this.clientRepositoryWrapper.findOneWithNotFoundDetection(clientId);"
  },
  {
    "path": "org.apache.fineract.infrastructure.hooks.service.HookWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "HookRepository",
    "description": "The class uses Spring Data JPA repositories (HookRepository, HookTemplateRepository, TemplateRepository) to perform CRUD operations on Hook entities and related data. It relies on the underlying JPA implementation (likely Hibernate) for object-relational mapping.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Hook",
      "HookTemplate",
      "Template"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, findById, findOne, delete) are used. No complex custom queries are visible in this service layer.",
    "transactionHandling": "Spring @Transactional annotations are used on public methods to ensure atomicity of operations.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.hookRepository.saveAndFlush(hook);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain",
    "mechanism": "SPRING-DATA",
    "name": "JobParameterRepository",
    "description": "The file uses Spring Data JPA to interact with the database. By extending JpaRepository, it automatically gains methods for saving, deleting, and finding JobParameter entities. It also defines a custom JPQL query to filter results.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "JobParameter"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select jobParameter from JobParameter jobParameter where jobParameter.jobId=:jobId\")\nList<JobParameter> findJobParametersByJobId(@Param(\"jobId\") Long jobId);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain",
    "mechanism": "SPRING-DATA",
    "name": "ScheduledJobRunHistoryRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access methods and defines a custom JPQL query for specific business logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ScheduledJobRunHistory"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with aggregations",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select max(sjrh.version) from ScheduledJobRunHistory sjrh where sjrh.scheduledJobDetail.jobKey = :jobKey\")"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain.CustomJobParameterRepository",
    "mechanism": "SPRING-DATA",
    "name": "CustomJobParameterRepository",
    "description": "This interface represents a Data Access Object (DAO) or Repository pattern, likely used within a Spring Data context (common in the Fineract project structure). It defines methods for CRUD operations (Create and Read) on the CustomJobParameter entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CustomJobParameter"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save and find by ID).",
    "transactionHandling": "Likely handled by Spring @Transactional at the service layer or default repository implementation.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Long save(Set<JobParameterDTO> customJobParameters);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain.ScheduledJobDetailRepository",
    "mechanism": "SPRING-DATA",
    "name": "ScheduledJobDetailRepository",
    "description": "The file is a Spring Data JPA repository interface that manages database interactions for the ScheduledJobDetail entity. It uses JPQL annotations for custom queries and standard JPA locking annotations for concurrency control.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ScheduledJobDetail"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with named parameters, pessimistic locking, and derived query methods.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select jobDetail from ScheduledJobDetail jobDetail where jobDetail.jobKey = :jobKey\")\nScheduledJobDetail findByJobKey(@Param(\"jobKey\") String jobKey);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.domain.SchedulerDetailRepository",
    "mechanism": "SPRING-DATA",
    "name": "SchedulerDetailRepository",
    "description": "The code defines a Spring Data JPA repository interface. This mechanism automatically generates the implementation for database access, mapping the 'SchedulerDetail' Java entity to a relational database table. It supports standard CRUD operations and dynamic queries via Specifications.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SchedulerDetail"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data JPA.",
    "transactionHandling": "Spring Data repositories are transactional by default (@Transactional is applied to the proxy methods).",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface SchedulerDetailRepository extends JpaRepository<SchedulerDetail, Long>, JpaSpecificationExecutor<SchedulerDetail> {}"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.filter.LoanCOBFilterHelper",
    "mechanism": "SPRING-DATA",
    "name": "Loan and GLIM Repositories",
    "description": "The class uses Spring Data JPA repositories to resolve loan identifiers from external IDs or reschedule request IDs, and to retrieve GLIM account details. It also indirectly queries loan business dates via a service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan",
      "GroupLoanIndividualMonitoringAccount",
      "LoanRescheduleRequest"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookups by ID or External ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return loanRepository.findIdByExternalId(new ExternalId(externalId));"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service",
    "mechanism": "SPRING-DATA",
    "name": "JobExecutionRepository",
    "description": "The service interacts with the database via a Spring Data repository to query job execution states, count stuck jobs, and update job statuses.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Counts entities, finds IDs by criteria, and updates status fields.",
    "transactionHandling": "Uses Spring TransactionTemplate with PROPAGATION_REQUIRES_NEW for status updates.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Long stuckJobCount = jobExecutionRepository.getStuckJobCountByJobName(jobName);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service",
    "mechanism": "SPRING-DATA",
    "name": "JobParameterRepository",
    "description": "The class uses a Spring Data repository interface to fetch job parameters stored in the database associated with a specific job ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "job_parameters"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookup by foreign key (job ID)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "List<org.apache.fineract.infrastructure.jobs.domain.JobParameter> jobParameterList = jobParameterRepository\n        .findJobParametersByJobId(scheduledJobDetail.getId());"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service.SchedularWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "ScheduledJobRepositories",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs CRUD operations and utilizes specific query methods defined in the repository interfaces.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ScheduledJobDetail",
      "ScheduledJobRunHistory",
      "SchedulerDetail"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, findAll) plus custom finders (findByJobKey, findMaxVersionByJobKey) and locking (findByJobKeyWithLock).",
    "transactionHandling": "Spring @Transactional annotations on write methods.",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "this.scheduledJobDetailsRepository.save(scheduledJobDetails);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service.SchedulerJobListener",
    "mechanism": "SPRING-DATA",
    "name": "SchedularWritePlatformService / AppUserRepositoryWrapper",
    "description": "The class interacts with the database indirectly through injected service components. It uses `AppUserRepositoryWrapper` to read system user details and `SchedularWritePlatformService` to read job details and write job execution history.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_appuser",
      "job",
      "job_run_history"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "CRUD operations via service layer abstractions.",
    "transactionHandling": "Likely handled by the called services (Spring @Transactional)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.schedularService.saveOrUpdate(scheduledJobDetails, runHistory);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service.executealldirtyjobs",
    "mechanism": "SPRING-DATA",
    "name": "ScheduledJobDetailRepository",
    "description": "The class uses a Spring Data repository interface to query for scheduled job details.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ScheduledJobDetail"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Repository method call to find mismatched jobs",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "List<ScheduledJobDetail> jobDetails = scheduledJobDetailsRepository.findAllMismatchedJobs(true);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service.increasedateby1day.IncreaseDateBy1DayServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "BusinessDateRepository",
    "description": "The class interacts with the database primarily through the `BusinessDateRepository` to read existing date configurations. It also delegates write operations to `BusinessDateWritePlatformService`, which implies further database interaction for updating records.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "BusinessDate"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple entity lookup by type via Spring Data repository.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Optional<BusinessDate> businessDateEntity = businessDateRepository.findByType(businessDateType);"
  },
  {
    "path": "org.apache.fineract.infrastructure.jobs.service.jobparameterprovider",
    "mechanism": "SPRING-DATA",
    "name": "CustomJobParameterRepository",
    "description": "The class uses a Spring Data repository (`CustomJobParameterRepository`) to persist job parameter data into the database. This allows the application to store dynamic parameters associated with a specific batch job execution instance.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Long customJobParameterId = customJobParameterRepository.save(getJobParameterDTOListWithCorrectBusinessDate(jobParameterDTOSet));"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.domain",
    "mechanism": "SPRING-DATA",
    "name": "ReportMailingJobRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, which provides standard CRUD operations, and JpaSpecificationExecutor for dynamic queries. It maps the ReportMailingJob entity to a database table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ReportMailingJob"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data JPA derived query methods and standard CRUD operations.",
    "transactionHandling": "Spring Data JPA repositories are transactional by default (read-only for read methods, read-write for others).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ReportMailingJobRepository extends JpaRepository<ReportMailingJob, Long>, JpaSpecificationExecutor<ReportMailingJob> { ... }"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.domain",
    "mechanism": "SPRING-DATA",
    "name": "ReportMailingJobRepository",
    "description": "The class interacts with the database through a Spring Data repository interface (ReportMailingJobRepository). It performs read operations to fetch entities by primary key.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ReportMailingJob"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD retrieval by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.reportMailingJobRepository.findById(id)"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.domain.ReportMailingJobConfigurationRepository",
    "mechanism": "SPRING-DATA",
    "name": "ReportMailingJobConfigurationRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to inherit standard CRUD operations and JpaSpecificationExecutor for dynamic queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ReportMailingJobConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and a specific derived query method for finding by name.",
    "transactionHandling": "Spring @Transactional (implicitly handled by the JpaRepository implementation)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ReportMailingJobConfigurationRepository\n        extends JpaRepository<ReportMailingJobConfiguration, Integer>..."
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.domain.ReportMailingJobRunHistoryRepository",
    "mechanism": "SPRING-DATA",
    "name": "ReportMailingJobRunHistoryRepository",
    "description": "The file uses Spring Data JPA to manage database interactions for the ReportMailingJobRunHistory entity. It inherits standard CRUD capabilities and specification execution logic without requiring manual SQL implementation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ReportMailingJobRunHistory"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic criteria-based queries via JpaSpecificationExecutor.",
    "transactionHandling": "Spring @Transactional (implicitly handled by the Spring Data JPA repository implementation)",
    "protocol": "JDBC (abstracted by JPA)",
    "connectionInfo": "unknown",
    "codeExample": "public interface ReportMailingJobRunHistoryRepository\n        extends JpaRepository<ReportMailingJobRunHistory, Long>, JpaSpecificationExecutor<ReportMailingJobRunHistory> {\n\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.handler",
    "mechanism": "SPRING-DATA",
    "name": "ReportMailingJobWritePlatformService",
    "description": "The class manages database transactions via the Spring @Transactional annotation. While it does not execute SQL directly, it defines the transaction boundary for the 'createReportMailingJob' operation, ensuring that the database writes performed by the injected service are committed or rolled back as a single unit.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Override\n@Transactional\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n    return this.reportMailingJobWritePlatformService.createReportMailingJob(jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.reportmailingjob.service",
    "mechanism": "SPRING-DATA",
    "name": "ReportMailingJobRepository",
    "description": "The class uses Spring Data JPA repositories (ReportMailingJobRepository and ReportRepositoryWrapper) to perform CRUD operations on ReportMailingJob and Report entities. It uses @Transactional to ensure atomicity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ReportMailingJob",
      "Report"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, saveAndFlush, findOne) with some domain logic handling updates.",
    "transactionHandling": "Spring @Transactional annotations on public methods",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "this.reportMailingJobRepository.saveAndFlush(reportMailingJob);"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.command",
    "mechanism": "SPRING-DATA",
    "name": "TwoFactorConfigurationService",
    "description": "The class manages database transactions via the Spring '@Transactional' annotation while delegating the actual data persistence logic to the 'TwoFactorConfigurationService'.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TWOFACTOR_CONFIGURATION"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates update logic to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    // ...\n    final Map<String, Object> changes = configurationService.update(command);\n    // ...\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.command.InvalidateTFAccessTokenCommandHandler",
    "mechanism": "SPRING-DATA",
    "name": "TwoFactorService",
    "description": "The class delegates data persistence operations to `TwoFactorService`, which manages the `TFAccessToken` entity. The method is annotated with `@Transactional`, indicating it participates in a database transaction managed by Spring.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TFAccessToken"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for entity updates.",
    "transactionHandling": "Spring @Transactional annotation",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "final TFAccessToken accessToken = twoFactorService.invalidateAccessToken(user, command);"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.domain",
    "mechanism": "SPRING-DATA",
    "name": "TFAccessTokenRepository",
    "description": "The interface extends JpaRepository, leveraging Spring Data JPA to manage database interactions for the TFAccessToken entity. It provides abstraction over the underlying SQL queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TFAccessToken"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and simple property-based filtering (findByUserAndToken).",
    "transactionHandling": "Spring Data Repositories are transactional by default (read-only for find methods, read-write for save/delete).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface TFAccessTokenRepository extends JpaRepository<TFAccessToken, Long> {\n    TFAccessToken findByUserAndToken(AppUser user, String token);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.domain",
    "mechanism": "SPRING-DATA",
    "name": "TwoFactorConfigurationRepository",
    "description": "The interface extends JpaRepository, utilizing Spring Data JPA to manage persistence for the TwoFactorConfiguration entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TwoFactorConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and a specific finder by name.",
    "transactionHandling": "Transactions are managed by the Spring container, typically applying read-only transactions to find methods and read-write to others.",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "TwoFactorConfiguration config = repository.findByName(\"otp_provider\");"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.domain.PlatformUserRepository",
    "mechanism": "SPRING-DATA",
    "name": "PlatformUserRepository",
    "description": "The interface functions as a Spring Data repository, leveraging method name derivation to perform database queries without writing explicit SQL.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PlatformUser"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Derived finder method (Simple CRUD)",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "PlatformUser findByUsernameAndDeletedAndEnabled(String username, boolean deleted, boolean enabled);"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.service",
    "mechanism": "SPRING-DATA",
    "name": "PlatformUserRepository",
    "description": "The class uses a Spring Data JPA repository (PlatformUserRepository) to query the database for user information.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PlatformUser (entity)"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple finder method (findByUsernameAndDeletedAndEnabled)",
    "transactionHandling": "Implicit (Spring Data default)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.platformUserRepository.findByUsernameAndDeletedAndEnabled(username, deleted, enabled);"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.service",
    "mechanism": "SPRING-DATA",
    "name": "TwoFactorConfigurationRepository",
    "description": "The class uses a Spring Data JPA repository (`TwoFactorConfigurationRepository`) to access and modify `TwoFactorConfiguration` entities stored in the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TwoFactorConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findAll, findByName, save)",
    "transactionHandling": "Spring @Transactional (implied by Service/Repository usage)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "List<TwoFactorConfiguration> configurationList = configurationRepository.findAll();"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.service.TwoFactorServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "SecurityRepositories",
    "description": "The service uses Spring Data repositories to interact with the database. It persists OTP requests, access tokens, and SMS messages using injected repository interfaces.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "OTPRequest",
      "TFAccessToken",
      "SmsMessage"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (save, delete, findBy) provided by Spring Data repositories.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.smsMessageRepository.save(smsMessage);"
  },
  {
    "path": "org.apache.fineract.infrastructure.sms.domain",
    "mechanism": "SPRING-DATA",
    "name": "SmsMessageRepository, GroupRepositoryWrapper, ClientRepositoryWrapper, StaffRepositoryWrapper, SmsCampaignRepository",
    "description": "The class uses Spring Data repositories and custom repository wrappers to fetch related entities (Group, Client, Staff, SmsCampaign) and the SmsMessage itself from the database. It performs read operations to resolve foreign keys and validate existence.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_sms_message",
      "m_group",
      "m_client",
      "m_staff",
      "sms_campaign"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookups by ID using repository methods like findOneWithNotFoundDetection and findById.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "smsCampaign = this.smsCampaignRepository.findById(campaignId).orElseThrow(() -> new SmsCampaignNotFound(campaignId));"
  },
  {
    "path": "org.apache.fineract.infrastructure.sms.domain",
    "mechanism": "SPRING-DATA",
    "name": "SmsMessageRepository",
    "description": "The file uses Spring Data JPA repositories to interact with the database. It extends `JpaRepository` to provide standard data access operations for the `SmsMessage` entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsMessage"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository, plus a derived query method for filtering by status.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data Repositories)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface SmsMessageRepository extends JpaRepository<SmsMessage, Long> {\n    Page<SmsMessage> findByStatusType(Integer status, Pageable pageable);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.sms.handler",
    "mechanism": "SPRING-DATA",
    "name": "SmsWritePlatformService",
    "description": "The class defines a transactional boundary using Spring's `@Transactional` annotation. While it does not execute SQL or call a repository directly, it orchestrates a database write operation (delete) by delegating to the `SmsWritePlatformService` within a transaction context.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SMS"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates deletion by ID to service layer",
    "transactionHandling": "Spring @Transactional annotation on processCommand method",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.delete(command.entityId());\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.sms.scheduler.SmsMessageScheduledJobServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "SmsMessageRepository",
    "description": "The class uses a Spring Data repository (`SmsMessageRepository`) to persist the state of SMS messages. It performs batch updates to message statuses before sending them to external systems.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsMessage"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Batch save operations (saveAll) and flush.",
    "transactionHandling": "Implicitly handled by Spring Data repository methods, though no explicit @Transactional annotation is present on the service methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.smsMessageRepository.saveAll(toSaveMessages);\nthis.smsMessageRepository.flush();"
  },
  {
    "path": "org.apache.fineract.infrastructure.sms.service",
    "mechanism": "SPRING-DATA",
    "name": "SmsMessageRepository",
    "description": "The class uses a Spring Data JPA repository (SmsMessageRepository) to perform CRUD operations on the SmsMessage entity. It relies on standard JPA annotations and Spring's exception translation for database interactions.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SmsMessage"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save, saveAndFlush, delete) delegated to the repository interface.",
    "transactionHandling": "Spring @Transactional annotations on methods",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.saveAndFlush(message);"
  },
  {
    "path": "org.apache.fineract.infrastructure.survey.domain",
    "mechanism": "SPRING-DATA",
    "name": "LikelihoodRepository",
    "description": "The file uses Spring Data JPA to interact with the database. By extending JpaRepository, it gains standard CRUD methods, and it defines a custom JPQL query for specific filtering requirements.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Likelihood"
    ],
    "operationType": [
      "READ",
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select liklihood FROM Likelihood liklihood WHERE liklihood.ppiName =:ppiName AND liklihood.id <>:id\")"
  },
  {
    "path": "org.apache.fineract.infrastructure.survey.service",
    "mechanism": "SPRING-DATA",
    "name": "LikelihoodRepository",
    "description": "The class uses a Spring Data JPA repository (LikelihoodRepository) to perform CRUD operations on Likelihood entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Likelihood"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (findById, save) and a custom finder method (findByPpiNameAndLikeliHoodId) followed by a batch save (saveAll).",
    "transactionHandling": "UNKNOWN",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Likelihood likelihood = this.repository.findById(likelihoodId).orElse(null);\nthis.repository.save(likelihood);"
  },
  {
    "path": "org.apache.fineract.interoperation.domain.InteropIdentifierRepository",
    "mechanism": "SPRING-DATA",
    "name": "InteropIdentifierRepository",
    "description": "The interface extends JpaRepository to provide database interaction for the InteropIdentifier entity using Spring Data JPA.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "InteropIdentifier"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and derived query methods based on method names.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository implementation)",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "public interface InteropIdentifierRepository extends JpaRepository<InteropIdentifier, Long> ..."
  },
  {
    "path": "org.apache.fineract.interoperation.service.InteropServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountRepository, InteropIdentifierRepository, JdbcTemplate",
    "description": "The class primarily uses Spring Data JPA repositories for CRUD operations on entities like SavingsAccount, InteropIdentifier, and Loan. It also uses Spring's JdbcTemplate for executing a complex SQL join query to retrieve KYC data efficiently.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client",
      "m_client_address",
      "m_address",
      "m_code_value",
      "m_client_identifier",
      "m_savings_account",
      "m_interop_identifier",
      "m_loan",
      "m_note",
      "m_payment_type",
      "m_savings_account_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Uses standard JPA repository methods for most operations. Uses a complex SQL join query for KYC data retrieval.",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final String sql = \"select \" + rm.schema() + \" where c.id = ?\";\nfinal InteropKycData accountKyc = this.jdbcTemplate.queryForObject(sql, rm, new Object[] { clientId });"
  },
  {
    "path": "org.apache.fineract.investor.accounting.journalentry.service",
    "mechanism": "SPRING-DATA",
    "name": "JournalEntryRepository, ProductToGLAccountMappingRepository, FinancialActivityAccountRepositoryWrapper, GLClosureRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs read operations to fetch GL closures, account mappings, and financial activity accounts. It performs write operations to save new `JournalEntry` records.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "JournalEntry",
      "GLClosure",
      "ProductToGLAccountMapping",
      "FinancialActivityAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, findBy...) and custom repository methods (getLatestGLClosureByBranch, findCoreProductToFinAccountMapping).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return this.glJournalEntryRepository.saveAndFlush(journalEntry);"
  },
  {
    "path": "org.apache.fineract.investor.cob.loan.LoanAccountOwnerTransferBusinessStep",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerTransferRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs complex queries using JPA Specifications (CriteriaBuilder) to find transfers based on multiple conditions (loanId, settlementDate, status, effectiveDate) and performs CRUD operations (save, delete) on transfer and mapping entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransfer",
      "ExternalAssetOwnerTransferLoanMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPA Specifications with dynamic criteria (AND conditions, IN clauses, GreaterThanOrEqualTo comparisons) and standard CRUD operations.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "externalAssetOwnerTransferRepository.findAll(\n    (root, query, criteriaBuilder) -> criteriaBuilder.and(criteriaBuilder.equal(root.get(\"loanId\"), loanId),\n            criteriaBuilder.equal(root.get(\"settlementDate\"), settlementDate),\n            root.get(\"status\").in(List.of(ExternalTransferStatus.PENDING, ExternalTransferStatus.BUYBACK)),\n            criteriaBuilder.greaterThanOrEqualTo(root.get(\"effectiveDateTo\"), FUTURE_DATE_9999_12_31)),\n    Sort.by(Sort.Direction.ASC, \"id\"));"
  },
  {
    "path": "org.apache.fineract.investor.domain",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerTransferLoanMappingRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, which provides standard CRUD capabilities, and defines custom JPQL queries for specific lookups.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransferLoanMapping",
      "ExternalAssetOwnerTransfer"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with joins/relationship traversal and standard CRUD operations.",
    "transactionHandling": "Spring Data repositories are transactional by default (usually read-only for find methods and read-write for others).",
    "protocol": "JDBC (abstracted via JPA)",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"SELECT mapping FROM ExternalAssetOwnerTransferLoanMapping mapping WHERE mapping.ownerTransfer.externalLoanId =:externalLoanId\")"
  },
  {
    "path": "org.apache.fineract.investor.domain",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerJournalEntryMappingRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access methods and defines a custom JPQL query for specific retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerJournalEntryMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via @Query annotations and standard CRUD operations.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "JPA",
    "connectionInfo": "configured externally",
    "codeExample": "@Query(\"SELECT mapping FROM ExternalAssetOwnerJournalEntryMapping mapping WHERE mapping.owner.externalId = :ownerExternalId\")"
  },
  {
    "path": "org.apache.fineract.investor.domain",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerRepository",
    "description": "The code uses Spring Data JPA to manage database interactions. By extending JpaRepository, it automatically gains methods for standard database operations without explicit implementation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwner"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and a specific lookup by external ID.",
    "transactionHandling": "Spring Data JPA default transaction management (usually read-only for find methods and transactional for modifications).",
    "protocol": "JPA",
    "connectionInfo": "configured in application properties",
    "codeExample": "public interface ExternalAssetOwnerRepository extends JpaRepository<ExternalAssetOwner, Long> ..."
  },
  {
    "path": "org.apache.fineract.investor.domain",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerTransferJournalEntryMappingRepository",
    "description": "The file uses Spring Data JPA to manage database interactions for the `ExternalAssetOwnerTransferJournalEntryMapping` entity. It inherits standard database operations and defines a custom JPQL query.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransferJournalEntryMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"SELECT mapping FROM ExternalAssetOwnerTransferJournalEntryMapping mapping WHERE mapping.ownerTransfer.id =:transferId\")"
  },
  {
    "path": "org.apache.fineract.investor.domain.ExternalAssetOwnerTransferRepository",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerTransferRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database using JPA entities and JPQL queries defined via annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransfer",
      "ExternalAssetOwnerTransferLoanMapping",
      "ExternalAssetOwner"
    ],
    "operationType": [
      "READ",
      "READ_WRITE"
    ],
    "queryPatterns": "The repository uses a mix of Spring Data method naming conventions for simple queries and @Query annotations with JPQL for more complex logic involving subqueries, joins, and specific field selections.",
    "transactionHandling": "Spring Data JPA repositories typically participate in existing transactions or create read-only transactions for query methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select e from ExternalAssetOwnerTransfer e where e.loanId = :loanId and e.id = (select max(ex.id) from ExternalAssetOwnerTransfer ex where ex.loanId = :loanId)\")\nOptional<ExternalAssetOwnerTransfer> findLatestByLoanId(@Param(\"loanId\") Long loanId);"
  },
  {
    "path": "org.apache.fineract.investor.domain.search",
    "mechanism": "SPRING-DATA",
    "name": "SearchingExternalAssetOwnerRepository",
    "description": "This interface is part of the Spring Data repository layer. It defines a custom search method that interacts with the database to retrieve investor data. The return type 'Page' indicates it leverages Spring Data's pagination support.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwner"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The method signature implies a dynamic search query based on the fields present in ExternalAssetOwnerSearchRequest.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "Page<SearchedExternalAssetOwner> searchInvestorData(PagedRequest<ExternalAssetOwnerSearchRequest> searchRequest);"
  },
  {
    "path": "org.apache.fineract.investor.enricher",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerTransferRepository",
    "description": "The class interacts with the database via a Spring Data repository to retrieve ownership transfer information associated with a loan.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransfer"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookup by Loan ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "externalAssetOwnerTransferRepository.findActiveOwnerByLoanId(data.getLoanId())"
  },
  {
    "path": "org.apache.fineract.investor.enricher.LoanAccountDataV1Enricher",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerTransferRepository",
    "description": "The class uses a Spring Data repository interface to query the database for active external asset owner transfers associated with a specific loan ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransfer"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookup by Loan ID using a repository method.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "externalAssetOwnerTransferRepository.findActiveByLoanId(data.getId()).ifPresent(transfer -> { ... })"
  },
  {
    "path": "org.apache.fineract.investor.enricher.LoanTransactionDataV1Enricher",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerTransferRepository",
    "description": "The class uses a Spring Data repository interface to query the database for asset owner transfer information.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransfer"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookup by Loan ID returning an Optional entity.",
    "transactionHandling": "Implicitly handled by Spring Data repository invocation (likely read-only transaction).",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "externalAssetOwnerTransferRepository.findActiveOwnerByLoanId(data.getLoanId())"
  },
  {
    "path": "org.apache.fineract.investor.service",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerTransferJournalEntryMappingRepository",
    "description": "The class uses Spring Data JPA repositories to persist mapping entities that link external asset owner transfers and owners to the generated accounting journal entries. It also uses a repository wrapper to retrieve financial activity account configurations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerJournalEntryMapping",
      "ExternalAssetOwnerTransferJournalEntryMapping",
      "FinancialActivityAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (saveAndFlush) and finding by type.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "externalAssetOwnerJournalEntryMappingRepository.saveAndFlush(mapping);"
  },
  {
    "path": "org.apache.fineract.investor.service",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwner Repositories",
    "description": "The class uses multiple Spring Data JPA repositories to interact with the database. It performs read-only operations to fetch transfer data, loan mappings, and journal entry mappings based on various criteria like Loan ID, External ID, or Transfer ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransfer",
      "ExternalAssetOwnerTransferLoanMapping",
      "ExternalAssetOwnerTransferJournalEntryMapping",
      "ExternalAssetOwnerJournalEntryMapping"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard Spring Data findBy... methods with pagination and sorting.",
    "transactionHandling": "Spring @Transactional(readOnly = true) at class level",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "result = externalAssetOwnerTransferRepository.findAllByLoanId(loanId, pageRequest);"
  },
  {
    "path": "org.apache.fineract.investor.service",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwner Repositories",
    "description": "The service interacts with the database using Spring Data JPA repositories to read loan transaction details, check for asset owner mappings, and persist new journal entry mappings.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerJournalEntryMapping",
      "ExternalAssetOwnerTransferLoanMapping",
      "LoanTransaction",
      "JournalEntry"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations: finding a loan ID by transaction ID, finding an active mapping by loan ID, and saving a new mapping entity.",
    "transactionHandling": "Implicitly handled by Spring Data repository methods; no explicit @Transactional annotation on the service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "externalAssetOwnerTransferLoanMappingRepository.findByLoanId(loanId).ifPresent(transferLoanMapping -> {\n    ExternalAssetOwnerJournalEntryMapping mapping = new ExternalAssetOwnerJournalEntryMapping();\n    mapping.setJournalEntry(journalEntry);\n    mapping.setOwner(transferLoanMapping.getOwnerTransfer().getOwner());\n    externalAssetOwnerJournalEntryMappingRepository.saveAndFlush(mapping);\n});"
  },
  {
    "path": "org.apache.fineract.investor.service",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerTransferRepository",
    "description": "The class uses Spring Data JPA repositories to manage `ExternalAssetOwnerTransfer` entities. It utilizes JPA Criteria API (Specifications) within the repository calls to perform complex filtering based on loan IDs, statuses, and dates.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransfer",
      "ExternalAssetOwnerTransferDetails",
      "ExternalAssetOwnerTransferLoanMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPA Criteria API queries with dynamic predicates (AND conditions, IN clauses) and standard CRUD operations (save, delete).",
    "transactionHandling": "Spring @Transactional",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "externalAssetOwnerTransferRepository.findAll((root, query, criteriaBuilder) -> criteriaBuilder.and(criteriaBuilder.equal(root.get(\"loanId\"), loanId), root.get(\"status\").in(List.of(PENDING, BUYBACK))..."
  },
  {
    "path": "org.apache.fineract.investor.service.ExternalAssetOwnersWriteServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "ExternalAssetOwnerTransferRepository, ExternalAssetOwnerRepository, LoanRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs CRUD operations and executes custom queries (via specifications or method naming conventions) to manage the lifecycle of asset transfers and validate loan states.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwnerTransfer",
      "ExternalAssetOwner",
      "Loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (save, findById, existsById) and custom finder methods (findEffectiveTransfersOrderByIdDesc, findByExternalId).",
    "transactionHandling": "Spring @Transactional annotations on public methods ensure atomicity of operations.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "externalAssetOwnerTransferRepository.saveAndFlush(externalAssetOwnerTransfer);"
  },
  {
    "path": "org.apache.fineract.investor.service.search",
    "mechanism": "SPRING-DATA",
    "name": "SearchingExternalAssetOwnerRepository",
    "description": "The service interacts with the database through a Spring Data repository interface named `SearchingExternalAssetOwnerRepository`. It retrieves paged results based on search criteria.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ExternalAssetOwner"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Paged search query via Repository abstraction",
    "transactionHandling": "Spring @Transactional(readOnly = true)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return externalAssetOwnerRepository.searchInvestorData(searchRequest).map(externalAssetOwnerSearchDataMapper::map);"
  },
  {
    "path": "org.apache.fineract.mix.domain",
    "mechanism": "SPRING-DATA",
    "name": "MixTaxonomyMappingRepository",
    "description": "This interface is a Spring Data JPA repository that abstracts database interactions for the `MixTaxonomyMapping` entity. It delegates low-level JDBC and SQL operations to the Hibernate/JPA provider configured in the Spring context.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "MixTaxonomyMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (save, delete, findById, findAll) and dynamic queries via Specifications.",
    "transactionHandling": "Transactions are handled by the Spring container, typically applying @Transactional behavior to repository methods by default.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface MixTaxonomyMappingRepository\n        extends JpaRepository<MixTaxonomyMapping, Long>, JpaSpecificationExecutor<MixTaxonomyMapping> {\n\n}"
  },
  {
    "path": "org.apache.fineract.mix.service",
    "mechanism": "SPRING-DATA",
    "name": "MixTaxonomyMappingRepository",
    "description": "The class uses a Spring Data repository (MixTaxonomyMappingRepository) to perform CRUD operations on the MixTaxonomyMapping entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "MixTaxonomyMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findById, saveAndFlush)",
    "transactionHandling": "Spring @Transactional annotation on the updateMapping method",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.mappingRepository.saveAndFlush(mapping);"
  },
  {
    "path": "org.apache.fineract.notification.domain.NotificationMapperRepository",
    "mechanism": "SPRING-DATA",
    "name": "NotificationMapperRepository",
    "description": "This interface is a Spring Data JPA repository that provides database access for the NotificationMapper entity. It inherits standard CRUD operations from JpaRepository.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "NotificationMapper"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository without custom queries.",
    "transactionHandling": "Spring @Transactional (default behavior for JpaRepository methods)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface NotificationMapperRepository extends JpaRepository<NotificationMapper, Long> {}"
  },
  {
    "path": "org.apache.fineract.notification.domain.NotificationRepository",
    "mechanism": "SPRING-DATA",
    "name": "NotificationRepository",
    "description": "The interface extends JpaRepository, allowing Spring Data to generate the implementation for database access at runtime. It manages the persistence of the Notification entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Notification"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "JDBC (via JPA)",
    "connectionInfo": "unknown",
    "codeExample": "public interface NotificationRepository extends JpaRepository<Notification, Long> {}"
  },
  {
    "path": "org.apache.fineract.notification.service",
    "mechanism": "SPRING-DATA",
    "name": "AppUserRepository, NotificationGeneratorWritePlatformService",
    "description": "The class interacts with the database using Spring Data repositories and wrapper services. It performs read operations to fetch `AppUser` entities and write operations to persist `Notification` and `NotificationMapper` entities. The entire operation is wrapped in a Spring `@Transactional` annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Notification",
      "NotificationMapper",
      "AppUser"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations involving finding entities by ID and saving new entities.",
    "transactionHandling": "Spring @Transactional annotation on the class level.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "AppUser appUser = this.appUserRepository.findById(userId).orElseThrow();\nNotificationMapper notificationMapper = new NotificationMapper().setNotification(...).setUserId(appUser)...;\nthis.notificationMapperWritePlatformService.create(notificationMapper);"
  },
  {
    "path": "org.apache.fineract.notification.service",
    "mechanism": "SPRING-DATA",
    "name": "AppUserRepository",
    "description": "The class uses the AppUserRepository, which is likely a Spring Data JPA repository, to query user information from the database. It retrieves users by ID and by office ID to determine notification recipients.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AppUser"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookups by ID and Office ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "Collection<AppUser> users = appUserRepository.findByOfficeId(officeId);"
  },
  {
    "path": "org.apache.fineract.notification.service",
    "mechanism": "SPRING-DATA",
    "name": "NotificationRepository",
    "description": "The class interacts with the database via the NotificationRepository, which is a Spring Data repository interface. It performs standard CRUD operations (Read and Delete) on the Notification entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Notification"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.notificationRepository.findById(id).orElse(null);"
  },
  {
    "path": "org.apache.fineract.notification.service",
    "mechanism": "SPRING-DATA",
    "name": "NotificationMapperRepository",
    "description": "The class interacts with the database through the NotificationMapperRepository, which is a Spring Data repository interface. It performs write operations to persist NotificationMapper entities using JPA mechanisms.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "NotificationMapper"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Simple CRUD save operation using JPA repository methods.",
    "transactionHandling": "Implicitly handled by Spring Data repository or service layer transaction configuration.",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "this.notificationMapperRepository.saveAndFlush(notificationMapper);"
  },
  {
    "path": "org.apache.fineract.notification.service.NotificationGeneratorWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "NotificationRepository",
    "description": "The class interacts with the database through a Spring Data repository interface (`NotificationRepository`). It uses the `saveAndFlush` method to persist entities immediately.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Notification"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.notificationRepository.saveAndFlush(notification);"
  },
  {
    "path": "org.apache.fineract.notification.service.NotificationMapperReadRepositoryWrapperImpl",
    "mechanism": "SPRING-DATA",
    "name": "NotificationMapperRepository",
    "description": "The class uses a Spring Data repository (NotificationMapperRepository) to interact with the database. This abstracts the underlying SQL or JPA queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "NotificationMapper"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findById, findAll, deleteById) provided by Spring Data infrastructure.",
    "transactionHandling": "Spring Data Repository default transaction handling (likely read-only for reads and transactional for deletes at the repository level).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.notificationMapperRepository.findById(id).orElse(null);"
  },
  {
    "path": "org.apache.fineract.organisation.holiday.domain",
    "mechanism": "SPRING-DATA",
    "name": "HolidayRepository",
    "description": "The file is a Spring Data JPA repository that manages persistence for the Holiday entity. It uses JPQL annotations to define specific read operations involving joins and filtering.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Holiday"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with joins and conditional filtering",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select holiday from Holiday holiday... where holiday.processed = false\")"
  },
  {
    "path": "org.apache.fineract.organisation.holiday.domain.HolidayRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "HolidayRepository",
    "description": "The class wraps a Spring Data repository (HolidayRepository) to perform CRUD operations and custom queries on Holiday entities. It abstracts the direct repository calls.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Holiday"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and custom finders with filtering by status and date.",
    "transactionHandling": "Likely relies on Spring's default repository transaction management or service-layer @Transactional (though not present on this class directly).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return this.repository.findById(id).orElseThrow(() -> new HolidayNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.organisation.holiday.service.HolidayWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "HolidayRepositoryWrapper, OfficeRepositoryWrapper, WorkingDaysRepositoryWrapper",
    "description": "The class interacts with the database through repository wrapper classes (`HolidayRepositoryWrapper`, `OfficeRepositoryWrapper`, `WorkingDaysRepositoryWrapper`), which are injected via Spring's dependency injection. These wrappers are assumed to encapsulate Spring Data JPA repositories. All public methods that modify data are annotated with `@Transactional`, delegating transaction management to the Spring framework. The class performs create, read, and update operations using methods like `saveAndFlush` and `findOneWithNotFoundDetection` on the repository wrappers.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Holiday",
      "Office",
      "WorkingDays"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.holidayRepository.saveAndFlush(holiday);"
  },
  {
    "path": "org.apache.fineract.organisation.monetary.domain",
    "mechanism": "SPRING-DATA",
    "name": "ApplicationCurrencyRepository",
    "description": "The class interacts with the database through the ApplicationCurrencyRepository interface, which is likely a Spring Data JPA repository. It performs read operations to fetch currency details by their unique code.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ApplicationCurrency"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD lookup by unique code",
    "transactionHandling": "unknown",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.findOneByCode(currencyCode)"
  },
  {
    "path": "org.apache.fineract.organisation.monetary.domain.ApplicationCurrencyRepository",
    "mechanism": "SPRING-DATA",
    "name": "ApplicationCurrencyRepository",
    "description": "The file uses Spring Data JPA to interact with the database. By extending JpaRepository, it gains automatic implementations for standard database operations, and by defining method signatures like findOneByCode, it triggers automatic query generation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ApplicationCurrency"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "simple CRUD, derived query methods",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "public interface ApplicationCurrencyRepository\n        extends JpaRepository<ApplicationCurrency, Long>..."
  },
  {
    "path": "org.apache.fineract.organisation.monetary.service",
    "mechanism": "SPRING-DATA",
    "name": "OrganisationCurrencyRepository",
    "description": "The class uses Spring Data repositories (OrganisationCurrencyRepository and ApplicationCurrencyRepositoryWrapper) to perform CRUD operations. It reads application currencies, checks existing organization currencies, and performs a bulk delete followed by a save operation to update the allowed currencies list.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "OrganisationCurrency (table unknown)",
      "ApplicationCurrency (table unknown)"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations including findOne, findAll, deleteAll, and saveAll.",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.organisationCurrencyRepository.deleteAll();\nthis.organisationCurrencyRepository.saveAll(allowedCurrencies);"
  },
  {
    "path": "org.apache.fineract.organisation.office.domain",
    "mechanism": "SPRING-DATA",
    "name": "OrganisationCurrencyRepository",
    "description": "The class interacts with the database through a Spring Data repository interface (OrganisationCurrencyRepository). It performs read operations to fetch currency configuration data based on a unique code.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "OrganisationCurrency"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD read operation (find by code)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final OrganisationCurrency organisationCurrency = this.repository.findOneByCode(currencyCode);"
  },
  {
    "path": "org.apache.fineract.organisation.office.domain",
    "mechanism": "SPRING-DATA",
    "name": "OfficeRepository",
    "description": "The class wraps a Spring Data repository (OfficeRepository) to perform CRUD operations on the Office entity. It uses standard JPA/Spring Data patterns for retrieval and persistence.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Office"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via Spring Data JPA methods (findById, save, delete).",
    "transactionHandling": "Uses Spring @Transactional(readOnly = true) for the hierarchy retrieval method to support lazy loading.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.findById(id).orElseThrow(() -> new OfficeNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.organisation.office.domain.OfficeRepository",
    "mechanism": "SPRING-DATA",
    "name": "OfficeRepository",
    "description": "The interface uses Spring Data JPA to manage database interactions for the Office entity. It inherits standard CRUD operations and specification execution capabilities, allowing for database abstraction.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Office"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and derived query methods based on method names.",
    "transactionHandling": "Spring Data JPA repositories are transactional by default (read-only for find methods, read-write for save/delete).",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface OfficeRepository extends JpaRepository<Office, Long> ... {\n    Optional<Office> findByExternalId(ExternalId externalId);\n}"
  },
  {
    "path": "org.apache.fineract.organisation.office.domain.OfficeTransactionRepository",
    "mechanism": "SPRING-DATA",
    "name": "OfficeTransactionRepository",
    "description": "Database integration is achieved through Spring Data JPA. The interface extends JpaRepository to provide standard CRUD operations and JpaSpecificationExecutor for dynamic queries on the OfficeTransaction entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "OfficeTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic criteria-based queries via Specifications.",
    "transactionHandling": "Spring @Transactional (default for Spring Data Repositories)",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "public interface OfficeTransactionRepository extends JpaRepository<OfficeTransaction, Long>, JpaSpecificationExecutor<OfficeTransaction> {}"
  },
  {
    "path": "org.apache.fineract.organisation.office.domain.OrganisationCurrencyRepository",
    "mechanism": "SPRING-DATA",
    "name": "OrganisationCurrencyRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard CRUD operations and JpaSpecificationExecutor for complex criteria-based queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "OrganisationCurrency"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and a specific derived query method for finding by code.",
    "transactionHandling": "Spring @Transactional (implicitly handled by Spring Data repositories)",
    "protocol": "JDBC (abstracted by JPA)",
    "connectionInfo": "unknown",
    "codeExample": "public interface OrganisationCurrencyRepository\n        extends JpaRepository<OrganisationCurrency, Long>, JpaSpecificationExecutor<OrganisationCurrency> {\n    OrganisationCurrency findOneByCode(String currencyCode);\n}"
  },
  {
    "path": "org.apache.fineract.organisation.office.service",
    "mechanism": "SPRING-DATA",
    "name": "Office and Transaction Repositories",
    "description": "The class uses Spring Data JPA repositories (wrapped in custom wrappers for some entities) to perform CRUD operations on Office and OfficeTransaction entities. It handles transaction management using Spring's @Transactional annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_office",
      "m_office_transaction",
      "m_currency"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via JPA repositories, with some hierarchy-related logic.",
    "transactionHandling": "Spring @Transactional annotations on service methods",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "this.officeRepositoryWrapper.saveAndFlush(office);"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.domain.ProvisioningCategoryRepository",
    "mechanism": "SPRING-DATA",
    "name": "ProvisioningCategoryRepository",
    "description": "The interface uses Spring Data JPA to provide automatic CRUD and specification-based query capabilities for the ProvisioningCategory entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProvisioningCategory"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic JPA Specifications provided by the framework.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface ProvisioningCategoryRepository\n        extends JpaRepository<ProvisioningCategory, Long>, JpaSpecificationExecutor<ProvisioningCategory> {\n\n}"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.domain.ProvisioningCriteriaDefinitionRepository",
    "mechanism": "SPRING-DATA",
    "name": "ProvisioningCriteriaDefinitionRepository",
    "description": "Database integration is achieved through Spring Data JPA, which automatically implements the repository interface to interact with the database tables mapped to the ProvisioningCriteriaDefinition entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProvisioningCriteriaDefinition"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "public interface ProvisioningCriteriaDefinitionRepository\n        extends JpaRepository<ProvisioningCriteriaDefinition, Long>, JpaSpecificationExecutor<ProvisioningCriteriaDefinition> {\n\n}"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.domain.ProvisioningCriteriaRepository",
    "mechanism": "SPRING-DATA",
    "name": "ProvisioningCriteriaRepository",
    "description": "Database integration is achieved via Spring Data JPA. The interface inherits methods for interacting with the database table mapped to the ProvisioningCriteria entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProvisioningCriteria"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic criteria-based queries provided by Spring Data.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ProvisioningCriteriaRepository\n        extends JpaRepository<ProvisioningCriteria, Long>, JpaSpecificationExecutor<ProvisioningCriteria> {\n\n}"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.service",
    "mechanism": "SPRING-DATA",
    "name": "Repositories (LoanProduct, ProvisioningCategory, GLAccount)",
    "description": "The class uses Spring Data repositories to fetch entities required to assemble the ProvisioningCriteria object. It performs read-only operations to retrieve LoanProducts, ProvisioningCategories, and GLAccounts by ID or all at once.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanProduct",
      "ProvisioningCategory",
      "GLAccount"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD operations (findById, findAll)",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "loanProducts.add(loanProductRepository.findById(productId).orElse(null));"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.service.ProvisioningCategoryWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "ProvisioningCategoryRepository",
    "description": "The class primarily uses a Spring Data JPA repository (ProvisioningCategoryRepository) for CRUD operations on the ProvisioningCategory entity. Additionally, it uses Spring's JdbcTemplate to execute a raw SQL query for checking referential integrity constraints that might not be easily handled by JPA alone (checking usage in loan products).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProvisioningCategory",
      "m_loanproduct_provisioning_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA CRUD operations (save, delete, findById) and one native SQL SELECT query using EXISTS logic.",
    "transactionHandling": "Spring Data default transaction handling (likely @Transactional at interface or repository level)",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "this.provisioningCategoryRepository.saveAndFlush(provisioningCategory);"
  },
  {
    "path": "org.apache.fineract.organisation.provisioning.service.ProvisioningCriteriaWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "ProvisioningCriteriaRepository",
    "description": "The class uses Spring Data JPA repositories (ProvisioningCriteriaRepository and GLAccountRepository) to interact with the database. It performs CRUD operations on ProvisioningCriteria and GLAccount entities, relying on the underlying Hibernate implementation managed by Spring.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProvisioningCriteria",
      "GLAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via JPA Repository methods (saveAndFlush, findById, deleteById).",
    "transactionHandling": "Implicitly handled by Spring Data repositories or service layer transaction management.",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.provisioningCriteriaRepository.saveAndFlush(provisioningCriteria);"
  },
  {
    "path": "org.apache.fineract.organisation.staff.domain",
    "mechanism": "SPRING-DATA",
    "name": "StaffRepository",
    "description": "The class uses a Spring Data repository (StaffRepository) to perform CRUD operations on the Staff entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Staff"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and custom finders by office.",
    "transactionHandling": "Likely handled by Spring Data default transaction management or at the service layer invoking this wrapper.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return this.repository.findById(id).orElseThrow(() -> new StaffNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.organisation.staff.domain.StaffRepository",
    "mechanism": "SPRING-DATA",
    "name": "StaffRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository<Staff, Long>, which provides standard CRUD operations, and JpaSpecificationExecutor<Staff> for dynamic queries. It also defines a custom JPQL query.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Staff"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and one custom JPQL query for filtering by office.",
    "transactionHandling": "Spring @Transactional (default for JpaRepository methods)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(FIND_BY_OFFICE_QUERY)\nStaff findByOffice(@Param(\"id\") Long id, @Param(\"officeId\") Long officeId);"
  },
  {
    "path": "org.apache.fineract.organisation.staff.service",
    "mechanism": "SPRING-DATA",
    "name": "StaffRepository",
    "description": "The class uses Spring Data JPA repositories (StaffRepository) to perform CRUD operations on Staff entities. It also uses OfficeRepositoryWrapper to retrieve Office entities. Transactions are managed via the @Transactional annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Staff",
      "Office"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save, findById) via JPA repositories.",
    "transactionHandling": "Spring @Transactional annotations on methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.staffRepository.saveAndFlush(staff);"
  },
  {
    "path": "org.apache.fineract.organisation.teller.domain",
    "mechanism": "SPRING-DATA",
    "name": "TellerRepository",
    "description": "The interface extends JpaRepository and JpaSpecificationExecutor, indicating it is a Spring Data repository used to interact with the database for the Teller entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Teller"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and a derived query method for filtering by office ID.",
    "transactionHandling": "Spring Data JPA repositories typically use default @Transactional settings on inherited methods.",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface TellerRepository extends JpaRepository<Teller, Long>, JpaSpecificationExecutor<Teller> { ... }"
  },
  {
    "path": "org.apache.fineract.organisation.teller.domain",
    "mechanism": "SPRING-DATA",
    "name": "CashierRepository",
    "description": "The interface uses Spring Data JPA to manage persistence for the Cashier entity, inheriting standard CRUD and specification execution capabilities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Cashier"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository",
    "transactionHandling": "Spring Data JPA default transaction management",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface CashierRepository extends JpaRepository<Cashier, Long>, JpaSpecificationExecutor<Cashier> {"
  },
  {
    "path": "org.apache.fineract.organisation.teller.domain.CashierRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "CashierRepository",
    "description": "The class interacts with the database via a Spring Data repository interface (`CashierRepository`). It performs read operations to fetch entities by primary key.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Cashier"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return this.repository.findById(id).orElseThrow(() -> new TellerNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.organisation.teller.domain.CashierTransactionRepository",
    "mechanism": "SPRING-DATA",
    "name": "CashierTransactionRepository",
    "description": "This interface is a Spring Data JPA repository that manages persistence for the CashierTransaction entity. It automatically provides methods for saving, deleting, and finding entities, as well as executing complex criteria-based queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CashierTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification queries handled by the framework.",
    "transactionHandling": "Spring Data JPA repositories typically apply @Transactional behavior by default (read-only for retrieval, read-write for modifications).",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface CashierTransactionRepository\n        extends JpaRepository<CashierTransaction, Long>, JpaSpecificationExecutor<CashierTransaction> {\n    // no added behavior\n}"
  },
  {
    "path": "org.apache.fineract.organisation.teller.domain.TellerRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "TellerRepository",
    "description": "The class interacts with the database via a Spring Data repository interface (TellerRepository). It performs standard CRUD operations and utilizes JPA/Hibernate features like lazy loading initialization.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Teller"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (findById, save, delete) provided by Spring Data JPA.",
    "transactionHandling": "Spring @Transactional annotations used explicitly on read operations and implicitly via the repository for write operations.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Teller teller = this.repository.findById(id).orElseThrow(() -> new TellerNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.organisation.teller.domain.TellerTransactionRepository",
    "mechanism": "SPRING-DATA",
    "name": "TellerTransactionRepository",
    "description": "The file is a Spring Data JPA repository interface. It provides database abstraction for the TellerTransaction entity, enabling CRUD operations and dynamic specification queries without explicit implementation code.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TellerTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data JPA.",
    "transactionHandling": "Spring @Transactional (implicitly handled by the Spring Data JPA implementation proxy)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface TellerTransactionRepository extends JpaRepository<TellerTransaction, Long>, JpaSpecificationExecutor<TellerTransaction> {\n    // no added behavior\n}"
  },
  {
    "path": "org.apache.fineract.organisation.teller.service.TellerWritePlatformServiceJpaImpl",
    "mechanism": "SPRING-DATA",
    "name": "Teller and Accounting Repositories",
    "description": "The class uses Spring Data JPA repositories (wrapped in Fineract wrappers) to interact with the database. It performs CRUD operations on Teller and Cashier entities and creates JournalEntry records for accounting.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_teller",
      "m_cashier",
      "m_cashier_transactions",
      "acc_gl_journal_entry",
      "m_office",
      "m_staff",
      "acc_gl_account",
      "acc_gl_financial_activity_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, delete, findById) and some custom finders via wrappers.",
    "transactionHandling": "Spring @Transactional annotations on public methods.",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.tellerRepositoryWrapper.saveAndFlush(teller);"
  },
  {
    "path": "org.apache.fineract.organisation.workingdays.domain",
    "mechanism": "SPRING-DATA",
    "name": "WorkingDaysRepository",
    "description": "The class wraps a Spring Data repository interface (WorkingDaysRepository) to perform CRUD operations on the WorkingDays entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "WorkingDays"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations delegated to Spring Data JPA repository.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final List<WorkingDays> workingDaysList = this.repository.findAll();"
  },
  {
    "path": "org.apache.fineract.organisation.workingdays.domain.WorkingDaysRepository",
    "mechanism": "SPRING-DATA",
    "name": "WorkingDaysRepository",
    "description": "The interface uses Spring Data JPA to manage database interactions for the WorkingDays entity. By extending JpaRepository, it automatically provides implementations for standard CRUD operations, and JpaSpecificationExecutor allows for complex, dynamic queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "WorkingDays"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data.",
    "transactionHandling": "Spring Data repositories are transactional by default (read-only for find methods, read-write for others).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface WorkingDaysRepository extends JpaRepository<WorkingDays, Long>, JpaSpecificationExecutor<WorkingDays> {}"
  },
  {
    "path": "org.apache.fineract.organisation.workingdays.service",
    "mechanism": "SPRING-DATA",
    "name": "WorkingDaysRepositoryWrapper",
    "description": "The class uses a repository wrapper (likely wrapping a Spring Data JPA repository) to retrieve and save the WorkingDays entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "WorkingDays"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findOne, saveAndFlush) via a repository wrapper.",
    "transactionHandling": "Spring @Transactional annotation on the update method.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final WorkingDays workingDays = this.daysRepositoryWrapper.findOne();\n// ... updates ...\nthis.daysRepositoryWrapper.saveAndFlush(workingDays);"
  },
  {
    "path": "org.apache.fineract.portfolio.account.domain",
    "mechanism": "SPRING-DATA",
    "name": "ClientRepositoryWrapper, OfficeRepositoryWrapper",
    "description": "The class uses repository wrappers to fetch Client and Office entities by ID. It also relies on other assemblers (SavingsAccountAssembler, LoanAssembler) which implicitly fetch account data from the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client",
      "m_office",
      "m_savings_account",
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookups by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final Long fromClientId = this.fromApiJsonHelper.extractLongNamed(fromClientIdParamName, element);\nfinal Client fromClient = this.clientRepository.findOneWithNotFoundDetection(fromClientId);"
  },
  {
    "path": "org.apache.fineract.portfolio.account.domain",
    "mechanism": "SPRING-DATA",
    "name": "StandingInstructionRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, which provides standard data access methods, and by defining custom JPQL queries via the @Query annotation to perform complex filtering based on entity relationships.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountTransferStandingInstruction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with logical OR conditions to check relationships (toLoanAccount/fromLoanAccount) and status filtering.",
    "transactionHandling": "Spring @Transactional (implicitly handled by Spring Data repository proxies)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(FIND_BY_LOAN_AND_STATUS_QUERY)\nCollection<AccountTransferStandingInstruction> findByLoanAccountAndStatus(@Param(\"loan\") Loan loan, @Param(\"status\") Integer status);"
  },
  {
    "path": "org.apache.fineract.portfolio.account.domain",
    "mechanism": "SPRING-DATA",
    "name": "AccountAssociationsRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, which provides standard CRUD operations, and defines custom JPQL queries for specific lookups.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountAssociations"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries using @Query annotations with named parameters.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select aa from AccountAssociations aa where aa.loanAccount.id= :loanId and aa.associationType = :associationType\")"
  },
  {
    "path": "org.apache.fineract.portfolio.account.domain",
    "mechanism": "SPRING-DATA",
    "name": "AccountTransferRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending `JpaRepository` and defining methods annotated with `@Query` containing JPQL to select data from the `AccountTransferTransaction` entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountTransferTransaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "JPQL queries with filtering by foreign key IDs (loan accounts, loan transactions) and boolean flags (reversed status). Includes OR conditions and IN clauses.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "@Query(\"select att from AccountTransferTransaction att where att.accountTransferDetails.fromLoanAccount.id= :accountNumber and att.reversed=false\")"
  },
  {
    "path": "org.apache.fineract.portfolio.account.domain.AccountTransferDetailRepository",
    "mechanism": "SPRING-DATA",
    "name": "AccountTransferDetailRepository",
    "description": "Database integration is achieved through Spring Data JPA, which automatically implements the repository interface to interact with the underlying database using Hibernate/JPA.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountTransferDetails"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data.",
    "transactionHandling": "Spring Data repositories are transactional by default (read-only for find methods, read-write for save/delete).",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "public interface AccountTransferDetailRepository\n        extends JpaRepository<AccountTransferDetails, Long>, JpaSpecificationExecutor<AccountTransferDetails> {}"
  },
  {
    "path": "org.apache.fineract.portfolio.account.service",
    "mechanism": "SPRING-DATA",
    "name": "AccountTransferDetailRepository, StandingInstructionRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It injects AccountTransferDetailRepository and StandingInstructionRepository to save new transfer details and retrieve/update existing standing instructions. The operations are wrapped in a Spring @Transactional annotation to ensure atomicity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AccountTransferDetails",
      "AccountTransferStandingInstruction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, findById).",
    "transactionHandling": "Spring @Transactional annotation on the class level and methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.accountTransferDetailRepository.saveAndFlush(standingInstruction);"
  },
  {
    "path": "org.apache.fineract.portfolio.account.service.AccountTransfersWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "AccountTransferRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It persists transfer details and transactions, and updates account balances via domain services that also use JPA.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_account_transfer_details",
      "m_account_transfer_transaction",
      "m_loan",
      "m_savings_account",
      "gsim_accounts"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, saveAndFlush, findBy...) and domain service operations.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.accountTransferDetailRepository.saveAndFlush(accountTransferDetails);"
  },
  {
    "path": "org.apache.fineract.portfolio.account.starter",
    "mechanism": "SPRING-DATA",
    "name": "Account and Standing Instruction Services",
    "description": "This configuration class wires up services that interact with the database using two primary mechanisms: Spring JDBC (via JdbcTemplate) for read-only platform services, and Spring Data JPA (via Repositories) for write platform services. The read services execute SQL queries directly, while the write services use repositories for entity persistence.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The configured services likely use a mix of direct SQL SELECTs (read services) and JPA entity operations (write services).",
    "transactionHandling": "Spring @Transactional (likely used within the service implementations being configured)",
    "protocol": "unknown",
    "connectionInfo": "Configured via Spring Boot DataSource (injected into JdbcTemplate)",
    "codeExample": "public AccountAssociationsReadPlatformService accountAssociationsReadPlatformService(JdbcTemplate jdbcTemplate) {\n    return new AccountAssociationsReadPlatformServiceImpl(jdbcTemplate);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.address.domain.AddressRepository",
    "mechanism": "SPRING-DATA",
    "name": "AddressRepository",
    "description": "The interface utilizes Spring Data JPA to automatically generate database access logic. By extending JpaRepository, it gains standard CRUD capabilities, and by extending JpaSpecificationExecutor, it gains the ability to run dynamic queries based on JPA Criteria.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Address"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic criteria-based queries via Specifications.",
    "transactionHandling": "Spring Data repositories are transactional by default (read-only for read methods, read-write for others).",
    "protocol": "JPA",
    "connectionInfo": "configured externally",
    "codeExample": "public interface AddressRepository extends JpaRepository<Address, Long>, JpaSpecificationExecutor<Address> {}"
  },
  {
    "path": "org.apache.fineract.portfolio.address.domain.FieldConfigurationRepository",
    "mechanism": "SPRING-DATA",
    "name": "FieldConfigurationRepository",
    "description": "This interface is a Spring Data JPA repository that manages database interactions for the FieldConfiguration entity. It automatically maps Java methods to database SQL operations via Hibernate/JPA.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FieldConfiguration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data JPA.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface FieldConfigurationRepository\n        extends JpaRepository<FieldConfiguration, Long>, JpaSpecificationExecutor<FieldConfiguration> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.address.service.AddressWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "AddressRepository, ClientAddressRepository",
    "description": "The class uses Spring Data JPA repositories to perform CRUD operations on Address and ClientAddress entities. It injects these repositories and uses methods like save(), saveAndFlush(), and getReferenceById() to persist data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Address",
      "ClientAddress",
      "CodeValue"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via JPA repositories.",
    "transactionHandling": "Implicitly handled by Spring Data repositories or the calling context (no explicit @Transactional on this class).",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "addressRepository.save(address);\nclientAddressRepository.saveAndFlush(clientAddress);"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.domain",
    "mechanism": "SPRING-DATA",
    "name": "CalendarRepository",
    "description": "The class interacts with the database through a Spring Data repository interface named CalendarRepository. It performs standard CRUD operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Calendar"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations delegated to Spring Data JPA repository.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.repository.findById(calendarId).orElseThrow(() -> new CalendarNotFoundException(calendarId));"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.domain",
    "mechanism": "SPRING-DATA",
    "name": "CalendarHistoryRepository",
    "description": "The interface acts as a Spring Data JPA repository, automatically generating the implementation for database interactions involving the CalendarHistory entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CalendarHistory"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic queries via JPA Specifications.",
    "transactionHandling": "Spring Data JPA repositories typically participate in Spring-managed transactions (@Transactional) by default.",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "public interface CalendarHistoryRepository extends JpaRepository<CalendarHistory, Long>, JpaSpecificationExecutor<CalendarHistory> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.domain",
    "mechanism": "SPRING-DATA",
    "name": "CalendarInstanceRepository",
    "description": "The class wraps a Spring Data repository interface to perform CRUD operations on the CalendarInstance entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CalendarInstance"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations delegated to the repository.",
    "transactionHandling": "Likely handled by the underlying Spring Data repository implementation or higher-level service transactions.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.repository.findById(CalendarInstanceId).orElseThrow(() -> new CalendarInstanceNotFoundException(CalendarInstanceId));"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.domain",
    "mechanism": "SPRING-DATA",
    "name": "CalendarInstanceRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, allowing for standard CRUD operations and custom JPQL queries defined via annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CalendarInstance",
      "Loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The repository uses both simple derived queries (CRUD) and complex JPQL queries involving subqueries and joins with the Loan entity.",
    "transactionHandling": "Transactions are handled by the Spring container, typically defaulting to @Transactional(readOnly = true) for query methods in JpaRepository implementations.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select ci from CalendarInstance ci where ci.entityId in (select loan.id from Loan loan where loan.client.id = :clientId...)\")"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.domain.CalendarRepository",
    "mechanism": "SPRING-DATA",
    "name": "CalendarRepository",
    "description": "The interface uses Spring Data JPA to manage database interactions for the Calendar entity. By extending JpaRepository, it inherits methods for saving, deleting, and finding entities. By extending JpaSpecificationExecutor, it supports complex, dynamic queries based on the JPA Criteria API.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Calendar"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data.",
    "transactionHandling": "Spring @Transactional (implicitly handled by Spring Data JPA implementation)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface CalendarRepository extends JpaRepository<Calendar, Long>, JpaSpecificationExecutor<Calendar> {}"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.service",
    "mechanism": "SPRING-DATA",
    "name": "CalendarRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It injects repositories for Calendar, CalendarHistory, CalendarInstance, and related entities (Group, Loan, Client) to perform CRUD operations and fetch relationships.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Calendar",
      "CalendarHistory",
      "CalendarInstance",
      "Group",
      "Loan",
      "Client"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, findById, delete) and some custom finders (findByEntityIdAndEntityTypeIdAndCalendarTypeId).",
    "transactionHandling": "Likely managed by Spring @Transactional at the interface or service layer (not explicitly visible in this class file but implied by usage of JPA).",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.calendarRepository.saveAndFlush(newCalendar);"
  },
  {
    "path": "org.apache.fineract.portfolio.calendar.starter",
    "mechanism": "SPRING-DATA",
    "name": "Calendar Services Configuration",
    "description": "This configuration class wires up database access components. It injects a JdbcTemplate for read services (JDBC mechanism) and multiple Spring Data JPA Repositories (CalendarRepository, CalendarHistoryRepository, etc.) for write services. While this file does not execute queries directly, it constructs the services that perform READ and WRITE operations against the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Configures services that likely perform CRUD operations via JPA and reporting queries via JDBC.",
    "transactionHandling": "Transactions are likely handled by the service implementations this class configures (e.g., @Transactional on the ServiceImpl classes), not in this configuration file itself.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Bean\npublic CalendarReadPlatformService calendarReadPlatformService(JdbcTemplate jdbcTemplate, ...) {\n    return new CalendarReadPlatformServiceImpl(jdbcTemplate, ...);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.charge.domain",
    "mechanism": "SPRING-DATA",
    "name": "ChargeRepository",
    "description": "The class interacts with the database through the injected ChargeRepository, which is a Spring Data repository interface. It performs read operations to fetch Charge entities by their primary key.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Charge"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD (findById)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final Charge chargeDefinition = this.repository.findById(id).orElseThrow(() -> new ChargeNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.portfolio.charge.domain.ChargeRepository",
    "mechanism": "SPRING-DATA",
    "name": "ChargeRepository",
    "description": "This interface is a Spring Data JPA repository that manages persistence for the Charge entity. It automatically provides implementations for standard database operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic JPA Specifications.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ChargeRepository extends JpaRepository<Charge, Long>, JpaSpecificationExecutor<Charge> {\n    // no added behaviour\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.charge.service.ChargeWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "ChargeRepository, JdbcTemplate",
    "description": "The class primarily uses Spring Data JPA repositories (ChargeRepository, LoanProductRepository, etc.) for managing the lifecycle of Charge entities. However, it also heavily relies on Spring's JdbcTemplate to execute raw SQL queries for complex validation logic, specifically to check for the existence of related records in tables like 'm_loan_charge' and 'm_savings_account_charge' which might not be efficiently loaded via JPA relationships during validation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_charge",
      "m_loan_charge",
      "m_savings_account_charge",
      "m_product_loan_charge",
      "m_savings_product_charge",
      "m_gl_account",
      "m_tax_group",
      "m_payment_type"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM queries for CRUD operations; Inline SQL for existence checks and validation.",
    "transactionHandling": "Spring @Transactional annotations on public methods.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final String sql = \"select (CASE WHEN exists (select 1 from m_loan_charge lc where lc.charge_id = ? and lc.is_active = true) THEN 'true' ELSE 'false' END)\";\nfinal String isLoansUsingCharge = this.jdbcTemplate.queryForObject(sql, String.class, new Object[] { chargeId });"
  },
  {
    "path": "org.apache.fineract.portfolio.client.api",
    "mechanism": "SPRING-DATA",
    "name": "ClientRepositoryWrapper",
    "description": "The code uses a wrapper around a Spring Data repository (ClientRepositoryWrapper) to fetch Client entities from the database by their ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookup by primary key",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Client client = clientRepositoryWrapper.findOneWithNotFoundDetection(clientId);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain",
    "mechanism": "SPRING-DATA",
    "name": "ClientTransactionRepository",
    "description": "The interface extends JpaRepository, indicating it is a Spring Data JPA repository used for database persistence. It manages the ClientTransaction entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data derived queries and standard CRUD operations.",
    "transactionHandling": "Spring @Transactional (default for JpaRepository methods)",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "public interface ClientTransactionRepository extends JpaRepository<ClientTransaction, Long>, JpaSpecificationExecutor<ClientTransaction>"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain",
    "mechanism": "SPRING-DATA",
    "name": "ClientChargeRepository",
    "description": "The class interacts with the database through the ClientChargeRepository, which is a Spring Data repository interface. It performs CRUD operations on the ClientCharge entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientCharge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via Repository interface methods (findById, save, delete).",
    "transactionHandling": "Implicitly handled by the Spring Data repository implementation or the calling service context.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final ClientCharge clientCharge = this.repository.findById(id).orElseThrow(() -> new ChargeNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain",
    "mechanism": "SPRING-DATA",
    "name": "ClientRepository",
    "description": "The file is a Spring Data JPA repository interface that manages database interactions for the Client entity. It uses JPQL annotations to define custom queries involving joins and conditional logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Client",
      "Office"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with joins, projections, and parameter binding.",
    "transactionHandling": "Spring Data default transaction management",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"SELECT c.id FROM Client c WHERE c.externalId = :externalId\")"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain",
    "mechanism": "SPRING-DATA",
    "name": "ClientAddressRepository",
    "description": "The class interacts with the database through a Spring Data repository interface (ClientAddressRepository). It performs read operations to fetch ClientAddress entities based on various filtering criteria.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientAddress"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple finder methods based on entity attributes (clientId, addressType, isActive, addressId).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final ClientAddress clientAddress = this.clientAddressRepository.findByClientIdAndAddressTypeAndIsActive(clientId, addressType, isActive);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain",
    "mechanism": "SPRING-DATA",
    "name": "ClientNonPersonRepository",
    "description": "Database integration is achieved through Spring Data JPA, which maps the ClientNonPerson entity to a database table and provides repository methods.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientNonPerson"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Uses standard CRUD operations provided by JpaRepository and a custom JPQL query for lookup by foreign key.",
    "transactionHandling": "Spring Data repositories typically participate in Spring managed transactions (@Transactional).",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select clientNonPerson from ClientNonPerson clientNonPerson where clientNonPerson.client.id = :clientId\")"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.AccountNumberGenerator",
    "mechanism": "SPRING-DATA",
    "name": "Repositories (Client, Loan, SavingsAccount)",
    "description": "The class uses Spring Data repositories to check for account number conflicts when random number generation is enabled. It queries the database to ensure a generated random number is not already assigned to an existing entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "client",
      "loan",
      "savings_account"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookups by account number to check existence.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Client client = this.clientRepository.getClientByAccountNumber(accountNumber);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientAddressRepository",
    "mechanism": "SPRING-DATA",
    "name": "ClientAddressRepository",
    "description": "The file uses Spring Data JPA repositories to interact with the database. It extends JpaRepository to provide standard data access methods and defines custom JPQL queries for specific lookups.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientAddress"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with parameter binding",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"SELECT clientAddress FROM ClientAddress clientAddress WHERE clientAddress.client.id = :clientId...\")"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientChargeRepository",
    "mechanism": "SPRING-DATA",
    "name": "ClientChargeRepository",
    "description": "This interface is a Spring Data JPA repository that manages persistence for the ClientCharge entity. It inherits standard database operations from JpaRepository.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientCharge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data infrastructure.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "public interface ClientChargeRepository extends JpaRepository<ClientCharge, Long>, JpaSpecificationExecutor<ClientCharge> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientFamilyMembersRepository",
    "mechanism": "SPRING-DATA",
    "name": "ClientFamilyMembersRepository",
    "description": "Database integration is achieved through Spring Data JPA, which automatically generates SQL queries based on the interface definition and inherited methods. It manages the lifecycle of the ClientFamilyMembers entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientFamilyMembers"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by JpaRepository and JpaSpecificationExecutor.",
    "transactionHandling": "Spring @Transactional (default behavior for Spring Data Repositories)",
    "protocol": "JPA",
    "connectionInfo": "configured externally",
    "codeExample": "public interface ClientFamilyMembersRepository\n        extends JpaRepository<ClientFamilyMembers, Long>, JpaSpecificationExecutor<ClientFamilyMembers> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientIdentifierRepository",
    "mechanism": "SPRING-DATA",
    "name": "ClientIdentifierRepository",
    "description": "The interface is a Spring Data JPA repository, which automatically generates SQL queries and handles database connections based on the method names and inherited interfaces.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientIdentifier"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD and Specification-based dynamic queries provided by Spring Data JPA.",
    "transactionHandling": "Spring Data repositories are transactional by default (read-only for find methods, read-write for others).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ClientIdentifierRepository extends JpaRepository<ClientIdentifier, Long>, JpaSpecificationExecutor<ClientIdentifier> {\n    // no behaviour\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientNonPersonRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "ClientNonPersonRepository",
    "description": "The class interacts with the database via a Spring Data repository interface (ClientNonPersonRepository). It performs standard CRUD operations (findById, findByClientId, save, delete) on the 'ClientNonPerson' entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientNonPerson"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and find-by-field queries.",
    "transactionHandling": "Likely relies on Spring's @Transactional at the service layer or default repository transactionality.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return this.repository.findById(id).orElseThrow(() -> new ClientNonPersonNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "ClientRepository",
    "description": "The class wraps a Spring Data repository (ClientRepository) to perform database operations. It uses standard JPA/Spring Data patterns for finding, saving, and deleting entities, while adding a layer of exception handling.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Client"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via Spring Data JPA, plus specific lookups by account number and hierarchy.",
    "transactionHandling": "Spring @Transactional annotations are used, specifically @Transactional(readOnly = true) for retrieval methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Client client = this.repository.findById(clientId).orElseThrow(() -> new ClientNotFoundException(clientId));"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientTransactionRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "ClientTransactionRepository",
    "description": "The class interacts with the database through a Spring Data repository interface (ClientTransactionRepository). It performs standard CRUD operations (save, delete, findById) on the ClientTransaction entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final ClientTransaction clientTransaction = this.repository.findById(transactionId)\n        .orElseThrow(() -> new ClientTransactionNotFoundException(clientId, transactionId));"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientTransferDetailsRepository",
    "mechanism": "SPRING-DATA",
    "name": "ClientTransferDetailsRepository",
    "description": "Database integration is achieved through Spring Data JPA, which abstracts the underlying JDBC/Hibernate interactions. The repository interface allows the application to interact with the 'ClientTransferDetails' table (or mapped entity) using object-oriented methods.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientTransferDetails"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data.",
    "transactionHandling": "Spring Data JPA repositories are transactional by default (read-only for find methods, read-write for save/delete).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ClientTransferDetailsRepository\n        extends JpaRepository<ClientTransferDetails, Long>, JpaSpecificationExecutor<ClientTransferDetails> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.ClientTransferDetailsRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "ClientTransferDetailsRepository",
    "description": "The class interacts with the database through a Spring Data repository interface (ClientTransferDetailsRepository). It delegates persistence operations (specifically 'save') to this repository, which abstracts the underlying SQL or JPA operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientTransferDetails"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Simple CRUD operation (save)",
    "transactionHandling": "Delegated to Repository/Spring Data default transaction management",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.save(clientTransferDetails);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.domain.search.SearchingClientRepository",
    "mechanism": "SPRING-DATA",
    "name": "SearchingClientRepository",
    "description": "This interface is part of the Data Access Layer using Spring Data conventions. It defines a custom search operation that will interact with the underlying database to retrieve client records.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SearchedClient"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Search query with text matching and hierarchy filtering",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Page<SearchedClient> searchByText(String searchText, Pageable pageable, String officeHierarchy);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service",
    "mechanism": "SPRING-DATA",
    "name": "Client Charge Transaction Service",
    "description": "This interface defines the transactional boundaries for database write operations regarding client charges. While it does not contain the actual data access code, the use of @Transactional annotations mandates that the implementing class will interact with the database within a transaction context to ensure data integrity during add, update, delete, and state-change operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Transactional write operations (CRUD and state transitions)",
    "transactionHandling": "Spring @Transactional annotations on all methods",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\nCommandProcessingResult addCharge(Long clientId, JsonCommand command);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service",
    "mechanism": "SPRING-DATA",
    "name": "ClientIdentifierRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It injects `ClientIdentifierRepository` (likely extending JpaRepository) to perform CRUD operations on `ClientIdentifier` entities. It also uses `ClientRepositoryWrapper` and `CodeValueRepositoryWrapper` for related data lookups.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientIdentifier",
      "Client",
      "CodeValue"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save, findById, delete) and entity relationship lookups.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.clientIdentifierRepository.saveAndFlush(clientIdentifier);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service",
    "mechanism": "SPRING-DATA",
    "name": "ClientTransactionRepositoryWrapper",
    "description": "The class interacts with the database using repository wrappers (likely wrapping Spring Data JPA repositories) to fetch and persist domain entities. It performs read operations to retrieve Client and ClientTransaction entities, and write operations to update the transaction status and associated charges.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Client",
      "ClientTransaction",
      "ClientCharge",
      "ClientChargePaidBy"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via repository wrappers (findOneWithNotFoundDetection) and entity state transitions followed by saveAndFlush.",
    "transactionHandling": "Implicitly handled by the framework or calling context (likely Spring @Transactional at the interface level), with explicit 'saveAndFlush' calls.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.clientTransactionRepository.saveAndFlush(clientTransaction);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service.ClientChargeWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "ClientChargeRepositoryWrapper",
    "description": "The class uses Spring Data JPA repositories (wrapped in Fineract specific wrappers) to perform CRUD operations on Client, Charge, and ClientCharge entities. It handles transaction management implicitly through the service layer and explicitly calls saveAndFlush for immediate persistence.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client_charge",
      "m_client",
      "m_charge",
      "m_client_transaction",
      "m_payment_detail"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findOne, save, delete) with some custom finders for active clients.",
    "transactionHandling": "Likely handled by Spring @Transactional at the interface or aspect level, though not explicitly annotated on this class. Uses saveAndFlush suggesting immediate DB synchronization.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.clientChargeRepository.saveAndFlush(clientCharge);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service.ClientFamilyMembersWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "ClientFamilyMembersRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It injects ClientFamilyMembersRepository and CodeValueRepository to perform CRUD operations. It uses methods like saveAndFlush, getReferenceById, and delete.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientFamilyMembers",
      "Client",
      "CodeValue"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations using JPA repository methods. Some lookups by ID.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.clientFamilyRepository.saveAndFlush(clientFamilyMembers);"
  },
  {
    "path": "org.apache.fineract.portfolio.client.service.search",
    "mechanism": "SPRING-DATA",
    "name": "ClientRepository",
    "description": "The service uses a Spring Data repository (ClientRepository) to perform database searches. It relies on the repository's abstraction to execute a query that filters clients by text and office hierarchy.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Client"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Search query with text filtering, hierarchy scoping, and pagination.",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "clientRepository.searchByText(searchText, pageable, hierarchy).map(clientSearchDataMapper::map);"
  },
  {
    "path": "org.apache.fineract.portfolio.collateral.domain.LoanCollateralRepository",
    "mechanism": "SPRING-DATA",
    "name": "LoanCollateralRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access operations and JpaSpecificationExecutor for criteria-based querying.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanCollateral"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Method name derivation (findBy...) and standard CRUD operations provided by JpaRepository.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository default implementation)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "LoanCollateral findByLoanIdAndId(Long loanId, Long id);"
  },
  {
    "path": "org.apache.fineract.portfolio.collateral.service",
    "mechanism": "SPRING-DATA",
    "name": "LoanCollateralRepository, CodeValueRepositoryWrapper",
    "description": "The class interacts with the database to retrieve existing LoanCollateral entities by ID and CodeValue entities by ID. It uses Spring Data repositories (or wrappers around them) to perform these read operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_collateral",
      "m_code_value"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD operations (findById)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final LoanCollateral loanCollateralItem = this.loanCollateralRepository.findById(id)\n        .orElseThrow(() -> new CollateralNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.portfolio.collateral.service.CollateralWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "LoanCollateralRepository",
    "description": "The class interacts with the database using Spring Data JPA repositories (LoanCollateralRepository) and wrapper classes (LoanRepositoryWrapper, CodeValueRepositoryWrapper). It performs transactional CRUD operations on LoanCollateral entities and retrieves related Loan and CodeValue entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanCollateral",
      "Loan",
      "CodeValue"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations using repository methods like findOne, saveAndFlush, and delete.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.collateralRepository.saveAndFlush(collateral);"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.domain",
    "mechanism": "SPRING-DATA",
    "name": "ClientCollateralManagementRepository",
    "description": "The file uses Spring Data JPA repositories to abstract database interactions. It extends JpaRepository to provide standard data access methods and defines custom JPQL queries for specific lookups.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientCollateralManagement"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations",
    "transactionHandling": "Spring Data repositories typically participate in Spring @Transactional contexts",
    "protocol": "JPA/JDBC",
    "connectionInfo": "configured externally",
    "codeExample": "@Query(\"select clientCollateral from ClientCollateralManagement clientCollateral where clientCollateral.client=:client\")"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.domain",
    "mechanism": "SPRING-DATA",
    "name": "ClientCollateralManagementRepository",
    "description": "The class interacts with the database via Spring Data JPA repositories (ClientCollateralManagementRepository, ClientRepositoryWrapper, LoanProductRepository). It performs standard CRUD operations and relational lookups.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientCollateralManagement",
      "Client",
      "LoanProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findById, save, deleteById) and derived query methods (findByClientId).",
    "transactionHandling": "Implicitly handled by Spring Data repositories or the calling service context (no explicit @Transactional on this class).",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "this.clientCollateralManagementRepository.findByClientId(client);"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.domain.CollateralManagementDomainRepository",
    "mechanism": "SPRING-DATA",
    "name": "CollateralManagementDomainRepository",
    "description": "The file defines a Spring Data JPA repository interface, which abstracts the interaction with the underlying relational database for the CollateralManagementDomain entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CollateralManagementDomain"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (save, findById, delete) and dynamic queries via Specifications.",
    "transactionHandling": "Transactions are handled implicitly by the Spring Data JPA implementation, typically with read-only transactions for retrieval and read-write transactions for modifications.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface CollateralManagementDomainRepository\n        extends JpaRepository<CollateralManagementDomain, Long>, JpaSpecificationExecutor<CollateralManagementDomain> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.domain.CollateralManagementRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "CollateralManagementDomainRepository",
    "description": "The class uses a Spring Data repository (inferred from method names like saveAndFlush, findById, deleteById) to interact with the database. It performs CRUD operations on the CollateralManagementDomain entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CollateralManagementDomain"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via Spring Data JPA methods (saveAndFlush, findById, findAll, deleteById).",
    "transactionHandling": "Likely handled by the underlying Spring Data repository or service layer transaction management (not explicitly visible in this wrapper).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return this.collateralManagementDomainRepository.saveAndFlush(collateralData);"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.service",
    "mechanism": "SPRING-DATA",
    "name": "LoanCollateralAssembler",
    "description": "The class uses Spring Data repositories and wrapper services to interact with the database. It fetches 'ClientCollateralManagement' entities to check availability and 'LoanCollateralManagement' entities to check existing state. It modifies the state of these managed entities (updating quantities), which are then persisted by the JPA context.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientCollateralManagement",
      "LoanCollateralManagement"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findById, getCollateral) and entity state updates.",
    "transactionHandling": "Implicitly relies on the transaction context of the caller (likely Spring @Transactional on the service layer invoking this assembler).",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "LoanCollateralManagement loanCollateralManagement = this.loanCollateralRepository.findById(id)\n        .orElseThrow(() -> new LoanCollateralManagementNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.service",
    "mechanism": "SPRING-DATA",
    "name": "CollateralManagementRepositoryWrapper",
    "description": "The class interacts with the database indirectly through the `CollateralManagementRepositoryWrapper`. This wrapper likely encapsulates a Spring Data JPA repository or similar persistence mechanism to fetch `CollateralManagementDomain` entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CollateralManagementDomain"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD read operations (findById, findAll)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final CollateralManagementDomain collateralManagementDomain = this.collateralManagementRepositoryWrapper.getCollateral(collateralId);"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.service",
    "mechanism": "SPRING-DATA",
    "name": "LoanCollateralManagementRepository, ClientCollateralManagementRepositoryWrapper",
    "description": "The class interacts with the database using Spring Data JPA repositories. It performs read operations to fetch entities, update operations to modify collateral quantities, and delete operations to remove loan collateral records.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanCollateralManagement",
      "ClientCollateralManagement"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (findById, saveAndFlush, deleteById) via JPA repositories.",
    "transactionHandling": "Spring @Transactional annotation on the delete method.",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "final LoanCollateralManagement loanCollateralManagement = this.loanCollateralManagementRepository.findById(id).orElseThrow();"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.service",
    "mechanism": "SPRING-DATA",
    "name": "LoanTransactionRepository",
    "description": "The class interacts with the database primarily through Spring Data repositories (LoanTransactionRepository) and a wrapper around another repository (ClientCollateralManagementRepositoryWrapper). It performs read operations to fetch entities by ID or by client association.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientCollateralManagement",
      "LoanTransaction",
      "LoanCollateralManagement"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD read operations and traversal of JPA entity relationships.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "LoanTransaction loanTransaction = this.loanTransactionRepository.findById(transactionId)\n        .orElseThrow(() -> new LoanTransactionNotFoundException(transactionId));"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.service",
    "mechanism": "SPRING-DATA",
    "name": "ClientCollateralManagementRepositoryWrapper",
    "description": "The class uses Repository Wrappers (likely wrapping Spring Data JPA repositories) to interact with the database. It performs CRUD operations on ClientCollateralManagement entities and fetches related Client and CollateralManagementDomain entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientCollateralManagement",
      "Client",
      "CollateralManagementDomain",
      "LoanCollateralManagement"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via repository abstraction. Some logic involves traversing sets (LoanCollateralManagementSet) which implies lazy or eager loading of related entities.",
    "transactionHandling": "Spring @Transactional annotations on public methods",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.clientCollateralManagementRepositoryWrapper.saveAndFlush(clientCollateralManagement);"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.service.CollateralManagementWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "CollateralManagementRepositoryWrapper",
    "description": "The class uses a Repository Wrapper pattern (likely wrapping Spring Data JPA repositories) to interact with the database. It performs CRUD operations on CollateralManagementDomain and ApplicationCurrency entities. Transactions are managed via Spring's @Transactional annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "CollateralManagementDomain",
      "ApplicationCurrency",
      "ClientCollateralManagement"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (create, findOne, update, delete) via repository abstraction.",
    "transactionHandling": "Spring @Transactional annotations on class and methods",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final CollateralManagementDomain collateral = CollateralManagementDomain.createNew(jsonCommand, applicationCurrency);\nthis.collateralManagementRepositoryWrapper.create(collateral);"
  },
  {
    "path": "org.apache.fineract.portfolio.collateralmanagement.service.LoanCollateralManagementReadPlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository, LoanCollateralManagementRepository",
    "description": "The class uses Spring Data JPA repositories to perform read-only operations on the database. It accesses `Loan` and `LoanCollateralManagement` entities via `findById` and `findByLoan` methods.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan",
      "LoanCollateralManagement"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookups by ID and association traversal.",
    "transactionHandling": "Spring @Transactional(readOnly = true) annotation on the class level.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "Loan loan = this.loanRepository.findById(loanId).orElseThrow(() -> new LoanNotFoundException(loanId));"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.domain",
    "mechanism": "SPRING-DATA",
    "name": "DelinquencyBucketMappingsRepository",
    "description": "Database integration is achieved through Spring Data JPA. The interface extends JpaRepository, which acts as a proxy to the underlying EntityManager, handling database interactions for the DelinquencyBucketMappings entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DelinquencyBucketMappings"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and a specific select query filtering by a foreign key association.",
    "transactionHandling": "Transactions are handled by the Spring container, typically with read-only transactions for retrieval methods and read-write for state-changing methods inherited from JpaRepository.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface DelinquencyBucketMappingsRepository extends JpaRepository<DelinquencyBucketMappings, Long> ..."
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.domain.DelinquencyBucketRepository",
    "mechanism": "SPRING-DATA",
    "name": "DelinquencyBucketRepository",
    "description": "Database integration is achieved through Spring Data JPA repositories. The interface inherits standard CRUD operations (save, findById, delete, etc.) from JpaRepository and dynamic query capabilities from JpaSpecificationExecutor.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DelinquencyBucket"
    ],
    "operationType": [
      "READ",
      "WRITE",
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data derived queries (findByName) and standard CRUD operations provided by JpaRepository.",
    "transactionHandling": "Spring @Transactional (default behavior for JpaRepository methods)",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface DelinquencyBucketRepository extends JpaRepository<DelinquencyBucket, Long> { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.domain.DelinquencyRangeRepository",
    "mechanism": "SPRING-DATA",
    "name": "DelinquencyRangeRepository",
    "description": "The interface uses Spring Data JPA to interact with the database. It maps the DelinquencyRange entity to a database table and provides methods for data manipulation and retrieval without writing explicit SQL.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DelinquencyRange"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and a specific property-based lookup (findByClassification).",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface DelinquencyRangeRepository extends JpaRepository<DelinquencyRange, Long> {\n    Optional<DelinquencyRange> findByClassification(String classification);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.domain.LoanDelinquencyTagHistoryRepository",
    "mechanism": "SPRING-DATA",
    "name": "LoanDelinquencyTagHistoryRepository",
    "description": "The interface extends JpaRepository, indicating it uses Spring Data JPA for database interactions. It maps the LoanDelinquencyTagHistory entity to a database table and provides methods to perform CRUD operations and custom queries without writing explicit SQL.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanDelinquencyTagHistory"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data JPA derived query methods (findBy..., countBy...)",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface LoanDelinquencyTagHistoryRepository\n        extends JpaRepository<LoanDelinquencyTagHistory, Long>, JpaSpecificationExecutor<LoanDelinquencyTagHistory> {\n    LoanDelinquencyTagHistory findFirstByLoanOrderByAddedOnDateDesc(Loan loan);"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.service.DelinquencyReadPlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "Delinquency and Loan Repositories",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs read operations on DelinquencyRange, DelinquencyBucket, LoanDelinquencyTagHistory, and Loan entities. It uses standard JPA methods like findAll, getReferenceById, and custom query methods defined in the repository interfaces (e.g., findByLoanAndLiftedOnDate).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DelinquencyRange",
      "DelinquencyBucket",
      "LoanDelinquencyTagHistory",
      "Loan",
      "LoanTransaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard CRUD reads and specific finder methods (findByLoan...) provided by Spring Data JPA.",
    "transactionHandling": "Spring @Transactional(readOnly = true) annotation at the class level.",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final List<DelinquencyRange> delinquencyRangeList = repositoryRange.findAll();"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.service.DelinquencyWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "Delinquency Repositories",
    "description": "The class uses multiple Spring Data JPA repositories to interact with the database. It performs CRUD operations on DelinquencyRange, DelinquencyBucket, and LoanDelinquencyTagHistory entities. It also uses `saveAndFlush` for immediate persistence.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DelinquencyRange",
      "DelinquencyBucket",
      "DelinquencyBucketMappings",
      "LoanDelinquencyTagHistory",
      "Loan",
      "LoanProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, delete, findById, countBy...) and some custom finders like `findByClassification` or `findByLoan`.",
    "transactionHandling": "Likely Spring @Transactional (implied by service layer usage in Fineract), plus explicit `saveAndFlush` calls.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "DelinquencyRange newDelinquencyRange = DelinquencyRange.instance(data.getClassification(), ...);\nreturn repositoryRange.saveAndFlush(newDelinquencyRange);"
  },
  {
    "path": "org.apache.fineract.portfolio.delinquency.starter.DelinquencyConfiguration",
    "mechanism": "SPRING-DATA",
    "name": "Delinquency Repositories",
    "description": "This configuration class wires up Spring Data repositories (e.g., DelinquencyRangeRepository, LoanRepository) into the service beans. While this specific file does not execute queries, it is the integration point that enables database access for the Delinquency module by injecting the persistence layer components.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DelinquencyRange",
      "DelinquencyBucket",
      "DelinquencyBucketMappings",
      "LoanDelinquencyTagHistory",
      "Loan",
      "LoanProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Repository injection for CRUD operations",
    "transactionHandling": "Delegated to the service implementations (likely Spring @Transactional)",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "public DelinquencyReadPlatformService delinquencyReadPlatformService(DelinquencyRangeRepository repositoryRange, ...) {\n    return new DelinquencyReadPlatformServiceImpl(repositoryRange, ...);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.floatingrates.domain",
    "mechanism": "SPRING-DATA",
    "name": "FloatingRateRepository",
    "description": "The class interacts with the database through an injected Spring Data repository interface (FloatingRateRepository). It performs standard CRUD operations (save, findById) and custom queries defined in the repository.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FloatingRate"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and ID-based lookups.",
    "transactionHandling": "Transaction management is likely handled by the underlying Spring Data repository implementation or the calling service layer.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return this.floatingRateRepository.findById(id).orElseThrow(() -> new FloatingRateNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.portfolio.floatingrates.domain",
    "mechanism": "SPRING-DATA",
    "name": "FloatingRateRepository",
    "description": "The file uses Spring Data JPA to abstract database interactions. It extends `JpaRepository` to provide standard data access methods and defines custom queries using JPQL annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FloatingRate",
      "FloatingRatePeriod"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "JPQL queries with inner joins and boolean logic filters.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select floatingRate from FloatingRate floatingRate where floatingRate.isBaseLendingRate = true...\")"
  },
  {
    "path": "org.apache.fineract.portfolio.floatingrates.serialization.FloatingRateDataValidator",
    "mechanism": "SPRING-DATA",
    "name": "FloatingRateRepository",
    "description": "The class uses `FloatingRateRepository` to perform read-only checks against the database during validation. It verifies if a Base Lending Rate already exists and checks for dependencies when modifying a Base Lending Rate.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FloatingRate"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookups to check existence of entities based on boolean flags (isBaseLendingRate) and relationships.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "FloatingRate baseLendingRate = this.floatingRateRepository.retrieveBaseLendingRate();"
  },
  {
    "path": "org.apache.fineract.portfolio.floatingrates.service.FloatingRateWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "FloatingRateRepositoryWrapper",
    "description": "The class uses a repository wrapper (FloatingRateRepositoryWrapper) to interact with the database. This wrapper likely delegates to a Spring Data JPA repository for standard CRUD operations on the FloatingRate entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FloatingRate"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (saveAndFlush, findOneWithNotFoundDetection, save) via repository abstraction.",
    "transactionHandling": "Transactions are managed using Spring's @Transactional annotation on the service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.floatingRateRepository.saveAndFlush(newFloatingRate);"
  },
  {
    "path": "org.apache.fineract.portfolio.fund.domain",
    "mechanism": "SPRING-DATA",
    "name": "FundRepository",
    "description": "The interface is a Spring Data JPA repository that manages the persistence of the Fund entity without requiring boilerplate JDBC code.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Fund"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and dynamic queries via JpaSpecificationExecutor.",
    "transactionHandling": "Spring Data JPA repositories are transactional by default (read-only for find methods, read-write for others).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface FundRepository extends JpaRepository<Fund, Long>, JpaSpecificationExecutor<Fund> {\n    // no added behaviour\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.fund.service",
    "mechanism": "SPRING-DATA",
    "name": "FundRepository",
    "description": "The class uses a Spring Data JPA repository (`FundRepository`) to perform CRUD operations on the `Fund` entity. It relies on `saveAndFlush` for persistence and `findById` for retrieval.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Fund"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations using JPA Repository methods.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.fundRepository.saveAndFlush(fund);"
  },
  {
    "path": "org.apache.fineract.portfolio.group.domain",
    "mechanism": "SPRING-DATA",
    "name": "GroupRoleRepository",
    "description": "The class interacts with the database via the GroupRoleRepository, which is likely a Spring Data JPA repository interface. It performs standard CRUD operations on the GroupRole entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GroupRole"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "Spring Data default transaction handling",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public GroupRole findOneWithNotFoundDetection(final Long id) {\n    return this.repository.findById(id).orElseThrow(() -> new GroupRoleNotFoundException(id));\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.group.domain",
    "mechanism": "SPRING-DATA",
    "name": "GroupRepository",
    "description": "The class wraps a Spring Data repository interface (GroupRepository) to perform database operations on Group entities. It delegates standard CRUD operations and custom queries to this repository.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Group"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and one specific date retrieval query.",
    "transactionHandling": "Delegated to the underlying repository or the calling service context (Spring @Transactional is not present on this wrapper).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public Group findOneWithNotFoundDetection(final Long id) {\n    return this.repository.findById(id).orElseThrow(() -> new GroupNotFoundException(id));\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.group.domain",
    "mechanism": "SPRING-DATA",
    "name": "GroupRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends `JpaRepository` for standard operations and uses `@Query` for custom JPQL execution.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Group"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Includes standard CRUD operations inherited from JpaRepository, a derived finder method for parent-child relationships, and a custom JPQL projection query.",
    "transactionHandling": "Spring Data Repositories are transactional by default (read-only for finders, read-write for others).",
    "protocol": "JPA/JDBC",
    "connectionInfo": "configured in application properties",
    "codeExample": "@Query(RETRIEVE_SUBMITTED_ON_DATE)\nLocalDate retrieveGroupTypeSubmitteOndDate(@Param(\"groupId\") Long groupId);"
  },
  {
    "path": "org.apache.fineract.portfolio.group.domain.GroupLevelRepository",
    "mechanism": "SPRING-DATA",
    "name": "GroupLevelRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to inherit standard CRUD operations and defines custom finders that are translated into SQL by the framework.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GroupLevel"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data derived queries (simple CRUD and property-based lookups)",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "GroupLevel findBySuperParent(boolean superParent);"
  },
  {
    "path": "org.apache.fineract.portfolio.group.domain.GroupRoleRepository",
    "mechanism": "SPRING-DATA",
    "name": "GroupRoleRepository",
    "description": "The interface extends JpaRepository, indicating it is a Spring Data repository used for database persistence of the GroupRole entity. It allows for standard CRUD operations and dynamic specification-based queries against the underlying database table mapped to the GroupRole entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GroupRole"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and dynamic criteria-based queries provided by JpaSpecificationExecutor.",
    "transactionHandling": "Spring Data JPA repositories are transactional by default (read-only for retrieval, read-write for modifications).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface GroupRoleRepository extends JpaRepository<GroupRole, Long>, JpaSpecificationExecutor<GroupRole> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.group.handler",
    "mechanism": "SPRING-DATA",
    "name": "GroupingTypesWritePlatformService",
    "description": "The class manages database transactions using Spring's @Transactional annotation while delegating the actual persistence logic to a service component.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GROUP",
      "CLIENT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(final JsonCommand command) {\n    return this.writePlatformService.associateClientsToGroup(command.entityId(), command);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.group.serialization.GroupingTypesDataValidator",
    "mechanism": "SPRING-DATA",
    "name": "GroupRepositoryWrapper",
    "description": "The validator uses the GroupRepositoryWrapper to retrieve existing data from the database to perform logical validation against current state (specifically dates).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_group"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple retrieval by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "LocalDate submittedOnDate = this.groupRepositoryWrapper.retrieveSubmittedOndate(centerId);"
  },
  {
    "path": "org.apache.fineract.portfolio.group.service",
    "mechanism": "SPRING-DATA",
    "name": "GroupRoleRepositoryWrapper",
    "description": "The class uses Spring Data JPA repositories (wrapped in custom wrapper classes) to interact with the database. It performs CRUD operations on GroupRole, Group, Client, and CodeValue entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GroupRole",
      "Group",
      "Client",
      "CodeValue"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via JPA repositories (findOne, saveAndFlush, delete).",
    "transactionHandling": "Implicitly handled by Spring Data or Service layer (saveAndFlush implies immediate persistence).",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final GroupRole groupRole = GroupRole.createGroupRole(group, client, role);\nthis.groupRoleRepository.saveAndFlush(groupRole);"
  },
  {
    "path": "org.apache.fineract.portfolio.group.service.GroupingTypesWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "GroupRepositoryWrapper",
    "description": "The class uses multiple Repository Wrappers (which wrap Spring Data JPA repositories) to perform CRUD operations on entities like Group, Client, Office, and Staff. It uses `saveAndFlush` for immediate persistence and `findOneWithNotFoundDetection` for retrieval with error handling.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Group",
      "Client",
      "Office",
      "Staff",
      "Note",
      "GroupLevel",
      "Loan",
      "CodeValue",
      "CalendarInstance",
      "SavingsAccount",
      "AccountNumberFormat"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "Standard JPA CRUD operations with some custom finders (e.g., findByOfficeHierarchyWithNotFoundDetection).",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.groupRepository.saveAndFlush(newGroup);"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.domain",
    "mechanism": "SPRING-DATA",
    "name": "InterestRateChartSlabRepository",
    "description": "The class wraps a Spring Data repository interface (InterestRateChartSlabRepository) to perform standard CRUD operations on the InterestRateChartSlab entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "InterestRateChartSlab"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findById, save, delete) provided by Spring Data JPA.",
    "transactionHandling": "Transactions are likely handled by the underlying Spring Data repository implementation or the service layer invoking this wrapper.",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "return this.repository.findById(chartSlabId).orElseThrow(() -> new InterestRateChartSlabNotFoundException(chartSlabId));"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.domain",
    "mechanism": "SPRING-DATA",
    "name": "InterestRateChartRepository",
    "description": "The class wraps a Spring Data repository interface to perform CRUD operations on the InterestRateChart entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "InterestRateChart"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations delegated to Spring Data JPA repository.",
    "transactionHandling": "Spring Data repositories typically handle transactions by default, though no explicit @Transactional annotation is present on this wrapper.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return this.repository.findById(intrestRateChartId).orElseThrow(() -> new InterestRateChartNotFoundException(intrestRateChartId));"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.domain.InterestRateChartRepository",
    "mechanism": "SPRING-DATA",
    "name": "InterestRateChartRepository",
    "description": "Database integration is achieved through Spring Data JPA, which automatically generates SQL queries based on the method signatures and inherited interfaces. The repository manages the persistence lifecycle of the InterestRateChart entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "InterestRateChart"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by the framework.",
    "transactionHandling": "Spring @Transactional (implicitly handled by the Spring Data JPA implementation)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface InterestRateChartRepository extends JpaRepository<InterestRateChart, Long>, JpaSpecificationExecutor<InterestRateChart> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.domain.InterestRateChartSlabRepository",
    "mechanism": "SPRING-DATA",
    "name": "InterestRateChartSlabRepository",
    "description": "Database integration is achieved through Spring Data JPA, which automatically implements the repository interface to interact with the database using Hibernate/JPA under the hood.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "InterestRateChartSlab"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by the framework.",
    "transactionHandling": "Spring @Transactional (default for JpaRepository methods)",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "public interface InterestRateChartSlabRepository\n        extends JpaRepository<InterestRateChartSlab, Long>, JpaSpecificationExecutor<InterestRateChartSlab> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.service",
    "mechanism": "SPRING-DATA",
    "name": "InterestRateChartSlabRepository",
    "description": "The class uses a Spring Data JPA repository (InterestRateChartSlabRepository) to perform CRUD operations on the InterestRateChartSlab entity. Transactions are managed using the @Transactional annotation on methods.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "InterestRateChartSlab"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, delete) are used without explicit custom queries.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.chartSlabRepository.saveAndFlush(interestRateChartSlab);"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.service",
    "mechanism": "SPRING-DATA",
    "name": "InterestRateChartRepositoryWrapper",
    "description": "The class uses a repository wrapper (likely wrapping a Spring Data JPA repository) to fetch existing InterestRateChart entities from the database by ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "InterestRateChart"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookup by primary key (ID).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final InterestRateChart interestRateChart = this.interestRateChartRepositoryWrapper\n        .findOneWithNotFoundDetection(interestRateChartId);"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.service",
    "mechanism": "SPRING-DATA",
    "name": "InterestRateChartRepositoryWrapper",
    "description": "The class interacts with the database through `InterestRateChartRepositoryWrapper`, which wraps a Spring Data JPA repository. It performs CRUD operations on `InterestRateChart` entities within transactional boundaries managed by Spring.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "InterestRateChart"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations (save, findOne, delete) via repository abstraction.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.interestRateChartRepository.saveAndFlush(interestRateChart);"
  },
  {
    "path": "org.apache.fineract.portfolio.interestratechart.service.InterestRateChartSlabAssembler",
    "mechanism": "SPRING-DATA",
    "name": "InterestRateChartRepositoryWrapper",
    "description": "The class uses a repository wrapper to fetch parent 'InterestRateChart' entities from the database. This is necessary to associate new slabs with existing charts and to validate that the parent chart exists.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "InterestRateChart"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookup by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final InterestRateChart chart = this.interestRateChartRepositoryWrapper.findOneWithNotFoundDetection(chartId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.api.InternalLoanInformationApiResource",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepositoryWrapper / LoanTransactionRepository",
    "description": "The class interacts with the database using Spring Data repositories (or wrappers around them). It retrieves Loan and LoanTransaction entities by ID and queries for loan IDs based on status.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan",
      "LoanTransaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD read operations (findById) and one custom query to find IDs by status.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Loan loan = loanRepositoryWrapper.findOneWithNotFoundDetection(loanId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "GLIMAccountInfoRepository",
    "description": "The interface extends JpaRepository, enabling automatic ORM mapping and SQL generation for the GroupLoanIndividualMonitoringAccount entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GroupLoanIndividualMonitoringAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data derived query methods (findBy...) and standard CRUD operations inherited from JpaRepository.",
    "transactionHandling": "Spring Data JPA repositories are transactional by default (read-only for read methods, read-write for others).",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface GLIMAccountInfoRepository\n        extends JpaRepository<GroupLoanIndividualMonitoringAccount, Long>..."
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "LoanTransactionRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database using JPA entities and JPQL queries. It extends JpaRepository to inherit standard CRUD operations and defines custom queries using the @Query annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanTransaction",
      "LoanCharge",
      "Loan"
    ],
    "operationType": [
      "READ",
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with constructor expressions (projections), aggregations (SUM, MIN), grouping (GROUP BY), and standard CRUD operations.",
    "transactionHandling": "Spring Data JPA repositories typically participate in existing transactions or create read-only transactions for query methods.",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"SELECT lt.id FROM LoanTransaction lt WHERE lt.externalId = :externalId\")\nLong findIdByExternalId(@Param(\"externalId\") ExternalId externalId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "LoanChargePaidByRepository",
    "description": "The file uses Spring Data JPA repositories to interact with the database. It extends JpaRepository to provide standard CRUD operations and defines a custom JPQL query to filter records.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanChargePaidBy",
      "LoanCharge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data)",
    "protocol": "JPA",
    "connectionInfo": "configured in application context",
    "codeExample": "@Query(\"select lp from LoanChargePaidBy lp where lp.loanCharge=:loanCharge and lp.installmentNumber=:installmentNumber\")"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "LoanChargeRepository",
    "description": "The interface extends JpaRepository to provide data access for the LoanCharge entity. It uses Spring Data JPA to automatically generate SQL for standard operations and executes a custom JPQL query for ID lookup.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanCharge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via JpaRepository inheritance and one custom JPQL query for ID retrieval.",
    "transactionHandling": "Spring @Transactional (default for Spring Data repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(FIND_ID_BY_EXTERNAL_ID)\nLong findIdByExternalId(@Param(\"externalId\") ExternalId externalId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "LoanCollateralManagementRepository",
    "description": "The code uses Spring Data JPA repositories to interact with the database. It extends JpaRepository to provide standard data access methods and defines a custom JPQL query for specific retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanCollateralManagement"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM queries using JPQL",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select loanCollaterals from LoanCollateralManagement loanCollaterals where loanCollaterals.loan=:loan\")\nList<LoanCollateralManagement> findByLoan(@Param(\"loan\") Loan loan);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepaymentScheduleInstallmentRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access methods and defines custom JPQL queries for specific reporting needs.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanRepaymentScheduleInstallment",
      "Loan",
      "LoanProduct"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "Spring @Transactional (implied by Spring Data)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"\"\"\n            SELECT new org.apache.fineract.portfolio.loanaccount.data.LoanScheduleDelinquencyData(\n                lrs.loan.id,\n                min(lrs.dueDate),\n                0L,\n                lrs.loan\n            ) FROM LoanRepaymentScheduleInstallment lrs...\"\"\")"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository",
    "description": "The class wraps a Spring Data JPA repository (LoanRepository) to perform CRUD operations and custom queries on the Loan entity. It handles transaction management and lazy loading of related entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD, complex joins via lazy loading initialization, batch operations, and custom repository queries.",
    "transactionHandling": "Spring @Transactional annotations are used on the class and specific methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Loan loan = this.repository.findById(id).orElseThrow(() -> new LoanNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanDisbursementDetailsRepository",
    "mechanism": "SPRING-DATA",
    "name": "LoanDisbursementDetailsRepository",
    "description": "The file is a Spring Data JPA repository interface. It automatically provides database interaction capabilities for the LoanDisbursementDetails entity without explicit implementation code.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanDisbursementDetails"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data JPA.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface LoanDisbursementDetailsRepository\n        extends JpaRepository<LoanDisbursementDetails, Long>, JpaSpecificationExecutor<LoanDisbursementDetails> {}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanRepository",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database primarily through JPQL queries defined in @Query annotations and standard Spring Data method naming conventions. It manages the 'Loan' entity and related data.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan",
      "LoanAccountLock"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The repository uses extensive JPQL queries. These include simple selects, filtering by multiple criteria (dates, IDs, statuses), aggregations (MAX, COUNT), subqueries (for finding oldest dates), and joins (implicit in path navigation like l.group.id and explicit in the lock query). It also uses constructor expressions (new ...) to return DTOs.",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select loan from Loan loan where loan.client.id = :clientId\")\nList<Loan> findLoanByClientId(@Param(\"clientId\") Long clientId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanTransactionRelationRepository",
    "mechanism": "SPRING-DATA",
    "name": "LoanTransactionRelationRepository",
    "description": "The interface extends JpaRepository, enabling Spring Data to generate the implementation for database access at runtime. It maps the LoanTransactionRelation entity to a database table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanTransactionRelation"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD and derived query methods based on property names.",
    "transactionHandling": "Spring @Transactional (default for JpaRepository methods)",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "public interface LoanTransactionRelationRepository extends JpaRepository<LoanTransactionRelation, Long> ..."
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.domain.LoanTransactionToRepaymentScheduleMappingRepository",
    "mechanism": "SPRING-DATA",
    "name": "LoanTransactionToRepaymentScheduleMappingRepository",
    "description": "The interface uses Spring Data JPA to interact with the database. It maps the 'LoanTransactionToRepaymentScheduleMapping' Java entity to a corresponding database table and provides object-relational mapping capabilities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanTransactionToRepaymentScheduleMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data JPA derived queries and standard CRUD operations.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "LoanTransactionToRepaymentScheduleMapping findByLoanTransaction(LoanTransaction loanTransaction);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.guarantor.domain",
    "mechanism": "SPRING-DATA",
    "name": "GuarantorFundingTransactionRepository",
    "description": "The code uses Spring Data JPA to interact with the database. It extends JpaRepository to inherit standard data access methods and defines a custom JPQL query for specific retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GuarantorFundingTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations and standard CRUD operations.",
    "transactionHandling": "Spring @Transactional annotations (implicit in JpaRepository implementation)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select ft from GuarantorFundingTransaction ft where ft.loanTransaction.id in :loanTransactions\")"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.guarantor.domain",
    "mechanism": "SPRING-DATA",
    "name": "GuarantorRepository",
    "description": "The interface extends JpaRepository to provide automated database interactions via Hibernate/JPA.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Guarantor"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD and derived query methods based on entity relationships.",
    "transactionHandling": "Spring @Transactional (default for JpaRepository methods)",
    "protocol": "JPA",
    "connectionInfo": "configured in application properties",
    "codeExample": "public interface GuarantorRepository extends JpaRepository<Guarantor, Long>, JpaSpecificationExecutor<Guarantor> { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.guarantor.domain.GuarantorFundingRepository",
    "mechanism": "SPRING-DATA",
    "name": "GuarantorFundingRepository",
    "description": "The interface utilizes Spring Data JPA to automatically generate the implementation for database access based on the GuarantorFundingDetails entity. It provides standard CRUD operations and specification execution capabilities without requiring explicit SQL or JPQL in this file.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GuarantorFundingDetails"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and dynamic criteria queries provided by JpaSpecificationExecutor.",
    "transactionHandling": "Spring Data repositories are transactional by default (read-only for find methods, read-write for save/delete).",
    "protocol": "JDBC (abstracted by JPA)",
    "connectionInfo": "unknown",
    "codeExample": "public interface GuarantorFundingRepository\n        extends JpaRepository<GuarantorFundingDetails, Long>, JpaSpecificationExecutor<GuarantorFundingDetails> {}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.guarantor.service.GuarantorDomainServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "Guarantor/Loan Repositories",
    "description": "The service uses Spring Data JPA repositories to interact with the database. It retrieves and saves entities related to guarantors, loans, and savings account transactions.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_guarantor",
      "m_guarantor_funding_details",
      "m_guarantor_transaction",
      "m_deposit_account_on_hold_transaction",
      "m_loan",
      "m_savings_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository finders (e.g., findByLoan) and save/flush operations.",
    "transactionHandling": "Likely relies on Spring's @Transactional at the service level (though not explicitly annotated on this class, it is common in this architecture) or repository-level transactions.",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "final List<Guarantor> existGuarantorList = this.guarantorRepository.findByLoan(loan);\n// ...\nthis.depositAccountOnHoldTransactionRepository.saveAndFlush(onHoldTransaction);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.jobs.applyholidaystoloans",
    "mechanism": "SPRING-DATA",
    "name": "HolidayRepositoryWrapper, LoanRepositoryWrapper",
    "description": "The class uses repository wrappers (likely abstractions over Spring Data JPA repositories) to fetch and persist domain entities. It retrieves `Holiday` entities to find unprocessed ones and `Loan` entities based on office IDs and status. It performs write operations to update the loan repayment schedules and the holiday processing status.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_holiday",
      "m_loan",
      "m_loan_repayment_schedule"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Repository finder methods (findUnprocessed, findByClientOfficeIdsAndLoanStatus) and save methods.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final List<Holiday> holidays = holidayRepository.findUnprocessed();\n// ...\nloans.addAll(loanRepositoryWrapper.findByClientOfficeIdsAndLoanStatus(officeIds, loanStatuses));\n// ...\nloanRepositoryWrapper.save(loans);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.jobs.setloandelinquencytags",
    "mechanism": "SPRING-DATA",
    "name": "Loan Repositories",
    "description": "The class injects Spring Data repositories (LoanRepaymentScheduleInstallmentRepository and LoanTransactionRepository) and passes them to the tasklet. While this configuration class does not execute queries directly, it wires the components that perform database operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_repayment_schedule",
      "m_loan_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Repository methods used within the tasklet for batch processing.",
    "transactionHandling": "Spring Batch Step transaction management via PlatformTransactionManager",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "private LoanRepaymentScheduleInstallmentRepository loanRepaymentScheduleInstallmentRepository;\nprivate LoanTransactionRepository loanTransactionRepository;\n\n@Bean\npublic SetLoanDelinquencyTagsTasklet setLoanDelinquencyTagsTasklet() {\n    return new SetLoanDelinquencyTagsTasklet(delinquencyWritePlatformService, loanRepaymentScheduleInstallmentRepository,\n            loanTransactionRepository);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.jobs.setloandelinquencytags",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepaymentScheduleInstallmentRepository, LoanTransactionRepository",
    "description": "The class uses Spring Data repositories to query the database for loans with specific transaction types and overdue schedules. It also delegates to a service that likely performs database updates (writes) to apply tags.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_transaction",
      "m_loan_repayment_schedule",
      "m_loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code uses custom repository methods to fetch data based on complex criteria (transaction type, date, loan status, obligations met).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "loanScheduleDelinquencyData = this.loanTransactionRepository\n        .fetchLoanTransactionsByTypeAndLessOrEqualDate(LoanTransactionType.CHARGEBACK.getValue(), businessDate);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.loanschedule.domain.LoanRepaymentScheduleHistoryRepository",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepaymentScheduleHistoryRepository",
    "description": "The interface uses Spring Data JPA to manage database interactions for LoanRepaymentScheduleHistory entities. It abstracts the underlying SQL or JPQL generation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanRepaymentScheduleHistory"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data.",
    "transactionHandling": "Spring Data repositories are transactional by default (read-only for read methods, read-write for others).",
    "protocol": "JPA/JDBC",
    "connectionInfo": "configured in application properties",
    "codeExample": "public interface LoanRepaymentScheduleHistoryRepository\n        extends JpaRepository<LoanRepaymentScheduleHistory, Long>, JpaSpecificationExecutor<LoanRepaymentScheduleHistory> {\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.loanschedule.service.LoanScheduleAssembler",
    "mechanism": "SPRING-DATA",
    "name": "LoanProductRepository, CalendarRepository, etc.",
    "description": "The class uses multiple Spring Data repositories to fetch domain entities required for assembling the loan schedule. It retrieves LoanProduct, Calendar, Holiday, Client, Group, and WorkingDays entities by their IDs or other attributes.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_product_loan",
      "m_currency",
      "m_calendar",
      "m_holiday",
      "m_client",
      "m_group",
      "m_working_days",
      "m_calendar_instance"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard JPA findById and findOne lookups.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final LoanProduct loanProduct = this.loanProductRepository.findById(loanProductId)\n        .orElseThrow(() -> new LoanProductNotFoundException(loanProductId));"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.loanschedule.service.LoanScheduleCalculationPlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "LoanProductRepository",
    "description": "The class uses Spring Data repositories to access loan product information and JPA entities (via LoanAssembler) to access Loan data. It performs read operations to fetch configuration and state required for schedule calculation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_product_loan",
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard JPA repository findById calls and entity traversal.",
    "transactionHandling": "Spring @Transactional annotations on the class and methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final LoanProduct loanProduct = this.loanProductRepository.findById(productId)\n        .orElseThrow(() -> new LoanProductNotFoundException(productId));"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.loanschedule.service.LoanScheduleHistoryWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepaymentScheduleHistoryRepository",
    "description": "The class uses a Spring Data repository (`LoanRepaymentScheduleHistoryRepository`) to perform batch insert operations (`saveAll`) for the history records. It also uses a read service (`LoanScheduleHistoryReadPlatformService`) which likely executes SQL/JDBC queries to fetch version numbers and old audit dates.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanRepaymentScheduleHistory",
      "LoanRepaymentScheduleInstallment"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Batch inserts via repository and specific lookups for versioning and audit data.",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.loanRepaymentScheduleHistoryRepository.saveAll(loanRepaymentScheduleHistoryList);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.rescheduleloan.domain",
    "mechanism": "SPRING-DATA",
    "name": "LoanRescheduleRequestRepository",
    "description": "The file is a Spring Data JPA repository interface. It automatically generates SQL queries based on method names and annotations to interact with the underlying relational database for the `LoanRescheduleRequest` entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanRescheduleRequest"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository, plus a custom JPQL projection query.",
    "transactionHandling": "Spring Data JPA repositories typically participate in existing Spring @Transactional contexts.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select lrr.loan.id from LoanRescheduleRequest lrr where lrr.id = :rescheduleRequestId\")"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.rescheduleloan.domain",
    "mechanism": "SPRING-DATA",
    "name": "LoanRescheduleRequestRepository",
    "description": "The class uses a Spring Data repository interface to interact with the database. It performs read operations to fetch LoanRescheduleRequest entities by their primary key.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanRescheduleRequest"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD (findById)",
    "transactionHandling": "Spring @Transactional(readOnly = true)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.loanRescheduleRequestRepository.findById(id)\n        .orElseThrow(() -> new LoanRescheduleRequestNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.rescheduleloan.domain.LoanTermVariationsRepository",
    "mechanism": "SPRING-DATA",
    "name": "LoanTermVariationsRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access methods and defines a custom JPQL query for specific retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanTermVariations"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations and standard CRUD operations provided by JpaRepository.",
    "transactionHandling": "Transactions are likely handled by the Spring container via @Transactional annotations at the service layer, or default read-only transactions for repository methods.",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select lrr from LoanTermVariations lrr where lrr.loan.id = :loanId\")"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.rescheduleloan.handler",
    "mechanism": "SPRING-DATA",
    "name": "LoanRescheduleRequestWritePlatformService",
    "description": "The class manages database transactions via the Spring @Transactional annotation while delegating the actual data persistence logic to the LoanRescheduleRequestWritePlatformService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegated to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n@Override\npublic CommandProcessingResult processCommand(JsonCommand jsonCommand) {\n    return this.loanRescheduleRequestWritePlatformService.reject(jsonCommand);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.rescheduleloan.service",
    "mechanism": "SPRING-DATA",
    "name": "LoanRescheduleRequestRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs CRUD operations on LoanRescheduleRequest, Loan, and LoanRepaymentScheduleHistory entities. It uses @Transactional to ensure atomicity of complex operations involving multiple tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_reschedule_request",
      "m_loan",
      "m_loan_repayment_schedule",
      "m_loan_repayment_schedule_history",
      "m_loan_transaction",
      "m_loan_term_variations",
      "m_loan_reschedule_request_term_variation_mapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, findById, saveAndFlush) and navigation through entity relationships.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.loanRescheduleRequestRepository.saveAndFlush(loanRescheduleRequest);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.rescheduleloan.service.LoanReschedulePreviewPlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "LoanRescheduleRequestRepositoryWrapper",
    "description": "The class uses a repository wrapper to fetch LoanRescheduleRequest entities from the database. It relies on the underlying JPA/Spring Data infrastructure to retrieve the request and its associated Loan entity and mappings.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan_reschedule_request",
      "m_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Entity lookup by ID with eager loading of associations (implied by findOneWithNotFoundDetection)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final LoanRescheduleRequest loanRescheduleRequest = this.loanRescheduleRequestRepository.findOneWithNotFoundDetection(requestId, true);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.serialization.LoanApplicationCommandFromApiJsonHelper",
    "mechanism": "SPRING-DATA",
    "name": "ClientCollateralManagementRepositoryWrapper",
    "description": "The class uses a repository wrapper to fetch client collateral details from the database during validation. This is used to verify that the collateral exists and to retrieve its quantity and value for business rule checks.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientCollateralManagement"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookup by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final ClientCollateralManagement clientCollateralManagement = this.clientCollateralManagementRepositoryWrapper.getCollateral(clientCollateralId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.serialization.LoanEventApiJsonValidator",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository",
    "description": "The class uses `LoanRepository` to fetch `Loan` entities by ID. This is primarily used in `validateDisbursementWithPostDatedChecks` to retrieve the loan's repayment schedule and validate that the provided post-dated checks correspond to valid installments.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_loan_repayment_schedule"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookup by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Loan loan = this.loanRepository.findById(loanId).orElseThrow(() -> new LoanNotFoundException(loanId));"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service",
    "mechanism": "SPRING-DATA",
    "name": "LoanTransactionRepository",
    "description": "The service uses a Spring Data repository to retrieve existing loan transaction entities by their primary key ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanTransaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD (findById)",
    "transactionHandling": "unknown",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "LoanTransaction oldTransaction = loanTransactionRepository.findById(mapEntry.getKey())\n        .orElseThrow(() -> new LoanTransactionNotFoundException(mapEntry.getKey()));"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service",
    "mechanism": "SPRING-DATA",
    "name": "ChargeRepositoryWrapper, LoanChargeRepository, LoanProductRepository",
    "description": "The class uses Spring Data repositories to fetch entity definitions required for assembly. It retrieves `Charge` definitions to understand calculation rules and `LoanProduct` definitions to check configuration flags like multi-disbursement support. It also retrieves existing `LoanCharge` entities by ID for updates.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_charge",
      "m_loan_charge",
      "m_product_loan"
    ],
    "operationType": [
      "READ",
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA findById lookups.",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final LoanProduct loanProduct = this.loanProductRepository.findById(productId)\n        .orElseThrow(() -> new LoanProductNotFoundException(productId));\nfinal Charge chargeDefinition = this.chargeRepository.findOneWithNotFoundDetection(chargeId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service",
    "mechanism": "SPRING-DATA",
    "name": "GLIMAccountInfoRepository",
    "description": "The class uses Spring Data repositories (`GLIMAccountInfoRepository` and `LoanRepository`) to interact with the database. It performs write operations (save/update) on `GroupLoanIndividualMonitoringAccount` entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GroupLoanIndividualMonitoringAccount"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save/update) via repository methods.",
    "transactionHandling": "Implicitly handled by Spring Data repository methods or upper layers (no explicit @Transactional in this file).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.glimAccountRepository.save(glimAccountInfo);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service.LoanAssembler",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepositoryWrapper, LoanProductRepository, ClientRepositoryWrapper, etc.",
    "description": "The class uses multiple repository wrappers and standard Spring Data repositories to fetch domain entities required to assemble a Loan. It primarily performs read operations to look up Clients, Groups, Products, Funds, and Staff.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_product_loan",
      "m_client",
      "m_group",
      "m_fund",
      "m_staff",
      "m_code_value",
      "m_holiday",
      "m_working_days"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard JPA findById or findOne lookups.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Loan loanAccount = this.loanRepository.findOneWithNotFoundDetection(accountId, true);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service.LoanChargeWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepositoryWrapper, ChargeRepositoryWrapper, LoanChargeRepository",
    "description": "The class uses Spring Data JPA repositories (wrapped in service wrappers) to interact with the database. It performs CRUD operations on Loan, LoanCharge, and LoanTransaction entities. It uses @Transactional to ensure data consistency across multiple repository calls.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_loan",
      "m_loan_charge",
      "m_loan_transaction",
      "m_charge",
      "m_note",
      "m_payment_detail",
      "m_account_transfer_details"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findById, save, saveAndFlush) and domain entity traversals (lazy loading of collections).",
    "transactionHandling": "Spring @Transactional annotations on the class and methods.",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.loanRepositoryWrapper.save(loan);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanaccount.service.LoanUtilService",
    "mechanism": "SPRING-DATA",
    "name": "RepositoryWrappers",
    "description": "The class interacts with the database through several injected repository wrappers (e.g., `ApplicationCurrencyRepositoryWrapper`, `CalendarInstanceRepository`, `HolidayRepository`). These are used to retrieve entity information such as currency details, calendar instances associated with loans, and holiday configurations required for schedule generation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_currency",
      "m_calendar_instance",
      "m_calendar",
      "m_holiday",
      "m_working_days"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookups by ID or associated entity ID.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "ApplicationCurrency applicationCurrency = this.applicationCurrencyRepository.findOneWithNotFoundDetection(currency);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.domain",
    "mechanism": "SPRING-DATA",
    "name": "LoanProductRepository",
    "description": "The file is a Spring Data JPA repository interface. It provides database interaction capabilities for the LoanProduct entity without requiring boilerplate JDBC code. It supports automatic transaction management and query generation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LoanProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "Spring @Transactional",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select loanProduct from LoanProduct loanProduct, IN(loanProduct.charges) charge where charge.id = :chargeId\")"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.productmix.domain",
    "mechanism": "SPRING-DATA",
    "name": "ProductMixRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, which provides standard CRUD operations, and by defining custom JPQL queries via the @Query annotation to access the 'ProductMix' entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProductMix"
    ],
    "operationType": [
      "READ",
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "@Query(GET_PRODUCTMIXES_BY_PRODUCTID_SCHEMA)\nList<ProductMix> findByProductId(@Param(\"productId\") Long productId);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.productmix.service.ProductMixWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "ProductMixRepository",
    "description": "The class uses Spring Data JPA repositories (`ProductMixRepository` and `LoanProductRepository`) to interact with the database. It performs CRUD operations on `ProductMix` and `LoanProduct` entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ProductMix",
      "LoanProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard Spring Data JPA repository methods (saveAll, deleteAll, findById, findByProductId).",
    "transactionHandling": "Spring @Transactional annotations on the class and methods.",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "this.productMixRepository.saveAll(productMixes);"
  },
  {
    "path": "org.apache.fineract.portfolio.loanproduct.service",
    "mechanism": "SPRING-DATA",
    "name": "LoanProductRepository",
    "description": "The class uses Spring Data JPA repositories (LoanProductRepository, FundRepository, etc.) to interact with the database. It performs CRUD operations on LoanProduct entities and related tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_product_loan",
      "m_fund",
      "m_charge",
      "m_rate",
      "m_floating_rates",
      "m_delinquency_bucket"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findById, saveAndFlush, getReferenceById) and some custom wrapper calls.",
    "transactionHandling": "Spring @Transactional annotations on public methods",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.loanProductRepository.saveAndFlush(loanProduct);"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.attendance.domain.ClientAttendanceRepository",
    "mechanism": "SPRING-DATA",
    "name": "ClientAttendanceRepository",
    "description": "The interface uses Spring Data JPA to automatically generate the implementation for database access at runtime. It maps the ClientAttendance entity to a database table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ClientAttendance"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data.",
    "transactionHandling": "Spring @Transactional (implicitly handled by the Spring Data repository implementation)",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "public interface ClientAttendanceRepository extends JpaRepository<ClientAttendance, Long>, JpaSpecificationExecutor<ClientAttendance> {}"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.domain.MeetingRepository",
    "mechanism": "SPRING-DATA",
    "name": "MeetingRepository",
    "description": "The file uses Spring Data JPA to manage database interactions. It extends JpaRepository to provide standard CRUD functionality and defines a custom finder method that is automatically translated into a database query by the framework.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Meeting"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "Meeting findByCalendarInstanceIdAndMeetingDate(Long calendarInstanceId, LocalDate meetingDate);"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.domain.MeetingRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "MeetingRepository",
    "description": "The class wraps a Spring Data repository (MeetingRepository) to perform CRUD operations on the Meeting entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Meeting"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via Spring Data JPA methods (findById, save, delete).",
    "transactionHandling": "Likely handled by the underlying Spring Data repository implementation (SimpleJpaRepository is @Transactional by default).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public Meeting findOneWithNotFoundDetection(final Long meetingId) {\n    return this.repository.findById(meetingId).orElseThrow(() -> new MeetingNotFoundException(meetingId));\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.service.MeetingWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "MeetingRepositoryWrapper",
    "description": "The class uses Spring Data JPA repositories (wrapped in Fineract's RepositoryWrapper pattern) to perform CRUD operations on Meeting entities and read-only operations on related entities like Calendar, Client, and Group.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_meeting",
      "m_calendar_instance",
      "m_calendar",
      "m_client",
      "m_group",
      "m_meeting_attendance"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, delete, findById) and some custom finders (findByCalendarIdAndEntityIdAndEntityTypeId).",
    "transactionHandling": "Implicitly handled by the Spring Data repositories or the service layer context (though @Transactional is not explicitly present on this class, it is likely present on the interface or inherited).",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.meetingRepositoryWrapper.saveAndFlush(newMeeting);"
  },
  {
    "path": "org.apache.fineract.portfolio.meeting.starter",
    "mechanism": "SPRING-DATA",
    "name": "Meeting Services Configuration",
    "description": "This configuration class wires up services that interact with the database using both JDBC (for reads) and Spring Data JPA Repositories (for writes). It injects the JdbcTemplate and various Repository interfaces into the service implementations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The configured services likely perform raw SQL queries via JdbcTemplate for reads and ORM-based CRUD operations via JPA repositories for writes.",
    "transactionHandling": "Transaction handling is likely managed within the service implementations (e.g., @Transactional), not in this configuration class.",
    "protocol": "JDBC / JPA",
    "connectionInfo": "configured in application properties",
    "codeExample": "public MeetingReadPlatformService meetingReadPlatformService(JdbcTemplate jdbcTemplate) {\n    return new MeetingReadPlatformServiceImpl(jdbcTemplate);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.note.domain.NoteRepository",
    "mechanism": "SPRING-DATA",
    "name": "NoteRepository",
    "description": "The interface extends JpaRepository and JpaSpecificationExecutor, leveraging Spring Data JPA to manage database interactions. It automatically generates SQL queries based on method names (e.g., findByClient) and provides built-in methods for standard CRUD operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Note"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data derived queries based on method names (e.g., findByLoanId, findByClient).",
    "transactionHandling": "Spring Data JPA repositories typically use @Transactional implicitly on their methods (read-only for finders, read-write for save/delete).",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "public interface NoteRepository extends JpaRepository<Note, Long> ... {\n    List<Note> findByClient(Client id);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.note.service.NoteWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "NoteRepository",
    "description": "The class uses multiple Spring Data JPA repositories (NoteRepository, ClientRepositoryWrapper, GroupRepository, etc.) to interact with the database. It performs CRUD operations on Note entities and read operations on parent entities (Client, Group, Loan, etc.) to establish relationships.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Note",
      "Client",
      "Group",
      "Loan",
      "LoanTransaction",
      "SavingsAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations using JPA repository methods like save, saveAndFlush, delete, findById, and findOneWithNotFoundDetection.",
    "transactionHandling": "Likely managed by Spring @Transactional at the class or interface level (though not explicitly visible in this file snippet, it is standard for such services).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final Note newNote = Note.clientNoteFromJson(client, command);\nthis.noteRepository.saveAndFlush(newNote);"
  },
  {
    "path": "org.apache.fineract.portfolio.note.starter.NoteAutoConfiguration",
    "mechanism": "SPRING-DATA",
    "name": "NoteAutoConfiguration",
    "description": "This configuration class wires up database access components. It injects a JdbcTemplate for the read service (indicating direct JDBC usage) and multiple Spring Data repositories (NoteRepository, GroupRepository, etc.) for the write service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_note",
      "m_client",
      "m_group",
      "m_loan",
      "m_loan_transaction",
      "m_savings_account"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The read service likely uses raw SQL via JdbcTemplate, while the write service uses JPA/Hibernate via Spring Data Repositories.",
    "transactionHandling": "Transactions are likely handled within the service implementations (NoteWritePlatformServiceJpaRepositoryImpl) rather than this configuration class.",
    "protocol": "unknown",
    "connectionInfo": "configured via Spring Boot DataSource",
    "codeExample": "@Bean\npublic NoteReadPlatformService noteReadPlatformService(JdbcTemplate jdbcTemplate) {\n    return new NoteReadPlatformServiceImpl(jdbcTemplate);\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.paymentdetail.domain",
    "mechanism": "SPRING-DATA",
    "name": "PaymentDetailRepository",
    "description": "Database integration is handled via Spring Data JPA. The interface inherits methods for saving, deleting, and finding PaymentDetail entities. It also inherits the ability to execute JPA Specifications, specifically typed for Loan entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PaymentDetail",
      "Loan"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository and dynamic criteria queries via JpaSpecificationExecutor.",
    "transactionHandling": "Spring Data repositories typically use @Transactional(readOnly = true) for read methods and @Transactional for write methods by default.",
    "protocol": "JPA",
    "connectionInfo": "configured in application properties",
    "codeExample": "public interface PaymentDetailRepository extends JpaRepository<PaymentDetail, Long>, JpaSpecificationExecutor<Loan> {\n    // no added behaviour\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.paymentdetail.domain",
    "mechanism": "SPRING-DATA",
    "name": "PaymentTypeRepositoryWrapper",
    "description": "The class uses a repository wrapper (likely wrapping a Spring Data JPA repository) to fetch PaymentType entities from the database by their ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PaymentType"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookup by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final PaymentType paymentType = this.repositoryWrapper.findOneWithNotFoundDetection(paymentTypeId);"
  },
  {
    "path": "org.apache.fineract.portfolio.paymentdetail.service",
    "mechanism": "SPRING-DATA",
    "name": "PaymentDetailRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It injects PaymentDetailRepository to save payment details and PaymentTypeRepositoryWrapper to read payment types.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PaymentDetail",
      "PaymentType"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save, findOne)",
    "transactionHandling": "Spring @Transactional annotations on persist methods",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.paymentDetailRepository.save(paymentDetail);"
  },
  {
    "path": "org.apache.fineract.portfolio.paymenttype.api",
    "mechanism": "SPRING-DATA",
    "name": "PaymentTypeRepositoryWrapper",
    "description": "The class interacts with the database indirectly through the 'PaymentTypeRepositoryWrapper' for entity existence checks and 'PaymentTypeReadPlatformService' for data retrieval. The wrapper likely encapsulates a Spring Data JPA repository.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PaymentType"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "Simple CRUD operations delegated to services.",
    "transactionHandling": "Delegated to underlying services (likely Spring @Transactional in the service layer)",
    "protocol": "unknown",
    "codeExample": "this.paymentTypeRepositoryWrapper.findOneWithNotFoundDetection(paymentTypeId);"
  },
  {
    "path": "org.apache.fineract.portfolio.paymenttype.domain",
    "mechanism": "SPRING-DATA",
    "name": "PaymentTypeRepository",
    "description": "The class uses a Spring Data JPA repository interface to interact with the database. It relies on method name query derivation (e.g., findAllByOrderByPositionAsc) to generate SQL queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PaymentType"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD operations with ordering and null checks.",
    "transactionHandling": "Spring @Transactional (likely inherited from repository or service layer)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.repository.findAllByOrderByPositionAsc()"
  },
  {
    "path": "org.apache.fineract.portfolio.paymenttype.domain.PaymentTypeRepository",
    "mechanism": "SPRING-DATA",
    "name": "PaymentTypeRepository",
    "description": "The file uses Spring Data JPA to abstract database interactions. By extending JpaRepository, it gains full CRUD capabilities on the PaymentType entity. It defines specific read operations using method naming conventions that Spring translates into SQL queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PaymentType"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data JPA derived queries for filtering and sorting",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface PaymentTypeRepository extends JpaRepository<PaymentType, Long>, JpaSpecificationExecutor<PaymentType> {\n    List<PaymentType> findAllByOrderByPositionAsc();\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.paymenttype.service",
    "mechanism": "SPRING-DATA",
    "name": "PaymentTypeRepositoryWrapper",
    "description": "The class interacts with the database through a wrapper around a Spring Data repository (implied by the naming convention and usage). It performs read-only operations to fetch PaymentType entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PaymentType"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD operations (findAll, findOne)",
    "transactionHandling": "None (Read-only operations, likely handled at repository level)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "List<PaymentType> paymentType = this.paymentTypeRepository.findAll();"
  },
  {
    "path": "org.apache.fineract.portfolio.paymenttype.service.PaymentTypeWriteServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "PaymentTypeRepository",
    "description": "The class uses a Spring Data JPA repository (`PaymentTypeRepository`) to interact with the database. It performs CRUD operations on the `PaymentType` entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PaymentType"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via JPA repository methods (save, delete, find).",
    "transactionHandling": "Implicitly handled by Spring Data repository methods or the service context (though @Transactional is not explicitly on this class, saveAndFlush implies immediate persistence).",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "this.repository.saveAndFlush(newPaymentType);"
  },
  {
    "path": "org.apache.fineract.portfolio.rate.domain",
    "mechanism": "SPRING-DATA",
    "name": "RateRepository",
    "description": "The class interacts with the database through the RateRepository interface, which is a Spring Data repository. It performs read operations to fetch Rate entities by primary key.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Rate"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD operations (findById, findAllById) provided by Spring Data.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Rate rate = this.repository.findById(rateId).orElseThrow(() -> new RateNotFoundException(rateId));"
  },
  {
    "path": "org.apache.fineract.portfolio.rate.domain",
    "mechanism": "SPRING-DATA",
    "name": "RateRepository",
    "description": "The interface extends JpaRepository, indicating it uses Spring Data JPA for database persistence. The Javadoc explicitly mentions saving to the 'm_rate' table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_rate"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data JPA derived queries (findBy...) and standard CRUD operations inherited from JpaRepository.",
    "transactionHandling": "Spring @Transactional (default for JpaRepository methods)",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "public interface RateRepository extends JpaRepository<Rate, Long>, JpaSpecificationExecutor<Rate> { ... }"
  },
  {
    "path": "org.apache.fineract.portfolio.rate.service",
    "mechanism": "SPRING-DATA",
    "name": "RateRepository",
    "description": "The class uses Spring Data JPA repositories (RateRepository and AppUserRepository) to interact with the database. It performs CRUD operations and relies on JPA for object-relational mapping.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Rate",
      "AppUser"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations using repository methods like saveAndFlush and findById.",
    "transactionHandling": "Spring @Transactional annotation is used on the updateRate method; createRate relies on repository transaction management.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.rateRepository.saveAndFlush(rate);"
  },
  {
    "path": "org.apache.fineract.portfolio.rate.service.RateAssembler",
    "mechanism": "SPRING-DATA",
    "name": "RateRepositoryWrapper",
    "description": "The class interacts with the database through the RateRepositoryWrapper. It does not execute SQL directly but relies on the repository pattern to fetch entities based on a list of primary keys (IDs).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Rate"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Batch retrieval by ID list",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "rateItems.addAll(rateRepository.findMultipleWithNotFoundDetection(idList));"
  },
  {
    "path": "org.apache.fineract.portfolio.repaymentwithpostdatedchecks.domain",
    "mechanism": "SPRING-DATA",
    "name": "PostDatedChecksRepository",
    "description": "The file is a Spring Data JPA repository interface that manages database interactions for the PostDatedChecks entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PostDatedChecks",
      "LoanRepaymentScheduleInstallment"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with dynamic criteria defined via annotations.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select pdc from PostDatedChecks pdc where pdc.status = 0 and pdc.loanRepaymentScheduleInstallment = :loanRepaymentScheduleInstallment\")"
  },
  {
    "path": "org.apache.fineract.portfolio.repaymentwithpostdatedchecks.service",
    "mechanism": "SPRING-DATA",
    "name": "PostDatedChecksRepository, LoanRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs CRUD operations on PostDatedChecks and read operations on Loan entities. Transaction management is handled via the @Transactional annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PostDatedChecks",
      "Loan",
      "LoanRepaymentScheduleInstallment"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findById, saveAndFlush, deleteById) and entity navigation.",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.postDatedChecksRepository.saveAndFlush(postDatedChecks);"
  },
  {
    "path": "org.apache.fineract.portfolio.repaymentwithpostdatedchecks.service",
    "mechanism": "SPRING-DATA",
    "name": "LoanRepository, PostDatedChecksRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It retrieves `Loan` and `PostDatedChecks` entities using standard `findById` methods and object graph navigation (e.g., `loan.getPostDatedChecks()`). The class is transactional with read-only propagation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Loan",
      "PostDatedChecks",
      "LoanRepaymentScheduleInstallment"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard CRUD find by ID and object traversal",
    "transactionHandling": "Spring @Transactional(readOnly = true)",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Loan loan = this.loanRepository.findById(id).orElseThrow(() -> new LoanNotFoundException(id));"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "GSIMRepositoy",
    "description": "The interface extends JpaRepository, which provides full database integration via Hibernate/JPA. It maps the GroupSavingsIndividualMonitoring entity to a database table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GroupSavingsIndividualMonitoring"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard Spring Data JPA derived queries (Simple CRUD)",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "JPA",
    "connectionInfo": "configured in application.properties",
    "codeExample": "GroupSavingsIndividualMonitoring findOneByAccountNumber(String accountNumber);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountChargeRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access methods and defines custom JPQL queries for specific business requirements.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SavingsAccountCharge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with custom filtering logic (WHERE clauses) and ordering.",
    "transactionHandling": "Spring Data default transaction management (likely read-only for query methods unless overridden).",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select sac from SavingsAccountCharge sac where sac.id =:id and sac.savingsAccount.id = :savingsAccountId\")"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "ChargeRepositoryWrapper, SavingsAccountChargeRepository",
    "description": "The class uses Spring Data repositories to retrieve 'Charge' definitions and existing 'SavingsAccountCharge' entities. It performs read operations to fetch data required for assembly and validation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_charge",
      "m_savings_account_charge"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard JPA repository find by ID methods.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Charge chargeDefinition = this.chargeRepository.findOneWithNotFoundDetection(chargeId);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountRepository",
    "description": "The class interacts with the database primarily through Spring Data JPA repositories (SavingsAccountRepository and SavingsAccountTransactionRepository). It performs standard CRUD operations, custom finders (e.g., by client ID, status), and transaction management using @Transactional annotations. A JdbcTemplate is injected but not explicitly used in the visible public methods.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SavingsAccount",
      "SavingsAccountTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods including findById, save, delete, and custom finders likely defined via method names or @Query annotations in the repository interfaces.",
    "transactionHandling": "Spring @Transactional annotations are used on methods, with readOnly=true specified for retrieval operations.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final SavingsAccount account = this.repository.findById(savingsId)\n        .orElseThrow(() -> new SavingsAccountNotFoundException(savingsId));"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "ChargeRepositoryWrapper, SavingsAccountChargeRepository",
    "description": "The class uses injected repository wrappers and repositories to interact with the database. It retrieves 'Charge' definitions to create new savings charges and retrieves existing 'SavingsAccountCharge' entities by ID to perform updates.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_charge",
      "m_savings_account_charge"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "Standard repository findById calls",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Charge chargeDefinition = this.chargeRepository.findOneWithNotFoundDetection(chargeId);\n// ...\nfinal SavingsAccountCharge savingsAccountCharge = this.savingsAccountChargeRepository\n        .findById(savingsAccountChargeId)\n        .orElseThrow(() -> new SavingsAccountChargeNotFoundException(savingsAccountChargeId));"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "RecurringDepositAccountRepository",
    "description": "The code utilizes Spring Data JPA to interact with the database. It defines a repository interface that extends JpaRepository, automatically providing data access methods for the RecurringDepositAccount entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RecurringDepositAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specifications via JpaSpecificationExecutor.",
    "transactionHandling": "Transactions are handled implicitly by the Spring Data JPA repository proxy (default @Transactional behavior).",
    "protocol": "JPA",
    "connectionInfo": "unknown",
    "codeExample": "public interface RecurringDepositAccountRepository\n        extends JpaRepository<RecurringDepositAccount, Long>, JpaSpecificationExecutor<RecurringDepositAccount> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "DepositAccountOnHoldTransactionRepository",
    "description": "The interface uses Spring Data JPA to abstract database interactions. It maps the DepositAccountOnHoldTransaction entity to a database table and provides methods to query and manipulate this data without writing raw SQL.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "DepositAccountOnHoldTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data JPA derived query methods (ORM)",
    "transactionHandling": "Spring Data JPA repositories are transactional by default (Spring @Transactional)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface DepositAccountOnHoldTransactionRepository extends JpaRepository<DepositAccountOnHoldTransaction, Long> ..."
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, which provides standard CRUD operations, and by defining custom JPQL queries via the @Query annotation for more complex retrieval logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SavingsAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code uses JPQL queries with named parameters. It includes simple selects, filtering by multiple columns, checking for existence (count > 0), and pessimistic locking.",
    "transactionHandling": "Spring Data repositories typically participate in existing transactions. The 'findOneLocked' method explicitly defines a PESSIMISTIC_WRITE lock mode.",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select s_acc from SavingsAccount s_acc where s_acc.client.id = :clientId\")\nList<SavingsAccount> findSavingAccountByClientId(@Param(\"clientId\") Long clientId);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "RepositoryWrappers",
    "description": "The class uses several RepositoryWrapper classes (ClientRepositoryWrapper, GroupRepositoryWrapper, SavingsAccountRepositoryWrapper, etc.) which likely wrap Spring Data JPA repositories. It uses these to fetch entities by ID to assemble the domain objects.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_client",
      "m_group",
      "m_staff",
      "m_product_loan"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Standard CRUD find operations by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "client = this.clientRepository.findOneWithNotFoundDetection(clientId, isCalendarInherited);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountChargeRepository",
    "description": "The class wraps a Spring Data repository interface (SavingsAccountChargeRepository) to perform CRUD operations and custom finders on the underlying database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SavingsAccountCharge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and specific finders by ID or pending status.",
    "transactionHandling": "Implicitly handled by the underlying Spring Data repository or the calling service context.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public SavingsAccountCharge findOneWithNotFoundDetection(final Long id) {\n    return this.repository.findById(id).orElseThrow(() -> new SavingsAccountChargeNotFoundException(id));\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountRepositoryWrapper",
    "description": "The class uses Spring Data JPA repositories (wrapped in custom wrappers) to persist SavingsAccount and SavingsAccountTransaction entities. It uses standard JPA save/saveAndFlush methods.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_savings_account_transaction",
      "m_deposit_account_on_hold_transaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and finding transactions by account.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.savingsAccountRepository.save(account);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountRepositoryWrapper",
    "description": "The class uses wrapper classes around Spring Data JPA repositories to interact with the database. It retrieves entities like SavingsProduct, Client, Group, and Staff, and loads SavingsAccount transactions.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_savings_product",
      "m_client",
      "m_group",
      "m_staff",
      "m_savings_account_transaction"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "The code primarily performs lookups by ID (findById) and fetches related transaction data. It includes logic for fetching transactions after a specific pivot date.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "final SavingsProduct product = this.savingProductRepository.findById(productId)\n        .orElseThrow(() -> new SavingsProductNotFoundException(productId));"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountTransactionRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending `JpaRepository`, which provides standard CRUD capabilities. It defines custom JPQL queries using `@Query` annotations and utilizes `@Lock` for database-level row locking (Pessimistic Write) to handle concurrency for financial transactions.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SavingsAccountTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with filtering by ID, date ranges, and boolean flags; Pessimistic locking; Pagination.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository) and explicit Pessimistic Locking.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Lock(LockModeType.PESSIMISTIC_WRITE)\n@Query(\"select st from SavingsAccountTransaction st where st.savingsAccount = :savingsAccount...\")\nList<SavingsAccountTransaction> findTransactionsAfterPivotDate(...);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.DepositProductAssembler",
    "mechanism": "SPRING-DATA",
    "name": "ChargeRepositoryWrapper, TaxGroupRepositoryWrapper",
    "description": "The class uses injected repository wrappers to retrieve existing Charge and TaxGroup entities from the database based on IDs provided in the JSON command. It performs read-only operations to link these existing entities to the new product being assembled.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_charge",
      "m_tax_group"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookup by primary key (ID).",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Long id = jsonObject.get(idParamName).getAsLong();\nfinal Charge charge = this.chargeRepository.findOneWithNotFoundDetection(id);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.FixedDepositAccountRepository",
    "mechanism": "SPRING-DATA",
    "name": "FixedDepositAccountRepository",
    "description": "Database integration is achieved through Spring Data JPA. The interface extends JpaRepository, which provides standard CRUD operations, and JpaSpecificationExecutor, which allows for dynamic querying based on JPA Specifications. The actual SQL generation and execution are handled by the Spring framework and the underlying Hibernate provider.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FixedDepositAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data infrastructure.",
    "transactionHandling": "Spring @Transactional (default behavior for Spring Data Repositories)",
    "protocol": "JPA",
    "connectionInfo": "configured in application properties (unknown from this file)",
    "codeExample": "public interface FixedDepositAccountRepository\n        extends JpaRepository<FixedDepositAccount, Long>, JpaSpecificationExecutor<FixedDepositAccount> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.FixedDepositProductRepository",
    "mechanism": "SPRING-DATA",
    "name": "FixedDepositProductRepository",
    "description": "The file uses Spring Data JPA to manage database interactions. By extending JpaRepository, it automatically gains methods for saving, deleting, and finding entities. By extending JpaSpecificationExecutor, it gains the ability to query the database using dynamic criteria (Specifications).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FixedDepositProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data Repositories)",
    "protocol": "JPA",
    "connectionInfo": "configured in application properties",
    "codeExample": "public interface FixedDepositProductRepository\n        extends JpaRepository<FixedDepositProduct, Long>, JpaSpecificationExecutor<FixedDepositProduct> {\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.RecurringDepositProductRepository",
    "mechanism": "SPRING-DATA",
    "name": "RecurringDepositProductRepository",
    "description": "The interface uses Spring Data JPA to abstract database interactions, automatically providing implementations for standard CRUD operations and specification-based queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RecurringDepositProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification queries provided by Spring Data.",
    "transactionHandling": "Spring @Transactional (default behavior for Spring Data Repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface RecurringDepositProductRepository\n        extends JpaRepository<RecurringDepositProduct, Long>, JpaSpecificationExecutor<RecurringDepositProduct> {\n    //\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.SavingsProductAssembler",
    "mechanism": "SPRING-DATA",
    "name": "ChargeRepositoryWrapper, TaxGroupRepositoryWrapper",
    "description": "The class uses injected repository wrappers (likely wrapping Spring Data JPA repositories) to look up existing 'Charge' and 'TaxGroup' entities by their primary keys during the assembly process.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Charge",
      "TaxGroup"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookups by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Charge charge = this.chargeRepository.findOneWithNotFoundDetection(id);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.domain.SavingsProductRepository",
    "mechanism": "SPRING-DATA",
    "name": "SavingsProductRepository",
    "description": "The code uses Spring Data JPA to interact with the database. By extending JpaRepository, it automatically gains methods for standard CRUD operations on the 'SavingsProduct' entity. By extending JpaSpecificationExecutor, it gains the ability to run dynamic queries based on the JPA Criteria API.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SavingsProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by Spring Data infrastructure.",
    "transactionHandling": "Spring Data repositories are transactional by default (read-only for read methods, read-write for others).",
    "protocol": "JDBC (via Hibernate/JPA)",
    "connectionInfo": "unknown",
    "codeExample": "public interface SavingsProductRepository extends JpaRepository<SavingsProduct, Long>, JpaSpecificationExecutor<SavingsProduct> {\n    //\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "SPRING-DATA",
    "name": "DepositAccountWritePlatformService",
    "description": "The class uses Spring's @Transactional annotation to manage database transactions for the activation process. While it does not execute SQL directly, it orchestrates the write operation via the injected DepositAccountWritePlatformService, ensuring the state change is committed atomically.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RECURRINGDEPOSITACCOUNT"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer for update/write operations.",
    "transactionHandling": "Spring @Transactional annotation on the processCommand method.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(final JsonCommand command) {\n        return this.depositAccountWritePlatformService.activateRDAccount(command.entityId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.handler",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountWritePlatformService",
    "description": "The class uses Spring's `@Transactional` annotation to define transaction boundaries for the database operation. The actual data access logic is delegated to the `SavingsAccountWritePlatformService`.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Delegates to service layer",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Transactional\n    @Override\n    public CommandProcessingResult processCommand(JsonCommand command) {\n        return this.writePlatformService.holdAmount(command.getSavingsId(), command);\n    }"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service",
    "mechanism": "SPRING-DATA",
    "name": "FixedDepositProductRepository",
    "description": "The class uses a Spring Data JPA repository (`FixedDepositProductRepository`) to interact with the database. It performs standard CRUD operations (save, findById, delete) on the `FixedDepositProduct` entity. Transactions are managed via the `@Transactional` annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "FixedDepositProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations using JPA Repository methods.",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.fixedDepositProductRepository.saveAndFlush(product);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service",
    "mechanism": "SPRING-DATA",
    "name": "SavingsProductRepository",
    "description": "The class uses a Spring Data JPA repository (`SavingsProductRepository`) to interact with the database. It performs CRUD operations on the `SavingsProduct` entity. Transaction management is handled via the `@Transactional` annotation on the class and methods.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SavingsProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, findById, delete) without explicit JPQL in this service.",
    "transactionHandling": "Spring @Transactional annotations on the class and methods.",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.savingProductRepository.saveAndFlush(product);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service",
    "mechanism": "SPRING-DATA",
    "name": "GSIMRepositoy",
    "description": "The class uses a Spring Data repository (GSIMRepositoy) to perform CRUD operations on the GroupSavingsIndividualMonitoring entity. The class is also annotated with @Transactional, ensuring that database operations within its methods are executed within a transaction context.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GroupSavingsIndividualMonitoring"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save/update) via repository methods.",
    "transactionHandling": "Spring @Transactional annotation on the class level.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "return this.gsimAccountRepository.save(glimAccountInfo);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.RecurringDepositProductWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "RecurringDepositProductRepository",
    "description": "The class uses a Spring Data JPA repository (RecurringDepositProductRepository) to interact with the database. It performs standard CRUD operations (saveAndFlush, findById, delete) on the RecurringDepositProduct entity. Transaction management is handled via the @Transactional annotation.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "RecurringDepositProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository CRUD operations.",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.recurringDepositProductRepository.saveAndFlush(product);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.SavingsAccountWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountRepositoryWrapper",
    "description": "The class uses Spring Data JPA repositories (wrapped in custom wrappers like `SavingsAccountRepositoryWrapper`) to interact with the database. It performs CRUD operations on `SavingsAccount`, `SavingsAccountTransaction`, `SavingsAccountCharge`, and other related entities. It uses `@Transactional` to ensure data consistency across multiple repository calls.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_savings_account_transaction",
      "m_savings_account_charge",
      "m_note",
      "gsim_accounts",
      "m_payment_detail",
      "m_account_transfer_standing_instruction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, findById, saveAndFlush) with some custom finders (e.g., findByGsimId, findBySavingsAccountIdAndLessThanDateOfAndReversedIsFalse).",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.savingAccountRepositoryWrapper.saveAndFlush(account);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.SavingsApplicationProcessWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountRepositoryWrapper",
    "description": "The class uses Spring Data JPA repositories (wrapped in custom wrappers) to interact with the database. It performs CRUD operations on SavingsAccount, Client, Group, and Note entities. It also handles transaction management using @Transactional annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_savings_account",
      "m_client",
      "m_group",
      "m_product_savings",
      "m_note",
      "gsim_accounts",
      "m_staff"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, findOne, delete) with some custom finders for GSIM accounts.",
    "transactionHandling": "Spring @Transactional annotations on service methods",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.savingAccountRepository.save(account);\nString accountNumber = \"\";\n// ...\naccountNumber = this.accountNumberGenerator.generate(account, accountNumberFormat);\naccount.updateAccountNo(accountNumber + \"1\");\n// ...\nthis.savingAccountRepository.saveAndFlush(account);"
  },
  {
    "path": "org.apache.fineract.portfolio.savings.service.search.SavingsAccountTransactionSearchService",
    "mechanism": "SPRING-DATA",
    "name": "SavingsAccountTransactionSearchService",
    "description": "While this is an interface, the return type `org.springframework.data.domain.Page` strongly indicates that the implementation interacts with a database using Spring Data or a similar pagination-aware data access layer. The methods are designed to retrieve paginated subsets of data (Transactions) based on IDs and criteria.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Paginated search queries with filtering criteria",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "Page<SavingsAccountTransactionData> searchTransactions(@NotNull Long savingsId, @NotNull TransactionSearchRequest searchParameters);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.account.domain",
    "mechanism": "SPRING-DATA",
    "name": "SelfBeneficiariesTPTRepository",
    "description": "The interface uses Spring Data JPA to interact with the database for the SelfBeneficiariesTPT entity. It inherits standard data access methods automatically.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SelfBeneficiariesTPT"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic queries via JpaSpecificationExecutor.",
    "transactionHandling": "Spring Data repositories typically apply @Transactional to inherited methods by default.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface SelfBeneficiariesTPTRepository\n        extends JpaRepository<SelfBeneficiariesTPT, Long>, JpaSpecificationExecutor<SelfBeneficiariesTPT> {"
  },
  {
    "path": "org.apache.fineract.portfolio.self.account.service",
    "mechanism": "SPRING-DATA",
    "name": "SelfBeneficiariesTPTRepository",
    "description": "The class uses Spring Data JPA repositories to interact with the database. It performs CRUD operations on the `SelfBeneficiariesTPT` entity and read-only lookups on `Loan` and `SavingsAccount` entities via their respective wrapper services.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SelfBeneficiariesTPT",
      "Loan",
      "SavingsAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (saveAndFlush, findById) and wrapper lookups (findNonClosedLoanByAccountNumber).",
    "transactionHandling": "Spring @Transactional annotations on methods.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.saveAndFlush(beneficiary);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.pockets.domain",
    "mechanism": "SPRING-DATA",
    "name": "PocketRepository",
    "description": "The class interacts with the database via a Spring Data repository interface (PocketRepository). It performs CRUD operations such as saving entities and finding records by foreign key (appUserId).",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Pocket"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and finder methods based on entity attributes.",
    "transactionHandling": "Relies on Spring Data's default transaction management for repositories.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.pocketRepository.saveAndFlush(pocket);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.pockets.domain",
    "mechanism": "SPRING-DATA",
    "name": "PocketAccountMappingRepository",
    "description": "The class wraps a Spring Data repository (PocketAccountMappingRepository) to perform CRUD operations on the PocketAccountMapping entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PocketAccountMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and finder methods by ID.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.pocketAccountMappingRepository.save(pocketAccountMapping);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.pockets.domain.PocketAccountMappingRepository",
    "mechanism": "SPRING-DATA",
    "name": "PocketAccountMappingRepository",
    "description": "The interface extends JpaRepository to provide database access for PocketAccountMapping entities using Spring Data JPA.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PocketAccountMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with named parameters for filtering by IDs.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select pam from PocketAccountMapping pam where pam.pocketId =:pocketId\")"
  },
  {
    "path": "org.apache.fineract.portfolio.self.pockets.domain.PocketRepository",
    "mechanism": "SPRING-DATA",
    "name": "PocketRepository",
    "description": "The interface extends JpaRepository to provide database interaction for the Pocket entity using Spring Data JPA.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Pocket"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via annotations and standard CRUD operations inherited from JpaRepository.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select pocket.id from Pocket pocket where pocket.appUserId= :appUserId\")"
  },
  {
    "path": "org.apache.fineract.portfolio.self.pockets.service.PocketWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "PocketRepositoryWrapper, PocketAccountMappingRepositoryWrapper",
    "description": "The class uses repository wrappers (likely wrapping Spring Data JPA repositories) to perform CRUD operations on 'Pocket' and 'PocketAccountMapping' entities. It uses 'saveAndFlush' for creating pockets, 'save' for batch inserting mappings, and 'delete' for removing mappings.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Pocket",
      "PocketAccountMapping"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findByAppUserId, save, delete, findByIdAndPocketId)",
    "transactionHandling": "Spring @Transactional annotations on the class level",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.pocketRepositoryWrapper.saveAndFlush(pocket);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.registration.domain.SelfServiceRegistrationRepository",
    "mechanism": "SPRING-DATA",
    "name": "SelfServiceRegistrationRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending `JpaRepository`, which provides standard CRUD operations, and defines custom JPQL queries via annotations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "SelfServiceRegistration"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries defined via @Query annotation and standard Spring Data CRUD operations.",
    "transactionHandling": "Spring Data JPA repositories typically participate in Spring managed transactions (@Transactional).",
    "protocol": "JPA/JDBC",
    "connectionInfo": "unknown",
    "codeExample": "@Query(FIND_BY_REQUEST_AND_AUTHENTICATION_TOKEN)\nSelfServiceRegistration getRequestByIdAndAuthenticationToken(@Param(\"id\") Long id, ...)"
  },
  {
    "path": "org.apache.fineract.portfolio.self.registration.service.SelfServiceRegistrationWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "SelfServiceRegistrationRepository",
    "description": "The class uses Spring Data JPA repositories (SelfServiceRegistrationRepository, ClientRepositoryWrapper, SmsMessageRepository, RoleRepository, PasswordValidationPolicyRepository) to perform CRUD operations on entities. It also delegates user creation to UserDomainService.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_selfservice_user_registration",
      "m_client",
      "m_appuser",
      "m_role",
      "sms_messages",
      "m_password_validation_policy"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (save, findById, etc.) and some custom finders.",
    "transactionHandling": "Likely managed by Spring @Transactional at the class or interface level (not visible in this file but implied by service layer conventions).",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.selfServiceRegistrationRepository.saveAndFlush(selfServiceRegistration);"
  },
  {
    "path": "org.apache.fineract.portfolio.self.registration.starter.SelfRegistrationConfiguration",
    "mechanism": "SPRING-DATA",
    "name": "SelfServiceRegistrationRepository",
    "description": "The configuration class wires up database access components. It injects a JdbcTemplate for the read platform service (indicating direct JDBC usage) and multiple Spring Data repositories (e.g., SelfServiceRegistrationRepository, ClientRepositoryWrapper, RoleRepository) for the write platform service.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "unknown"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The read service likely uses SQL queries via JdbcTemplate, while the write service uses Spring Data JPA repository methods.",
    "transactionHandling": "Transaction handling is likely managed within the service implementations (SelfServiceRegistrationWritePlatformServiceImpl) rather than this configuration class.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return new SelfServiceRegistrationReadPlatformServiceImpl(jdbcTemplate);"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.domain.ShareAccountDividendRepository",
    "mechanism": "SPRING-DATA",
    "name": "ShareAccountDividendRepository",
    "description": "The interface extends JpaRepository, indicating it uses Spring Data JPA to manage persistence for the ShareAccountDividendDetails entity without writing explicit SQL or JPQL.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ShareAccountDividendDetails"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations provided by JpaRepository.",
    "transactionHandling": "Managed implicitly by Spring Data JPA (usually @Transactional on the proxy).",
    "protocol": "JPA",
    "connectionInfo": "configured externally",
    "codeExample": "public interface ShareAccountDividendRepository\n        extends JpaRepository<ShareAccountDividendDetails, Long>, JpaSpecificationExecutor<ShareAccountDividendDetails> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.domain.ShareAccountRepository",
    "mechanism": "SPRING-DATA",
    "name": "ShareAccountRepository",
    "description": "The interface extends JpaRepository and JpaSpecificationExecutor, leveraging Spring Data JPA to manage database interactions for the ShareAccount entity automatically.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ShareAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specifications provided by Spring Data JPA.",
    "transactionHandling": "Spring @Transactional (implicitly handled by the Spring Data JPA implementation proxy)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ShareAccountRepository extends JpaRepository<ShareAccount, Long>, JpaSpecificationExecutor<ShareAccount> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.domain.ShareAccountRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "ShareAccountRepository",
    "description": "The class wraps a Spring Data repository (ShareAccountRepository) to perform CRUD operations. It relies on the underlying JPA implementation provided by Spring Data to generate SQL queries.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ShareAccount"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (findById, save, saveAndFlush)",
    "transactionHandling": "Delegated to underlying repository or caller (no explicit @Transactional on this class)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.shareAccountRepository.findById(accountId).orElseThrow(() -> new ShareAccountNotFoundException(accountId));"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.serialization.ShareAccountDataSerializer",
    "mechanism": "SPRING-DATA",
    "name": "RepositoryWrappers",
    "description": "The class uses several repository wrappers (ChargeRepositoryWrapper, SavingsAccountRepositoryWrapper, ClientRepositoryWrapper, ShareProductRepositoryWrapper) to interact with the database. These wrappers likely encapsulate Spring Data JPA repositories. The class fetches entities to validate existence and business rules, and modifies the state of the ShareAccount entity which is then persisted by the calling transaction context.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_charge",
      "m_client",
      "m_share_product",
      "m_savings_account",
      "m_share_account",
      "m_share_account_transaction",
      "m_share_account_charge"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via repository methods (findOne, etc.)",
    "transactionHandling": "Implicitly relies on the transaction context of the caller (likely a Service class annotated with @Transactional), as this class is a helper/validator service.",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "ShareProduct shareProduct = this.shareProductRepository.findOneWithNotFoundDetection(productId);"
  },
  {
    "path": "org.apache.fineract.portfolio.shareaccounts.service",
    "mechanism": "SPRING-DATA",
    "name": "ShareAccountDividendRepository",
    "description": "The class uses a Spring Data repository (ShareAccountDividendRepository) to fetch and save dividend details. It also interacts with the database implicitly through the SavingsAccountAssembler and SavingsAccountDomainService which manage SavingsAccount entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ShareAccountDividendDetails",
      "SavingsAccount",
      "SavingsAccountTransaction"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "CRUD operations via Repository methods (findById, saveAndFlush)",
    "transactionHandling": "Spring @Transactional annotation on the postDividend method",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "ShareAccountDividendDetails shareAccountDividendDetails = this.shareAccountDividendRepository.findById(dividendDetailId).orElseThrow();\n...\nthis.shareAccountDividendRepository.saveAndFlush(shareAccountDividendDetails);"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.domain",
    "mechanism": "SPRING-DATA",
    "name": "ShareProductDividentPayOutDetailsRepository",
    "description": "Database integration is achieved through Spring Data JPA. The interface extends JpaRepository, which provides standard CRUD operations, and JpaSpecificationExecutor, which allows for dynamic query construction. The framework automatically maps these methods to database operations for the ShareProductDividendPayOutDetails entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ShareProductDividendPayOutDetails"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic queries via Specifications",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository methods)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ShareProductDividentPayOutDetailsRepository\n        extends JpaRepository<ShareProductDividendPayOutDetails, Long>, JpaSpecificationExecutor<ShareProductDividendPayOutDetails> {\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.domain.ShareProductDividentPayOutDetailsRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "ShareProductDividentPayOutDetailsRepository",
    "description": "The class wraps a Spring Data repository interface to perform database operations on the ShareProductDividendPayOutDetails entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ShareProductDividendPayOutDetails"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.shareProductDividentPayOutDetailsRepository.findById(dividendId)"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.domain.ShareProductRepository",
    "mechanism": "SPRING-DATA",
    "name": "ShareProductRepository",
    "description": "Database integration is achieved through Spring Data JPA, which automatically implements the repository interface to interact with the database tables mapped to the ShareProduct entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ShareProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification-based queries provided by JpaRepository and JpaSpecificationExecutor.",
    "transactionHandling": "Spring @Transactional (implicitly handled by Spring Data JPA implementation)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface ShareProductRepository extends JpaRepository<ShareProduct, Long>, JpaSpecificationExecutor<ShareProduct> {}"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.domain.ShareProductRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "ShareProductRepository",
    "description": "The class interacts with the database through a Spring Data repository interface (ShareProductRepository). It performs standard CRUD operations such as finding by ID and saving entities. The actual SQL generation and execution are handled by the Spring Data JPA implementation backing the repository interface.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ShareProduct"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via Repository abstraction",
    "transactionHandling": "Likely handled by Spring @Transactional at the repository or service level (implicit)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.shareProductRepository.findById(productId).orElseThrow(...)"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.serialization.ShareProductDataSerializer",
    "mechanism": "SPRING-DATA",
    "name": "ChargeRepositoryWrapper",
    "description": "The class uses a repository wrapper to access Charge entities from the database during validation. This is used to verify that charges associated with a share product exist and share the same currency.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Charge"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple lookup by ID",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Charge charge = this.chargeRepository.findOneWithNotFoundDetection(id);"
  },
  {
    "path": "org.apache.fineract.portfolio.shareproducts.service",
    "mechanism": "SPRING-DATA",
    "name": "ShareProductRepositoryWrapper",
    "description": "The class uses repository wrappers (likely wrapping Spring Data JpaRepository interfaces) to interact with the database. It performs CRUD operations and explicit flushing.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "ShareProduct",
      "ShareProductDividendPayOutDetails"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via repository abstraction (save, saveAndFlush, findOne, delete).",
    "transactionHandling": "Implicitly handled by Spring Data repositories or service layer AOP (though @Transactional is not explicitly on this class, saveAndFlush implies transaction participation).",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.saveAndFlush(product);"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.domain",
    "mechanism": "SPRING-DATA",
    "name": "TaxComponentRepository",
    "description": "The class interacts with the database via the TaxComponentRepository, which is a Spring Data repository interface. It performs read operations to locate TaxComponent entities by ID.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TaxComponent"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD (findById)",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "this.repository.findById(id).orElseThrow(() -> new TaxComponentNotFoundException(id))"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.domain.TaxComponentRepository",
    "mechanism": "SPRING-DATA",
    "name": "TaxComponentRepository",
    "description": "Database integration is achieved through Spring Data JPA, which automatically generates the implementation for standard CRUD operations and specification-based queries for the TaxComponent entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TaxComponent"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specification queries provided by Spring Data.",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository implementation)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface TaxComponentRepository extends JpaRepository<TaxComponent, Long>, JpaSpecificationExecutor<TaxComponent> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.domain.TaxGroupRepository",
    "mechanism": "SPRING-DATA",
    "name": "TaxGroupRepository",
    "description": "The interface uses Spring Data JPA to manage persistence for the TaxGroup entity, providing automatic implementation of data access patterns.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TaxGroup"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations and dynamic specifications via Criteria API",
    "transactionHandling": "Spring @Transactional (default for Spring Data Repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface TaxGroupRepository extends JpaRepository<TaxGroup, Long>, JpaSpecificationExecutor<TaxGroup> {\n\n}"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.domain.TaxGroupRepositoryWrapper",
    "mechanism": "SPRING-DATA",
    "name": "TaxGroupRepository",
    "description": "The class wraps a Spring Data repository interface to perform database read operations.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TaxGroup"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD lookup by Primary Key",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.repository.findById(id).orElseThrow(() -> new TaxGroupNotFoundException(id))"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.service.TaxAssembler",
    "mechanism": "SPRING-DATA",
    "name": "GLAccountRepositoryWrapper, TaxComponentRepositoryWrapper",
    "description": "The class uses repository wrappers to perform read-only operations against the database. It fetches 'GLAccount' entities to validate account IDs provided in the JSON payload and 'TaxComponent' entities when assembling tax groups.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "GLAccount (implied)",
      "TaxComponent (implied)"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple entity lookups by ID using repository wrappers.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "debitGlAccount = this.glAccountRepositoryWrapper.findOneWithNotFoundDetection(debitAccountId);"
  },
  {
    "path": "org.apache.fineract.portfolio.tax.service.TaxWritePlatformServiceImpl",
    "mechanism": "SPRING-DATA",
    "name": "TaxComponentRepository and TaxGroupRepository",
    "description": "The class uses Spring Data JPA repositories (injected via constructor) to perform CRUD operations. It uses 'saveAndFlush' for immediate persistence and 'findOneWithNotFoundDetection' (via a wrapper) for retrieval.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "TaxComponent",
      "TaxGroup",
      "TaxGroupMappings"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "Simple CRUD operations via Repository interface methods.",
    "transactionHandling": "Implicitly handled by Spring Data Repository methods or higher-level AOP (not explicit in this class).",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "this.taxComponentRepository.saveAndFlush(taxComponent);"
  },
  {
    "path": "org.apache.fineract.portfolio.transfer.service.TransferWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "Fineract Portfolio Repositories",
    "description": "The class uses multiple Repository Wrappers (which likely wrap Spring Data JpaRepositories) to perform CRUD operations on entities like Client, Group, Office, Loan, and SavingsAccount. It uses @Transactional to ensure atomicity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client",
      "m_group",
      "m_office",
      "m_loan",
      "m_savings_account",
      "m_calendar_instance",
      "m_client_transfer_details",
      "m_staff"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository finders (findOne, findBy...) and save/flush operations.",
    "transactionHandling": "Spring @Transactional annotations on service methods",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.clientRepositoryWrapper.saveAndFlush(client);"
  },
  {
    "path": "org.apache.fineract.spm.api.ScorecardApiResource",
    "mechanism": "SPRING-DATA",
    "name": "ClientRepositoryWrapper / ScorecardService",
    "description": "The class interacts with the database through service layers and repository wrappers. It uses `ClientRepositoryWrapper` (likely wrapping a Spring Data JPA repository) to fetch Client entities and `ScorecardService`/`ScorecardReadPlatformService` to perform CRUD operations on Scorecards. The `@Transactional` annotation on methods indicates that these operations participate in Spring-managed database transactions.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_client",
      "m_survey_scorecards",
      "m_surveys"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The code performs entity lookups by ID (Client, Survey) and creates new entities (Scorecard). Read operations likely involve simple SELECTs with WHERE clauses on foreign keys (survey_id, client_id).",
    "transactionHandling": "Spring @Transactional annotations on public methods",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final Client client = this.clientRepositoryWrapper.findOneWithNotFoundDetection(scorecardData.getClientId());\nthis.scorecardService.createScorecard(ScorecardMapper.map(scorecardData, survey, appUser, client));"
  },
  {
    "path": "org.apache.fineract.spm.domain",
    "mechanism": "SPRING-DATA",
    "name": "SurveyRepository",
    "description": "The code utilizes Spring Data JPA to interact with the database. It extends `JpaRepository` to inherit standard database operations and uses `@Query` annotations to define custom JPQL queries for temporal filtering.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Survey"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries involving temporal 'between' comparisons and exact matches on keys.",
    "transactionHandling": "Transactions are handled by the Spring container; read operations are typically read-only, while inherited write operations are transactional.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"select s from Survey s where :pointInTime between s.validFrom and s.validTo\")"
  },
  {
    "path": "org.apache.fineract.spm.domain.LookupTableRepository",
    "mechanism": "SPRING-DATA",
    "name": "LookupTableRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, which provides standard CRUD operations, and defines custom finder methods that are translated into SQL/JPQL by the Spring framework.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LookupTable"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "simple CRUD",
    "transactionHandling": "Spring @Transactional",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "public interface LookupTableRepository extends JpaRepository<LookupTable, Long> {\n    List<LookupTable> findBySurvey(Survey survey);\n}"
  },
  {
    "path": "org.apache.fineract.spm.domain.ScorecardRepository",
    "mechanism": "SPRING-DATA",
    "name": "ScorecardRepository",
    "description": "The file uses Spring Data JPA to interact with the database. By extending JpaRepository, it gains automatic implementations for standard CRUD operations and supports dynamic query generation based on method names.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Scorecard"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM queries, simple CRUD",
    "transactionHandling": "Spring @Transactional",
    "protocol": "JDBC",
    "connectionInfo": "unknown",
    "codeExample": "public interface ScorecardRepository extends JpaRepository<Scorecard, Long> { ... }"
  },
  {
    "path": "org.apache.fineract.spm.service.LookupTableService",
    "mechanism": "SPRING-DATA",
    "name": "LookupTableRepository",
    "description": "The service uses a Spring Data repository interface (`LookupTableRepository`) to interact with the underlying database. This abstracts the SQL/JPQL logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "LookupTable"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (find by key, find by survey, save all) delegated to Spring Data.",
    "transactionHandling": "Implicitly handled by Spring Data repository methods or higher-level transaction boundaries (not explicit in this file).",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return this.lookupTableRepository.findByKey(key);"
  },
  {
    "path": "org.apache.fineract.spm.service.ScorecardService",
    "mechanism": "SPRING-DATA",
    "name": "ScorecardRepository",
    "description": "The service uses a Spring Data repository (`ScorecardRepository`) to perform CRUD operations on `Scorecard` entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Scorecard"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD and finder methods provided by Spring Data JPA.",
    "transactionHandling": "Implicitly handled by Spring Data repository methods (default transactional behavior), though no explicit @Transactional annotation is present on the service methods.",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "return this.scorecardRepository.saveAll(scorecards);"
  },
  {
    "path": "org.apache.fineract.spm.service.SpmService",
    "mechanism": "SPRING-DATA",
    "name": "SurveyRepository",
    "description": "The class interacts with the database via the `SurveyRepository` interface, which is injected by Spring. It performs CRUD operations (save, findById) and custom queries (fetchActiveSurveys, findByKey). It explicitly handles JPA and Data Integrity exceptions to manage database constraints.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Survey",
      "m_survey_scorecards"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via Repository pattern, plus custom fetch methods for active surveys and finding by key.",
    "transactionHandling": "Implicitly handled by Spring Data Repository methods (saveAndFlush), though no explicit @Transactional annotation is present on the service class itself.",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "this.surveyRepository.saveAndFlush(survey);"
  },
  {
    "path": "org.apache.fineract.template.domain",
    "mechanism": "SPRING-DATA",
    "name": "TemplateRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, which provides standard CRUD operations, and defines custom query methods for specific lookups.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Template",
      "Template.mappers"
    ],
    "operationType": [
      "READ",
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with joins and derived query methods",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select t from Template as t left join t.mappers as m where m.mapperkey = :mapperkey and m.mappervalue = :mappervalue\")"
  },
  {
    "path": "org.apache.fineract.template.service.JpaTemplateDomainService",
    "mechanism": "SPRING-DATA",
    "name": "TemplateRepository",
    "description": "The class uses a Spring Data repository interface (`TemplateRepository`) to perform CRUD operations on the database. It relies on Spring's `@Transactional` annotation to manage transaction boundaries for data modification methods.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Template"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations and finder methods (findAll, findById, findByEntityAndType).",
    "transactionHandling": "Spring @Transactional annotations on state-changing methods (create, update, remove).",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.templateRepository.saveAndFlush(template);"
  },
  {
    "path": "org.apache.fineract.useradministration.domain",
    "mechanism": "SPRING-DATA",
    "name": "AppUserPreviousPasswordRepository",
    "description": "The code uses Spring Data JPA to interact with the database. By extending `JpaRepository`, it abstracts the underlying JDBC and SQL interactions, allowing object-oriented manipulation of the `AppUserPreviousPassword` entity.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AppUserPreviousPassword"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Spring Data derived query methods and standard CRUD operations.",
    "transactionHandling": "Spring Data JPA default transaction management (typically read-only for find methods, transactional for writes).",
    "protocol": "JDBC (via Hibernate/JPA)",
    "connectionInfo": "unknown",
    "codeExample": "List<AppUserPreviousPassword> history = repository.findByUserId(123L, PageRequest.of(0, 5));"
  },
  {
    "path": "org.apache.fineract.useradministration.domain",
    "mechanism": "SPRING-DATA",
    "name": "AppUserRepository",
    "description": "The class interacts with the database via the injected `AppUserRepository`, which is likely a Spring Data repository interface.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AppUser"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple CRUD find by name",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "AppUser user = this.appUserRepository.findAppUserByName(AppUserConstants.SYSTEM_USER_NAME);"
  },
  {
    "path": "org.apache.fineract.useradministration.domain",
    "mechanism": "SPRING-DATA",
    "name": "AppUserRepository",
    "description": "The class uses a Spring Data JPA repository (AppUserRepository) to persist AppUser entities. It performs save and flush operations within a transactional context.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AppUser"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations (save, saveAndFlush)",
    "transactionHandling": "Spring @Transactional annotation on the class and method",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.userRepository.saveAndFlush(appUser);"
  },
  {
    "path": "org.apache.fineract.useradministration.domain",
    "mechanism": "SPRING-DATA",
    "name": "PermissionRepository",
    "description": "The file uses Spring Data JPA to interact with the database. It extends JpaRepository to provide standard data access methods and defines a custom JPQL query for specific lookup logic.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Permission"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries with string manipulation functions (LOWER, TRIM) to handle case-insensitivity and whitespace.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"SELECT p FROM Permission p WHERE LOWER(TRIM(BOTH FROM p.code)) = LOWER(TRIM(BOTH FROM ?1))\")\nPermission findOneByCode(@Param(\"code\") String code);"
  },
  {
    "path": "org.apache.fineract.useradministration.domain",
    "mechanism": "SPRING-DATA",
    "name": "PasswordValidationPolicyRepository",
    "description": "The file uses Spring Data JPA repositories to interact with the database. It inherits standard CRUD methods and defines a custom JPQL query to filter entities based on their active status.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PasswordValidationPolicy"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "ORM QUERIES",
    "transactionHandling": "Spring @Transactional (implicit in JpaRepository)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"select PVP from PasswordValidationPolicy PVP WHERE PVP.active = true\")"
  },
  {
    "path": "org.apache.fineract.useradministration.domain.AppUserRepository",
    "mechanism": "SPRING-DATA",
    "name": "AppUserRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database by extending JpaRepository, which provides standard CRUD operations, and defines custom query methods for specific data retrieval needs.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AppUser"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Uses JPQL via @Query annotation and Spring Data derived query methods.",
    "transactionHandling": "Spring @Transactional (implicit in Spring Data repositories)",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "@Query(\"Select appUser from AppUser appUser where appUser.username = :username\")\nAppUser findAppUserByName(@Param(\"username\") String username);"
  },
  {
    "path": "org.apache.fineract.useradministration.domain.RoleRepository",
    "mechanism": "SPRING-DATA",
    "name": "RoleRepository",
    "description": "The file is a Spring Data JPA repository interface. It interacts with the database using the Java Persistence API (JPA) through Spring's abstraction layer. It defines custom queries using JPQL to access Role and AppUser tables.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Role",
      "AppUser"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "JPQL queries involving joins and case-insensitive filtering.",
    "transactionHandling": "Spring @Transactional annotations (implicit in JpaRepository)",
    "protocol": "JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "@Query(\"SELECT COUNT(a) FROM AppUser a JOIN a.roles r WHERE r.id = :roleId AND a.deleted = false\")"
  },
  {
    "path": "org.apache.fineract.useradministration.service",
    "mechanism": "SPRING-DATA",
    "name": "PermissionRepository",
    "description": "The class uses a Spring Data JPA repository (PermissionRepository) to interact with the database. It retrieves all permission entities and saves updates to specific permission entities.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Permission"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findAll, saveAndFlush).",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.permissionRepository.saveAndFlush(permission);"
  },
  {
    "path": "org.apache.fineract.useradministration.service",
    "mechanism": "SPRING-DATA",
    "name": "PasswordValidationPolicyRepository",
    "description": "The class uses a Spring Data JPA repository (`PasswordValidationPolicyRepository`) to interact with the database. It performs bulk reads and writes to manage the state of password validation policies.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PasswordValidationPolicy"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Simple CRUD operations involving finding all records and saving a collection of records.",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "JPA/JDBC",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final List<PasswordValidationPolicy> validationPolicies = this.validationRepository.findAll();\n// ... logic ...\nthis.validationRepository.saveAll(validationPolicies);"
  },
  {
    "path": "org.apache.fineract.useradministration.service.AppUserWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "AppUserRepository",
    "description": "The class uses Spring Data JPA repositories (AppUserRepository, OfficeRepositoryWrapper, RoleRepository, etc.) to interact with the database. It performs CRUD operations on AppUser entities and retrieves related entities like Office, Staff, and Role.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "AppUser",
      "Office",
      "Role",
      "Staff",
      "Client",
      "AppUserPreviousPassword"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard JPA repository methods (findById, save, saveAndFlush) and some custom finders (findByUserId).",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA",
    "connectionInfo": "not identifiable from code",
    "codeExample": "this.appUserRepository.saveAndFlush(userToUpdate);"
  },
  {
    "path": "org.apache.fineract.useradministration.service.RoleWritePlatformServiceJpaRepositoryImpl",
    "mechanism": "SPRING-DATA",
    "name": "RoleRepository, PermissionRepository",
    "description": "The class uses Spring Data JPA repositories (RoleRepository, PermissionRepository) to persist and retrieve Role and Permission entities. It utilizes @Transactional for transaction management and handles DataIntegrityViolationException for constraint enforcement.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Role",
      "Permission"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "Standard CRUD operations via JpaRepository methods (saveAndFlush, findById, delete, findAll) and a custom count query (getCountOfRolesAssociatedWithUsers).",
    "transactionHandling": "Spring @Transactional annotations on service methods.",
    "protocol": "JPA",
    "connectionInfo": "n/a",
    "codeExample": "final Role entity = Role.fromJson(command);\nthis.roleRepository.saveAndFlush(entity);"
  },
  {
    "path": "org.apache.fineract.useradministration.service.UserDataValidator",
    "mechanism": "SPRING-DATA",
    "name": "PasswordValidationPolicyRepository",
    "description": "The class uses a Spring Data repository to fetch the active password validation policy from the database. This policy contains the regex pattern used to validate user passwords.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "PasswordValidationPolicy"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Simple repository lookup to find the active policy.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "final PasswordValidationPolicy validationPolicy = this.passwordValidationPolicy.findActivePasswordValidationPolicy();\nfinal String regex = validationPolicy.getRegex();"
  },
  {
    "path": "org.apache.fineract.useradministration.starter",
    "mechanism": "SPRING-DATA",
    "name": "UserAdministrationRepositories",
    "description": "The configuration class wires up database interactions by injecting Spring Data JPA repositories (e.g., AppUserRepository, RoleRepository) and the Spring JDBC Template into service implementations. The 'Read' services typically use JdbcTemplate for direct SQL queries, while 'Write' services use JPA Repositories for domain entity management.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_appuser",
      "m_role",
      "m_permission",
      "m_password_validation_policy"
    ],
    "operationType": [
      "READ_WRITE"
    ],
    "queryPatterns": "The configuration enables both ORM-based CRUD operations (via JPA Repositories) and direct SQL read operations (via JdbcTemplate).",
    "transactionHandling": "Transaction handling is likely managed by the service implementations (e.g., @Transactional) which are instantiated here, rather than in this configuration class itself.",
    "protocol": "JDBC",
    "connectionInfo": "Configured via Spring Boot DataSource (not visible in this file)",
    "codeExample": "@Bean\npublic AppUserReadPlatformService appUserReadPlatformService(..., JdbcTemplate jdbcTemplate, ...) {\n    return new AppUserReadPlatformServiceImpl(..., jdbcTemplate, ...);\n}"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/ceda/bk_ceda_trial.sql",
    "mechanism": "SQL",
    "name": "Mifos Tenant Database",
    "description": "The file is a MySQL database dump that utilizes standard SQL DDL to create the schema and DML to populate it. It defines a comprehensive relational model for a microfinance application (Mifos), including tables for clients, loans, savings, and system configuration. It uses InnoDB for transaction support and foreign key constraints.",
    "databaseName": "mifostenant-ceda",
    "tablesAccessed": [
      "acc_gl_account",
      "acc_gl_closure",
      "acc_gl_journal_entry",
      "acc_product_mapping",
      "c_configuration",
      "client additional data",
      "impact measurement",
      "loan additional data",
      "m_appuser",
      "m_appuser_role",
      "m_calendar",
      "m_calendar_instance",
      "m_charge",
      "m_client",
      "m_client_identifier",
      "m_code",
      "m_code_value",
      "m_currency",
      "m_document",
      "m_fund",
      "m_group",
      "m_group_client",
      "m_group_level",
      "m_guarantor",
      "m_loan",
      "m_loan_arrears_aging",
      "m_loan_charge",
      "m_loan_collateral",
      "m_loan_officer_assignment_history",
      "m_loan_repayment_schedule",
      "m_loan_transaction",
      "m_note",
      "m_office",
      "m_office_transaction",
      "m_organisation_currency",
      "m_permission",
      "m_portfolio_command_source",
      "m_product_loan",
      "m_product_loan_charge",
      "m_role",
      "m_role_permission",
      "m_savings_account",
      "m_savings_account_transaction",
      "m_savings_product",
      "m_staff",
      "r_enum_value",
      "rpt_sequence",
      "schema_version",
      "stretchy_parameter",
      "stretchy_report",
      "stretchy_report_parameter",
      "x_registered_table"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements, INSERT operations, complex reporting queries stored in text fields",
    "transactionHandling": "LOCK TABLES/UNLOCK TABLES for bulk inserts",
    "protocol": "MySQL 5.1.60",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "CREATE TABLE `acc_gl_account` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) NOT NULL,\n  `parent_id` BIGINT DEFAULT NULL,\n  ...\n) ENGINE=InnoDB AUTO_INCREMENT=98 DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-db/mifospltaform-tenants-first-time-install.sql",
    "mechanism": "SQL",
    "name": "fineract_tenants initialization",
    "description": "The file is a raw SQL dump that performs direct database initialization using DDL to create schema structures and DML to populate initial data. It interacts directly with the MySQL server to set up the `fineract_tenants` database.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [
      "schema_version",
      "tenants",
      "timezones"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements, INSERT statements with bulk values, LOCK/UNLOCK TABLES",
    "transactionHandling": "Implicit transactions via LOCK TABLES and atomic INSERT statements",
    "protocol": "MySQL 5.1.60",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "CREATE TABLE `tenants` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `identifier` varchar(100) NOT NULL,\n  `name` varchar(100) NOT NULL,\n  ...\n) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/0001-mifos-platform-shared-tenants.sql",
    "mechanism": "SQL",
    "name": "fineract_tenants",
    "description": "The file is a raw MySQL dump script that integrates directly with the database server to initialize the schema and data. It combines Data Definition Language (DDL) to create the `tenants` and `timezones` tables and Data Manipulation Language (DML) to populate them with initial records. The script manages the database state by dropping existing objects and locking tables during write operations to ensure atomicity of the bulk inserts.",
    "databaseName": "fineract_tenants",
    "tablesAccessed": [
      "tenants",
      "timezones"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements, INSERT operations with bulk values, LOCK/UNLOCK TABLES for integrity",
    "transactionHandling": "Explicit LOCK TABLES and UNLOCK TABLES statements surround the INSERT operations",
    "protocol": "MySQL 5.1.60",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "CREATE TABLE `tenants` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `identifier` varchar(100) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=UTF8MB4;\nINSERT INTO `tenants` VALUES (1,'default',...);"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/ceda/ceda-user-office-product-setup.sql",
    "mechanism": "SQL",
    "name": "Seed Data Script",
    "description": "The file integrates with the database by executing raw SQL statements directly against the schema. It functions as a data migration or seed script, utilizing DML operations to populate tables with initial configuration data. There is no application layer code; the integration is purely at the database command level. It handles relationships between entities manually through foreign key values in INSERT statements.",
    "databaseName": "mifos/fineract",
    "tablesAccessed": [
      "m_organisation_currency",
      "m_appuser",
      "m_appuser_role",
      "m_office",
      "m_staff",
      "m_charge",
      "m_product_loan",
      "acc_product_mapping"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Direct INSERT, UPDATE, and DELETE statements using hardcoded values.",
    "transactionHandling": "Implicit auto-commit or script-level transaction depending on the runner.",
    "protocol": "MySQL",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "INSERT INTO `m_organisation_currency`\n(\n`code`,\n`decimal_places`,\n`name`,\n`display_symbol`,\n`internationalized_name_code`)\nVALUES\n('UGX', 2, 'Uganda Shilling', 'USh', 'currency.UGX');"
  },
  {
    "path": "kubernetes/fineractmysql-configmap.yml",
    "mechanism": "SQL",
    "name": "MySQL Initialization Script",
    "description": "Database integration is achieved through a raw SQL script embedded in a Kubernetes ConfigMap, designed to be executed directly by the MySQL engine to bootstrap the database environment.",
    "databaseName": "fineract_tenants, fineract_default",
    "tablesAccessed": [],
    "operationType": [
      "DDL",
      "ADMIN"
    ],
    "queryPatterns": "Database creation commands and user privilege granting statements.",
    "transactionHandling": "Implicit auto-commit typically used for initialization scripts.",
    "protocol": "MySQL",
    "connectionInfo": "n/a",
    "codeExample": "CREATE DATABASE IF NOT EXISTS `fineract_tenants`;\nCREATE DATABASE IF NOT EXISTS `fineract_default`;\nGRANT ALL ON *.* TO 'root'@'%';"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/bare-bones-demo/bk_bare_bones_demo.sql",
    "mechanism": "SQL",
    "name": "MySQL Database Dump",
    "description": "The file is a raw SQL dump that integrates with a MySQL database by executing DDL (Data Definition Language) to create the schema and DML (Data Manipulation Language) to populate it. It defines the entire database structure including tables, primary keys, and foreign key constraints. Additionally, it contains embedded SQL queries stored as strings within the `stretchy_report` and `stretchy_parameter` tables, which are used by the application's reporting engine to execute dynamic queries at runtime.",
    "databaseName": "fineract_default",
    "tablesAccessed": [
      "acc_gl_account",
      "acc_gl_closure",
      "acc_gl_journal_entry",
      "acc_product_mapping",
      "c_configuration",
      "client additional data",
      "extra_client_details",
      "extra_family_details",
      "extra_loan_details",
      "impact measurement",
      "loan additional data",
      "m_appuser",
      "m_appuser_role",
      "m_calendar",
      "m_calendar_instance",
      "m_charge",
      "m_client",
      "m_client_identifier",
      "m_code",
      "m_code_value",
      "m_currency",
      "m_document",
      "m_fund",
      "m_group",
      "m_group_client",
      "m_group_level",
      "m_guarantor",
      "m_loan",
      "m_loan_arrears_aging",
      "m_loan_charge",
      "m_loan_collateral",
      "m_loan_officer_assignment_history",
      "m_loan_repayment_schedule",
      "m_loan_transaction",
      "m_note",
      "m_office",
      "m_office_transaction",
      "m_organisation_currency",
      "m_permission",
      "m_portfolio_command_source",
      "m_product_loan",
      "m_product_loan_charge",
      "m_role",
      "m_role_permission",
      "m_savings_account",
      "m_savings_account_transaction",
      "m_savings_product",
      "m_staff",
      "r_enum_value",
      "rpt_sequence",
      "stretchy_parameter",
      "stretchy_report",
      "stretchy_report_parameter",
      "x_registered_table"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements, INSERT INTO statements, and embedded SELECT queries stored in the stretchy_report table.",
    "transactionHandling": "Explicit LOCK TABLES and UNLOCK TABLES for bulk insert consistency.",
    "protocol": "MySQL 5.1.60",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "DROP TABLE IF EXISTS `acc_gl_account`;\nCREATE TABLE `acc_gl_account` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-provider/src/main/resources/sql/migrations/sample_data/load_sample_data.sql",
    "mechanism": "SQL",
    "name": "Mifos X / Apache Fineract Database Schema",
    "description": "The file is a raw SQL dump containing both Data Definition Language (DDL) for creating the database schema and Data Manipulation Language (DML) for seeding initial reference data. It is designed to be executed by a database migration tool (likely Flyway, given the 'schema_version' table) or manually imported into a MySQL database to initialize the persistence layer for the application.",
    "databaseName": "mifostenant-reference",
    "tablesAccessed": [
      "acc_accounting_rule",
      "acc_gl_account",
      "acc_gl_closure",
      "acc_gl_financial_activity_account",
      "acc_gl_journal_entry",
      "acc_product_mapping",
      "acc_rule_tags",
      "c_account_number_format",
      "c_cache",
      "c_configuration",
      "c_external_service",
      "c_external_service_properties",
      "job",
      "job_run_history",
      "mix_taxonomy",
      "mix_taxonomy_mapping",
      "mix_xbrl_namespace",
      "m_account_transfer_details",
      "m_account_transfer_standing_instructions",
      "m_account_transfer_standing_instructions_history",
      "m_account_transfer_transaction",
      "m_address",
      "m_appuser",
      "m_appuser_previous_password",
      "m_appuser_role",
      "m_calendar",
      "m_calendar_history",
      "m_calendar_instance",
      "m_cashiers",
      "m_cashier_transactions",
      "m_charge",
      "m_client",
      "m_client_address",
      "m_client_attendance",
      "m_client_charge",
      "m_client_charge_paid_by",
      "m_client_identifier",
      "m_client_non_person",
      "m_client_transaction",
      "m_code",
      "m_code_value",
      "m_currency",
      "m_deposit_account_on_hold_transaction",
      "m_deposit_account_recurring_detail",
      "m_deposit_account_term_and_preclosure",
      "m_deposit_product_interest_rate_chart",
      "m_deposit_product_recurring_detail",
      "m_deposit_product_term_and_preclosure",
      "m_document",
      "m_entity_datatable_check",
      "m_entity_relation",
      "m_entity_to_entity_access",
      "m_entity_to_entity_mapping",
      "m_field_configuration",
      "m_floating_rates",
      "m_floating_rates_periods",
      "m_fund",
      "m_group",
      "m_group_client",
      "m_group_level",
      "m_group_roles",
      "m_guarantor",
      "m_guarantor_funding_details",
      "m_guarantor_transaction",
      "m_holiday",
      "m_holiday_office",
      "m_hook",
      "m_hook_configuration",
      "m_hook_registered_events",
      "m_hook_schema",
      "m_hook_templates",
      "m_image",
      "m_interest_incentives",
      "m_interest_rate_chart",
      "m_interest_rate_slab",
      "m_loan",
      "m_loanproduct_provisioning_entry",
      "m_loanproduct_provisioning_mapping",
      "m_loan_arrears_aging",
      "m_loan_charge",
      "m_loan_charge_paid_by",
      "m_loan_collateral",
      "m_loan_disbursement_detail",
      "m_loan_installment_charge",
      "m_loan_interest_recalculation_additional_details",
      "m_loan_officer_assignment_history",
      "m_loan_overdue_installment_charge",
      "m_loan_paid_in_advance",
      "m_loan_recalculation_details",
      "m_loan_repayment_schedule",
      "m_loan_repayment_schedule_history",
      "m_loan_reschedule_request",
      "m_loan_reschedule_request_term_variations_mapping",
      "m_loan_term_variations",
      "m_loan_topup",
      "m_loan_tranche_charges",
      "m_loan_tranche_disbursement_charge",
      "m_loan_transaction",
      "m_loan_transaction_repayment_schedule_mapping",
      "m_mandatory_savings_schedule",
      "m_meeting",
      "m_note",
      "m_office",
      "m_office_transaction",
      "m_organisation_currency",
      "m_password_validation_policy",
      "m_payment_detail",
      "m_payment_type",
      "m_permission",
      "m_portfolio_account_associations",
      "m_portfolio_command_source",
      "m_product_loan",
      "m_product_loan_charge",
      "m_product_loan_configurable_attributes",
      "m_product_loan_floating_rates",
      "m_product_loan_guarantee_details",
      "m_product_loan_recalculation_details",
      "m_product_loan_variable_installment_config",
      "m_product_loan_variations_borrower_cycle",
      "m_product_mix",
      "m_provisioning_criteria",
      "m_provisioning_criteria_definition",
      "m_provisioning_history",
      "m_provision_category",
      "m_report_mailing_job",
      "m_report_mailing_job_configuration",
      "m_report_mailing_job_run_history",
      "m_role",
      "m_role_permission",
      "m_savings_account",
      "m_savings_account_charge",
      "m_savings_account_charge_paid_by",
      "m_savings_account_interest_rate_chart",
      "m_savings_account_interest_rate_slab",
      "m_savings_account_transaction",
      "m_savings_account_transaction_tax_details",
      "m_savings_interest_incentives",
      "m_savings_officer_assignment_history",
      "m_savings_product",
      "m_savings_product_charge",
      "m_selfservice_beneficiaries_tpt",
      "m_selfservice_user_client_mapping",
      "m_share_account",
      "m_share_account_charge",
      "m_share_account_charge_paid_by",
      "m_share_account_dividend_details",
      "m_share_account_transactions",
      "m_share_product",
      "m_share_product_charge",
      "m_share_product_dividend_pay_out",
      "m_share_product_market_price",
      "m_staff",
      "m_staff_assignment_history",
      "m_surveys",
      "m_survey_components",
      "m_survey_lookup_tables",
      "m_survey_questions",
      "m_survey_responses",
      "m_survey_scorecards",
      "m_tax_component",
      "m_tax_component_history",
      "m_tax_group",
      "m_tax_group_mappings",
      "m_tellers",
      "m_template",
      "m_templatemappers",
      "m_template_m_templatemappers",
      "m_working_days",
      "oauth_access_token",
      "oauth_client_details",
      "oauth_refresh_token",
      "ppi_likelihoods",
      "ppi_likelihoods_ppi",
      "ppi_scores",
      "rpt_sequence",
      "r_enum_value",
      "scheduler_detail",
      "schema_version",
      "sms_campaign",
      "sms_messages_outbound",
      "stretchy_parameter",
      "stretchy_report",
      "stretchy_report_parameter",
      "x_registered_table",
      "x_table_column_code_mappings"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements, INSERT statements for reference data",
    "transactionHandling": "Not explicitly defined in script, likely handled by the execution tool",
    "protocol": "MySQL 5.6+",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "CREATE TABLE IF NOT EXISTS `acc_gl_account` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `name` varchar(200) NOT NULL,\n  `gl_code` varchar(45) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/ceda/bk_core_with_custom_and_coa.sql",
    "mechanism": "SQL",
    "name": "Mifos Tenant Database (CEDA)",
    "description": "The file is a raw SQL dump containing both Data Definition Language (DDL) to create the schema and Data Manipulation Language (DML) to insert initial data. It defines a relational structure for a microfinance application. A unique integration feature is the 'stretchy_report' table, which stores full SQL SELECT statements as text data; the application reads these strings at runtime to execute dynamic reports against the database, effectively treating the database as a repository for its own reporting logic. The schema also includes a 'schema_version' table, indicating integration with a migration tool like Flyway.",
    "databaseName": "mifostenant-ceda",
    "tablesAccessed": [
      "acc_gl_account",
      "acc_gl_closure",
      "acc_gl_journal_entry",
      "acc_product_mapping",
      "c_configuration",
      "client additional data",
      "impact measurement",
      "loan additional data",
      "m_appuser",
      "m_appuser_role",
      "m_calendar",
      "m_calendar_instance",
      "m_charge",
      "m_client",
      "m_client_identifier",
      "m_code",
      "m_code_value",
      "m_currency",
      "m_document",
      "m_fund",
      "m_group",
      "m_group_client",
      "m_group_level",
      "m_guarantor",
      "m_loan",
      "m_loan_arrears_aging",
      "m_loan_charge",
      "m_loan_collateral",
      "m_loan_officer_assignment_history",
      "m_loan_repayment_schedule",
      "m_loan_transaction",
      "m_note",
      "m_office",
      "m_office_transaction",
      "m_organisation_currency",
      "m_permission",
      "m_portfolio_command_source",
      "m_product_loan",
      "m_product_loan_charge",
      "m_role",
      "m_role_permission",
      "m_savings_account",
      "m_savings_account_transaction",
      "m_savings_product",
      "m_staff",
      "r_enum_value",
      "rpt_sequence",
      "schema_version",
      "stretchy_parameter",
      "stretchy_report",
      "stretchy_report_parameter",
      "x_registered_table"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements, INSERT INTO statements, and embedded SELECT queries stored within the 'stretchy_report' table for dynamic reporting.",
    "transactionHandling": "Uses explicit LOCK TABLES and UNLOCK TABLES commands to ensure data consistency during the dump restoration process.",
    "protocol": "MySQL 5.1.60",
    "codeExample": "CREATE TABLE `m_client` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `account_no` varchar(20) NOT NULL,\n  `office_id` BIGINT NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-provider/src/main/resources/sql/migrations/sample_data/barebones_db.sql",
    "mechanism": "SQL",
    "description": "The file is a comprehensive SQL script that performs both Data Definition (DDL) and Data Manipulation (DML). It creates the entire database schema for the Fineract application, including tables for accounting, clients, loans, savings, and system configurations. It establishes relationships between these entities using foreign keys. Furthermore, it populates the database with initial reference data, such as permissions, roles, default configurations, and report definitions, using INSERT statements.",
    "databaseName": "fineract_default",
    "tablesAccessed": [
      "acc_accounting_rule",
      "acc_gl_account",
      "acc_gl_journal_entry",
      "c_configuration",
      "job",
      "m_appuser",
      "m_client",
      "m_group",
      "m_loan",
      "m_loan_transaction",
      "m_office",
      "m_permission",
      "m_product_loan",
      "m_role",
      "m_savings_account",
      "m_staff",
      "stretchy_report",
      "schema_version"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements, INSERT INTO statements, ALTER TABLE statements",
    "transactionHandling": "none",
    "protocol": "MySQL 5.6+",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "CREATE TABLE IF NOT EXISTS `m_client` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `account_no` varchar(20) NOT NULL,\n  `office_id` BIGINT NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/bk_mifostenant_default.sql",
    "mechanism": "SQL",
    "name": "Fineract Database Schema",
    "description": "The file interacts with the database using raw SQL commands. It primarily uses Data Definition Language (DDL) to define the schema structure (tables, keys, constraints) and Data Manipulation Language (DML) to insert initial configuration data. The script is designed to be executed directly against a MySQL server to initialize the 'fineract_default' database.",
    "databaseName": "fineract_default",
    "tablesAccessed": [
      "acc_gl_account",
      "acc_gl_closure",
      "acc_gl_journal_entry",
      "acc_product_mapping",
      "c_configuration",
      "client additional data",
      "extra_client_details",
      "extra_family_details",
      "extra_loan_details",
      "impact measurement",
      "loan additional data",
      "m_appuser",
      "m_appuser_role",
      "m_calendar",
      "m_calendar_instance",
      "m_charge",
      "m_client",
      "m_client_identifier",
      "m_code",
      "m_code_value",
      "m_currency",
      "m_document",
      "m_fund",
      "m_group",
      "m_group_client",
      "m_group_level",
      "m_guarantor",
      "m_loan",
      "m_loan_arrears_aging",
      "m_loan_charge",
      "m_loan_collateral",
      "m_loan_officer_assignment_history",
      "m_loan_repayment_schedule",
      "m_loan_transaction",
      "m_note",
      "m_office",
      "m_office_transaction",
      "m_organisation_currency",
      "m_permission",
      "m_portfolio_command_source",
      "m_product_loan",
      "m_product_loan_charge",
      "m_role",
      "m_role_permission",
      "m_savings_account",
      "m_savings_account_transaction",
      "m_savings_product",
      "m_staff",
      "r_enum_value",
      "rpt_sequence",
      "stretchy_parameter",
      "stretchy_report",
      "stretchy_report_parameter",
      "x_registered_table"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements, INSERT statements for seed data, ALTER TABLE for constraints",
    "transactionHandling": "Implicit transactions via LOCK TABLES / UNLOCK TABLES during data insertion",
    "protocol": "MySQL 5.1.60",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "CREATE TABLE `acc_gl_account` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) NOT NULL,\n  `parent_id` BIGINT DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=98 DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/default-demo/bk_mifostenant-default.sql",
    "mechanism": "SQL",
    "name": "Fineract Database Schema",
    "description": "The file interacts with the database using raw SQL commands. It primarily uses Data Definition Language (DDL) to define the schema structure (tables, keys, constraints) and Data Manipulation Language (DML) to insert initial configuration data. The script is designed to be executed directly against a MySQL server to initialize the 'fineract_default' database.",
    "databaseName": "fineract_default",
    "tablesAccessed": [
      "acc_gl_account",
      "acc_gl_closure",
      "acc_gl_journal_entry",
      "acc_product_mapping",
      "c_configuration",
      "client additional data",
      "extra_client_details",
      "extra_family_details",
      "extra_loan_details",
      "impact measurement",
      "loan additional data",
      "m_appuser",
      "m_appuser_role",
      "m_calendar",
      "m_calendar_instance",
      "m_charge",
      "m_client",
      "m_client_identifier",
      "m_code",
      "m_code_value",
      "m_currency",
      "m_document",
      "m_fund",
      "m_group",
      "m_group_client",
      "m_group_level",
      "m_guarantor",
      "m_loan",
      "m_loan_arrears_aging",
      "m_loan_charge",
      "m_loan_collateral",
      "m_loan_officer_assignment_history",
      "m_loan_repayment_schedule",
      "m_loan_transaction",
      "m_note",
      "m_office",
      "m_office_transaction",
      "m_organisation_currency",
      "m_permission",
      "m_portfolio_command_source",
      "m_product_loan",
      "m_product_loan_charge",
      "m_role",
      "m_role_permission",
      "m_savings_account",
      "m_savings_account_transaction",
      "m_savings_product",
      "m_staff",
      "r_enum_value",
      "rpt_sequence",
      "stretchy_parameter",
      "stretchy_report",
      "stretchy_report_parameter",
      "x_registered_table"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "CREATE TABLE statements, INSERT statements for seed data, ALTER TABLE for constraints",
    "transactionHandling": "Implicit transactions via LOCK TABLES / UNLOCK TABLES during data insertion",
    "protocol": "MySQL 5.1.60",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "CREATE TABLE `acc_gl_account` (\n  `id` BIGINT NOT NULL AUTO_INCREMENT,\n  `name` varchar(45) NOT NULL,\n  `parent_id` BIGINT DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=98 DEFAULT CHARSET=UTF8MB4;"
  },
  {
    "path": "fineract-provider/src/main/resources/sql/migrations/sample_data/interop_sample_data.sql",
    "mechanism": "SQL",
    "name": "Financial System Configuration Script",
    "description": "The file interacts with the database purely through raw SQL scripts containing DML (Data Manipulation Language) operations. It uses SQL variables (e.g., @last_saving_prod_id) to maintain referential integrity across multiple INSERT statements without needing hardcoded IDs. It performs reads to determine current max IDs and writes to create new configuration entities.",
    "databaseName": "mifos_platform_tenants (inferred from table naming conventions)",
    "tablesAccessed": [
      "m_savings_product",
      "m_payment_type",
      "acc_gl_account",
      "acc_product_mapping",
      "m_charge"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "The script uses SELECT statements to fetch current maximum IDs or specific reference IDs into variables, followed by INSERT statements that utilize these variables.",
    "transactionHandling": "Implicit transaction handling (script execution flow).",
    "protocol": "MySQL / MariaDB (inferred from syntax like @variable and concat)",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "SET @saving_prod_name = concat('Saving Product', @last_saving_prod_id);\nINSERT INTO `m_savings_product`\n(`name`, `short_name`, `description`, ...)\nVALUES (@saving_prod_name, concat('SP', @last_saving_prod_id), ...);"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/default-demo/README.md",
    "mechanism": "SQL",
    "name": "Demo Database Initialization",
    "description": "The documentation describes a database initialization process that involves running DDL for the latest schema and inserting mandatory reference data (DML). It specifies the creation of core entities required for the application to function.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "Currency",
      "Office",
      "Permission",
      "Role",
      "User"
    ],
    "operationType": [
      "DDL",
      "WRITE"
    ],
    "queryPatterns": "Database schema creation and initial data seeding for deployment.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "n/a"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/ceda/ceda-schema-customisations.sql",
    "mechanism": "SQL",
    "name": "Database Initialization Script",
    "description": "The file interacts with the database via direct SQL execution, combining DDL for schema extensions and DML for data seeding. It creates new tables to store additional business data and populates configuration tables to integrate these extensions into the application framework.",
    "databaseName": "Mifos/Fineract Schema (implied)",
    "tablesAccessed": [
      "m_code",
      "m_code_value",
      "client additional data",
      "m_client",
      "impact measurement",
      "m_loan",
      "loan additional data",
      "x_registered_table",
      "m_permission",
      "acc_gl_account"
    ],
    "operationType": [
      "DDL",
      "WRITE",
      "READ"
    ],
    "queryPatterns": "CREATE TABLE with Foreign Keys, INSERT INTO ... VALUES, INSERT INTO ... SELECT, TRUNCATE TABLE",
    "transactionHandling": "Implicit (Auto-commit assumed for script execution)",
    "protocol": "MySQL / MariaDB (inferred from syntax like backticks and engine definition)",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "INSERT INTO `m_code` (`code_name`, `is_system_defined`)\nVALUES\n('FieldOfEmployment', '0'),\n('EducationLevel', '0');\nCREATE TABLE `client additional data` (...);"
  },
  {
    "path": "fineract-db/multi-tenant-demo-backups/default-demo/extra-datatables-and-code-values.sql",
    "mechanism": "SQL",
    "name": "Database Initialization Script",
    "description": "The file integrates with the database by directly executing raw SQL commands to modify both the schema and the data. It utilizes DDL to create new extension tables and DML to insert configuration data, register application metadata, and populate the general ledger.",
    "databaseName": "Mifos/Fineract (implied by table prefixes)",
    "tablesAccessed": [
      "m_code",
      "m_code_value",
      "extra_client_details",
      "m_client",
      "extra_family_details",
      "extra_loan_details",
      "m_loan",
      "x_registered_table",
      "m_permission",
      "acc_gl_account"
    ],
    "operationType": [
      "READ",
      "WRITE",
      "DDL",
      "ADMIN"
    ],
    "queryPatterns": "The script uses INSERT INTO ... SELECT patterns for dynamic data population, standard CREATE TABLE statements for schema definition, and bulk INSERT statements for static data loading.",
    "transactionHandling": "Implicit transaction handling per statement (auto-commit) is typical for such scripts, though not explicitly defined.",
    "protocol": "MySQL / MariaDB (inferred from syntax like `ifnull`, backticks, and ENGINE=InnoDB)",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "INSERT INTO `m_code_value`(`code_id`,`code_value`,`order_position`)\nselect mc.id, 'option.Male', ifnull(max(mv.id), 1)\nfrom m_code mc\njoin m_code_value mv on mv.code_id = mc.id\nwhere mc.`code_name` = \"Gender\";"
  },
  {
    "path": "fineract-provider/src/main/resources/sql/migrations/sample_data/tn04_interop_sample_data.sql",
    "mechanism": "SQL",
    "name": "Data Initialization Script",
    "description": "The code is a direct SQL script used for data manipulation and initialization. It interacts directly with the database engine to insert records and query existing data to resolve foreign keys. It uses MySQL-specific variable syntax to pass data between statements within the script execution session.",
    "databaseName": "tn04",
    "tablesAccessed": [
      "m_client",
      "m_savings_product",
      "m_savings_account",
      "interop_identifier",
      "m_charge",
      "m_savings_account_charge"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "The script uses a pattern of setting variables, performing INSERTs, and using SELECT ... INTO @variable to resolve foreign keys for subsequent INSERTs.",
    "transactionHandling": "Implicit transaction handling (relies on the session's auto-commit settings or external transaction wrapping).",
    "protocol": "MySQL / MariaDB",
    "connectionInfo": "not applicable for SQL files",
    "codeExample": "SET @client_name = 'InteropMerchant';\nINSERT INTO `m_client` (`account_no`, ... ) VALUES (@saving_account_no, ...);\nSET @saving_prod_id = -1;\nSELECT id FROM m_savings_product WHERE name = @saving_prod_name INTO @saving_prod_id;\nINSERT INTO `m_savings_account` ... VALUES ...;"
  },
  {
    "path": "org.apache.fineract.commands.api.AuditsApiResource",
    "mechanism": "SQL",
    "name": "AuditReadPlatformService",
    "description": "The class constructs SQL fragments using a `SQLBuilder` utility class. While it does not execute the query directly (delegating that to the service layer), it explicitly defines the SQL WHERE clauses and column aliases (e.g., 'aud.action_name', 'aud.entity_name') used to query the database.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "aud"
    ],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation based on optional filter parameters.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "not identifiable from code",
    "codeExample": "extraCriteria.addNonNullCriteria(\"aud.action_name = \", actionName);\nif (entityName != null) {\n    extraCriteria.addCriteria(\"aud.entity_name like\", entityName + \"%\");\n}\nextraCriteria.addNonNullCriteria(\"aud.resource_id = \", resourceId);"
  },
  {
    "path": "org.apache.fineract.commands.api.MakercheckersApiResource",
    "mechanism": "SQL",
    "name": "AuditReadPlatformService / SQLBuilder",
    "description": "The class constructs dynamic SQL WHERE clauses using a `SQLBuilder` utility. It references specific database columns (aliased with 'aud.') corresponding to the audit/command source table. These criteria are passed to the service layer for execution.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "aud (alias for audit table)"
    ],
    "operationType": [
      "READ",
      "WRITE"
    ],
    "queryPatterns": "Dynamic SQL generation for filtering audit entries based on multiple optional criteria.",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "unknown",
    "codeExample": "SQLBuilder extraCriteria = new SQLBuilder();\nextraCriteria.addNonNullCriteria(\"aud.action_name = \", actionName);\nif (entityName != null) {\n    extraCriteria.addCriteria(\"aud.entity_name like \", entityName + \"%\");\n}\nextraCriteria.addNonNullCriteria(\"aud.resource_id = \", resourceId);"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.data.PaginationParameters",
    "mechanism": "SQL",
    "name": "PaginationParameters",
    "description": "This class is responsible for dynamically generating SQL fragments for 'ORDER BY', 'LIMIT', and 'OFFSET' clauses. It does not execute queries directly but prepares safe, validated SQL strings to be appended to database queries in other components. It explicitly validates input using 'SQLInjectionValidator' to prevent SQL injection.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation for pagination and sorting",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "sql.append(\" limit \").append(this.getLimit());"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database",
    "mechanism": "SQL",
    "name": "DatabaseSpecificSQLGenerator",
    "description": "This class is a helper for generating raw SQL strings compatible with either MySQL or PostgreSQL. It does not execute queries itself but constructs valid SQL syntax for other components to execute via JDBC.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ",
      "WRITE",
      "READ_WRITE"
    ],
    "queryPatterns": "Dynamic SQL generation including SELECT, INSERT, UPDATE, JOINs, and dialect-specific function calls.",
    "transactionHandling": "none",
    "protocol": "MySQL or PostgreSQL",
    "connectionInfo": "n/a",
    "codeExample": "if (databaseTypeResolver.isMySQL()) {\n    return format(\"LIMIT %s,%s\", offset, count);\n} else if (databaseTypeResolver.isPostgreSQL()) {\n    return format(\"LIMIT %s OFFSET %s\", count, offset);\n}"
  },
  {
    "path": "org.apache.fineract.infrastructure.core.service.database.SqlOperator",
    "mechanism": "SQL",
    "name": "SqlOperator",
    "description": "This class is a utility for generating SQL WHERE clause fragments. It does not execute queries itself but constructs SQL strings representing comparisons (e.g., 'col = val', 'col LIKE %val%') used by other data access components.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "OTHER"
    ],
    "queryPatterns": "Dynamic SQL generation for filtering criteria",
    "transactionHandling": "none",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "return format(\"%s %s %s\", definition, getSymbol(), sqlGenerator.formatValue(columnType, \"%\" + values[0] + \"%\"));"
  },
  {
    "path": "org.apache.fineract.infrastructure.dataqueries.service",
    "mechanism": "SQL",
    "name": "GenericDataService",
    "description": "The interface explicitly defines methods for executing raw SQL strings passed as arguments. It acts as a direct gateway for dynamic SQL execution against the database.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL queries passed as strings",
    "transactionHandling": "unknown",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "GenericResultsetData fillGenericResultSet(String sql);"
  },
  {
    "path": "org.apache.fineract.infrastructure.security.utils",
    "mechanism": "SQL",
    "name": "SQLBuilder",
    "description": "This class is a utility for dynamically constructing SQL WHERE clauses. While it does not execute queries directly, it generates SQL strings and manages parameters for use with JDBC PreparedStatements or Spring JdbcTemplate.",
    "databaseName": "unknown",
    "tablesAccessed": [],
    "operationType": [
      "READ"
    ],
    "queryPatterns": "Dynamic SQL generation for filtering criteria",
    "transactionHandling": "none",
    "protocol": "JDBC",
    "connectionInfo": "n/a",
    "codeExample": "sb.append(trimmedCriteria);\nsb.append(\" ?\");\ncrts.add(trimmedCriteria);\nargs.add(argument);"
  },
  {
    "path": "org.apache.fineract.infrastructure.survey.service",
    "mechanism": "SQL",
    "name": "ReadWriteNonCoreDataService",
    "description": "The class interacts with the database primarily by constructing raw SQL strings for permission management and delegating execution to 'ReadWriteNonCoreDataService'. It manually builds INSERT statements for the 'm_permission' table.",
    "databaseName": "unknown",
    "tablesAccessed": [
      "m_permission"
    ],
    "operationType": [
      "WRITE"
    ],
    "queryPatterns": "Inline SQL string construction for INSERT statements.",
    "transactionHandling": "Spring @Transactional annotations",
    "protocol": "unknown",
    "connectionInfo": "n/a",
    "codeExample": "return \"insert into m_permission (\" + columns + \") values \" + \"('datatable', \" + createPermission + \", 'CREATE', '\" + dataTableName\n                + \"', false),\" + \"('datatable', \" + createPermissionChecker + \", 'CREATE', '\" + dataTableName + \"', false),\""
  }
]