GENERATED-BY: VertexAIGemini

REQUIREMENT: New Features: Act as a senior programmer analyzing the code in a TypeScript application, where the content of each file in the application's codebase is shown below in a code block. The project analyzes a legacy application, reporting as many important details as possible to help new users understand its structure, size, and nuances. However, the project could be significantly improved in terms of the types and depth of details it captures. Identify at least 5 new informative aspects of legacy applications that the project could capture and report on, to provide users with additional insights into how the application works and is constructed. Consider that the legacy application will be around 10-40 years old, and the user wants to analyze the application with a view to modernizing it from an ancient technology stack (which they may understand little about) to a modern technology stack. For each new aspect, provide references to the specific part(s) of the code that would be altered and/or added to, with a plan on how to apply and verify the changes/additions required. Include the list or relative file paths of each source file affected.

RECOMENDATIONS:

As a senior programmer analyzing this TypeScript application, I've identified several opportunities to significantly enhance its value for users aiming to modernize legacy applications. The current tool provides a strong foundation by capturing architectural and structural details. However, for a 10-40 year old application, a deeper analysis of specific modernization pain points is crucial.

Here are 5 new informative aspects the project could capture and report on, along with a plan for implementation and verification.

---

### 1. Data Model and Schema Analysis

**Value for Modernization**: Understanding the legacy data model is arguably the most critical part of any modernization effort. The current tool identifies database interactions but doesn't provide a consolidated view of the database schema itself. This feature would analyze DDL files (`.sql`) and ORM configurations to extract a detailed data model, including tables, columns, data types, and relationships. This is essential for planning database migration, identifying data type incompatibilities with modern databases, and designing new microservice persistence layers.

**Implementation Plan**:

1.  **Enhance Data Capture for SQL Files**:
    *   **File**: `src/components/capture/config/capture.config.ts`
    *   **Change**: Update the `instructions` for the `sql` file type in `fileTypeMetadataConfig`. The new prompt will instruct the LLM to parse `CREATE TABLE` statements and extract table names, column names, data types, primary keys, and foreign key constraints. The existing `tables` schema in `src/schemas/sources.schema.ts` is already suitable for capturing this.

2.  **Create a New "Data Model" Insight Category**:
    *   **File**: `src/schemas/app-summaries.schema.ts`
    *   **Change**: Add `"dataModel"` to the `AppSummaryCategories` enum. Define new Zod schemas (`columnSchema`, `foreignKeySchema`, `tableSchema`, `dataModelSchema`) to represent a structured data model.
    *   **File**: `src/components/insights/insights-generation.config.ts`
    *   **Change**: Add a new configuration for `dataModel` to `summaryCategoriesConfig`, linking it to the new `dataModelSchema`.

3.  **Implement Data Model Aggregation**:
    *   **File**: `src/components/insights/insights-from-db-generator.ts`
    *   **Change**: This class will be updated to orchestrate the new data model generation step. It will use a new `DataModelGenerator` component.
    *   **New File**: `src/components/insights/data-model-generator.ts`
    *   **Add**: This new component will query the `sources` collection for all files containing DDL information (from the `summary.tables` field). It will then use an LLM to consolidate these fragments into a unified data model, resolving relationships and ensuring consistency.

4.  **Update Reporting**:
    *   **File**: `src/components/reporting/app-report-generator.ts`
    *   **Change**: Fetch the new `dataModel` data from the `AppSummaryRepository` and pass it to the report writers.
    *   **New File**: `src/components/reporting/templates/partials/data-model.ejs`
    *   **Add**: Create a new EJS partial to render the data model as a series of tables. For an advanced report, this could also generate Mermaid-syntax for an ERD diagram.
    *   **File**: `src/components/reporting/templates/main.ejs`
    *   **Change**: Include the new `data-model.ejs` partial in the main report template.

**Verification Plan**:
1.  Analyze a sample project containing `.sql` files with `CREATE TABLE` statements.
2.  Run `npm run build` and then `node ./dist/src/cli/capture-codebase.js`.
3.  Inspect the `sources` collection in MongoDB to confirm that documents for the `.sql` files have their `summary.tables` field populated.
4.  Run `node ./dist/src/cli/generate-insights-from-db.js`.
5.  Inspect the `appsummaries` collection to verify that a `dataModel` field has been created with a consolidated list of tables and columns.
6.  Run `node ./dist/src/cli/produce-report.js` and open the generated `codebase-report.html` to ensure the "Data Model" section is present and correctly formatted.

**Affected Files**:
*   `src/schemas/app-summaries.schema.ts`
*   `src/components/insights/insights-generation.config.ts`
*   `src/components/capture/config/capture.config.ts`
*   `src/components/insights/insights-from-db-generator.ts`
*   `src/components/reporting/app-report-generator.ts`
*   `src/components/reporting/templates/main.ejs`
*   **New**: `src/components/insights/data-model-generator.ts`
*   **New**: `src/components/reporting/templates/partials/data-model.ejs`

---

### 2. Dependency and Library Version Analysis

**Value for Modernization**: Legacy applications often rely on a multitude of third-party libraries, many of which may be outdated, unsupported, or have known security vulnerabilities. This feature would parse build files (`pom.xml`, `package.json`, etc.) to create a comprehensive Bill of Materials (BOM). This BOM is invaluable for assessing technical debt, planning library upgrades, and identifying security risks that must be remediated during modernization.

**Implementation Plan**:

1.  **Enhance Capture to Identify Dependencies**:
    *   **File**: `src/components/capture/config/file-type-mappings.config.ts`
    *   **Change**: Add new mappings for build files, e.g., `pom.xml` -> `maven`, `build.gradle` -> `gradle`, `package.json` -> `npm`.
    *   **File**: `src/components/capture/config/capture.config.ts`
    *   **Change**: Create new prompt configurations in `fileTypeMetadataConfig` for these new file types. The prompt will instruct the LLM to extract a list of dependencies, including their group/artifact ID (or name) and version.
    *   **File**: `src/schemas/sources.schema.ts`
    *   **Change**: Add a `dependencies` array to `sourceSummarySchema` using a new `dependencySchema`.

2.  **Create a "Bill of Materials" Insight Category**:
    *   **File**: `src/schemas/app-summaries.schema.ts`
    *   **Change**: Add `"billOfMaterials"` to `AppSummaryCategories` and define a `billOfMaterialsSchema` to store a de-duplicated list of all dependencies, highlighting any version conflicts found across different build files.
    *   **File**: `src/components/insights/insights-generation.config.ts`
    *   **Change**: Add a new configuration for `billOfMaterials` to `summaryCategoriesConfig`.

3.  **Implement BOM Aggregation**:
    *   **New File**: `src/components/insights/bom-aggregator.ts`
    *   **Add**: This new component will query the `sources` collection for all documents with a `summary.dependencies` field. It will aggregate these into a single list, identify any libraries with multiple versions, and store the result in the `appsummaries` collection.

4.  **Update Reporting**:
    *   **File**: `src/components/reporting/app-report-generator.ts`
    *   **Change**: Fetch the `billOfMaterials` data and pass it to the report writers.
    *   **New File**: `src/components/reporting/templates/partials/bom.ejs`
    *   **Add**: Create a new partial to render the BOM as a table, with a column to flag version conflicts.
    *   **File**: `src/components/reporting/templates/main.ejs`
    *   **Change**: Include the new `bom.ejs` partial.

**Verification Plan**:
1.  Analyze a project with a `pom.xml` (for Java) or `package.json` (for Node.js).
2.  Run `capture-codebase` and verify that the `summary.dependencies` field is populated in the MongoDB document for the build file.
3.  Run `generate-insights-from-db` and check the `appsummaries` collection for the `billOfMaterials` document.
4.  Run `produce-report` and check the HTML report for the new "Bill of Materials" section.

**Affected Files**:
*   `src/schemas/sources.schema.ts`
*   `src/schemas/app-summaries.schema.ts`
*   `src/components/capture/config/capture.config.ts`
*   `src/components/capture/config/file-type-mappings.config.ts`
*   `src/components/insights/insights-from-db-generator.ts`
*   `src/components/reporting/app-report-generator.ts`
*   `src/components/reporting/templates/main.ejs`
*   **New**: `src/components/insights/bom-aggregator.ts`
*   **New**: `src/components/reporting/templates/partials/bom.ejs`

---

### 3. Code Quality and "Code Smell" Metrics

**Value for Modernization**: Modernization isn't just about changing technology; it's an opportunity to improve code quality. This feature would analyze the code to identify "code smells" and calculate complexity metrics. Metrics like cyclomatic complexity, long methods, and large classes help pinpoint high-risk, hard-to-maintain code. This data allows teams to prioritize refactoring efforts, estimate the complexity of migration, and make informed decisions about which components to rewrite versus lift-and-shift.

**Implementation Plan**:

1.  **Enhance Capture to Extract Code Metrics**:
    *   **File**: `src/components/capture/config/capture.config.ts`
    *   **Change**: For code file types (`java`, `javascript`, etc.), update the prompt instructions to ask the LLM to estimate cyclomatic complexity and line counts for each public method, and to identify common code smells.
    *   **File**: `src/schemas/sources.schema.ts`
    *   **Change**: Enhance `publicMethodSchema` to include `cyclomaticComplexity`, `linesOfCode`, and `codeSmells`. Add a `codeQualityMetrics` object to `sourceSummarySchema` for file-level metrics.

2.  **Create a "Code Quality" Insight Category**:
    *   **File**: `src/schemas/app-summaries.schema.ts`
    *   **Change**: Add `"codeQualitySummary"` to `AppSummaryCategories`. Define a `codeQualitySummarySchema` to store aggregated metrics, such as a list of the "Top 10 Most Complex Methods" and a summary of the most common code smells found.
    *   **File**: `src/components/insights/insights-generation.config.ts`
    *   **Change**: Add a new configuration for `codeQualitySummary`.

3.  **Implement Code Quality Aggregation**:
    *   **New File**: `src/components/insights/code-quality-aggregator.ts`
    *   **Add**: This component will query the `sources` collection, aggregate all code quality metrics, calculate statistics, and store the summary in the `appsummaries` collection.

4.  **Update Reporting**:
    *   **File**: `src/components/reporting/app-report-generator.ts`
    *   **Change**: Fetch the `codeQualitySummary` data.
    *   **New File**: `src/components/reporting/templates/partials/code-quality.ejs`
    *   **Add**: Create a new partial to render the code quality summary, including tables for the most complex methods and most frequent code smells.
    *   **File**: `src/components/reporting/templates/main.ejs`
    *   **Change**: Include the new `code-quality.ejs` partial.

**Verification Plan**:
1.  Run `capture-codebase` on a sample project. Verify that the `summary.publicMethods` array in the `sources` collection contains the new quality metrics.
2.  Run `generate-insights-from-db` and check the `appsummaries` collection for the `codeQualitySummary` document.
3.  Run `produce-report` and check the HTML report for the new "Code Quality Summary" section.

**Affected Files**:
*   `src/schemas/sources.schema.ts`
*   `src/schemas/app-summaries.schema.ts`
*   `src/components/capture/config/capture.config.ts`
*   `src/components/insights/insights-from-db-generator.ts`
*   `src/components/reporting/app-report-generator.ts`
*   `src/components/reporting/templates/main.ejs`
*   **New**: `src/components/insights/code-quality-aggregator.ts`
*   **New**: `src/components/reporting/templates/partials/code-quality.ejs`

---

### 4. Batch Processing and Scheduled Jobs Analysis

**Value for Modernization**: Legacy systems often contain critical business logic hidden within batch scripts (`.sh`, `.bat`), mainframe JCL, or `cron` jobs. These non-interactive workflows are easily missed by analyses that focus on user-facing application code. Identifying these jobs, their triggers (e.g., time-based), and their functions is essential for a successful modernization, as this logic must be migrated to modern equivalents like serverless functions, Kubernetes CronJobs, or event-driven architectures.

**Implementation Plan**:

1.  **Enhance Capture to Identify Batch Jobs**:
    *   **File**: `src/components/capture/config/file-type-mappings.config.ts`
    *   **Change**: Add mappings for script files like `.sh`, `.bat`, and potentially `.jcl` or `crontab` files.
    *   **File**: `src/components/capture/config/capture.config.ts`
    *   **Change**: Create new prompt configurations for these file types, instructing the LLM to identify if the file defines a batch job, its trigger, purpose, and any input/output resources.
    *   **File**: `src/schemas/sources.schema.ts`
    *   **Change**: Add an optional `scheduledJobs` array to `sourceSummarySchema` using a new `scheduledJobSchema`.

2.  **Create a "Scheduled Jobs" Insight Category**:
    *   **File**: `src/schemas/app-summaries.schema.ts`
    *   **Change**: Add `"scheduledJobsSummary"` to `AppSummaryCategories` and define a `scheduledJobsSummarySchema` to list all discovered jobs and their properties.
    *   **File**: `src/components/insights/insights-generation.config.ts`
    *   **Change**: Add a new configuration for `scheduledJobsSummary`.

3.  **Implement Job Aggregation**:
    *   **New File**: `src/components/insights/job-aggregator.ts`
    *   **Add**: This component will query the `sources` collection for documents with a `summary.scheduledJobs` field, aggregate them, and store the consolidated list in `appsummaries`.

4.  **Update Reporting**:
    *   **File**: `src/components/reporting/app-report-generator.ts`
    *   **Change**: Fetch the `scheduledJobsSummary` data.
    *   **New File**: `src/components/reporting/templates/partials/scheduled-jobs.ejs`
    *   **Add**: Create a new partial to render the list of identified jobs.
    *   **File**: `src/components/reporting/templates/main.ejs`
    *   **Change**: Include the new `scheduled-jobs.ejs` partial.

**Verification Plan**:
1.  Analyze a project containing shell scripts or other job-defining files.
2.  Run `capture-codebase` and verify that the `summary.scheduledJobs` field is populated in the relevant documents in the `sources` collection.
3.  Run `generate-insights-from-db` and check the `appsummaries` collection for the `scheduledJobsSummary` document.
4.  Run `produce-report` and check the HTML report for the new "Scheduled Jobs" section.

**Affected Files**:
*   `src/schemas/sources.schema.ts`
*   `src/schemas/app-summaries.schema.ts`
*   `src/components/capture/config/capture.config.ts`
*   `src/components/capture/config/file-type-mappings.config.ts`
*   `src/components/insights/insights-from-db-generator.ts`
*   `src/components/reporting/app-report-generator.ts`
*   `src/components/reporting/templates/main.ejs`
*   **New**: `src/components/insights/job-aggregator.ts`
*   **New**: `src/components/reporting/templates/partials/scheduled-jobs.ejs`

---

### 5. Security Vulnerability Analysis

**Value for Modernization**: Legacy applications are often rife with security vulnerabilities that are unacceptable in modern systems. This feature would scan for common anti-patterns like hardcoded secrets (passwords, API keys), the use of outdated and broken cryptographic algorithms (e.g., MD5, DES), and insecure connection strings. Identifying these issues early is a top priority, as they represent critical risks that must be remediated during the modernization process.

**Implementation Plan**:

1.  **Enhance Capture to Detect Security Vulnerabilities**:
    *   **File**: `src/components/capture/config/capture.config.ts`
    *   **Change**: For all code file types, update the prompt instructions to ask the LLM to identify hardcoded secrets, outdated cryptography, and other common security smells.
    *   **File**: `src/schemas/sources.schema.ts`
    *   **Change**: Add an optional `securityVulnerabilities` array to `sourceSummarySchema` using a new `securityVulnerabilitySchema` that includes fields for `type`, `description`, `severity`, and `codeSnippet`.

2.  **Create a "Security Summary" Insight Category**:
    *   **File**: `src/schemas/app-summaries.schema.ts`
    *   **Change**: Add `"securitySummary"` to `AppSummaryCategories` and define a `securitySummarySchema` to aggregate all identified vulnerabilities.
    *   **File**: `src/components/insights/insights-generation.config.ts`
    *   **Change**: Add a new configuration for `securitySummary`.

3.  **Implement Security Aggregation**:
    *   **New File**: `src/components/insights/security-aggregator.ts`
    *   **Add**: This component will query the `sources` collection for all documents with a `summary.securityVulnerabilities` field, aggregate them, and store the result in `appsummaries`.

4.  **Update Reporting**:
    *   **File**: `src/components/reporting/app-report-generator.ts`
    *   **Change**: Fetch the `securitySummary` data.
    *   **New File**: `src/components/reporting/templates/partials/security-summary.ejs`
    *   **Add**: Create a new partial to render the list of potential vulnerabilities, grouped by severity. This section should include a prominent disclaimer that the findings are AI-generated and require manual verification.
    *   **File**: `src/components/reporting/templates/main.ejs`
    *   **Change**: Include the new `security-summary.ejs` partial.

**Verification Plan**:
1.  Create a test file containing a hardcoded password (e.g., `String dbPassword = "admin";`).
2.  Run `capture-codebase` and verify that the `summary.securityVulnerabilities` field is populated for that file's document in MongoDB.
3.  Run `generate-insights-from-db` and check the `appsummaries` collection for the `securitySummary` document.
4.  Run `produce-report` and check the HTML report for the new "Security Summary" section, including the disclaimer.

**Affected Files**:
*   `src/schemas/sources.schema.ts`
*   `src/schemas/app-summaries.schema.ts`
*   `src/components/capture/config/capture.config.ts`
*   `src/components/insights/insights-from-db-generator.ts`
*   `src/components/reporting/app-report-generator.ts`
*   `src/components/reporting/templates/main.ejs`
*   **New**: `src/components/insights/security-aggregator.ts`
*   **New**: `src/components/reporting/templates/partials/security-summary.ejs`
